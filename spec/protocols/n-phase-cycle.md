# N-Phase Cycle Protocol

> *"The 'N' is not a number—it is a variable. The cycle adapts to the task."*

## Overview

The N-Phase Cycle is a self-similar, category-theoretic lifecycle protocol for multi-session agent-human collaboration. It provides structured process without rigidity, enabling both humans and agents to navigate complex work across session boundaries.

## The Three Phases (Default)

```
SENSE → ACT → REFLECT → (loop)
```

| Phase | Purpose | Contains |
|-------|---------|----------|
| **SENSE** | Understand the terrain | Plan, Research, Develop, Strategize, Cross-Synergize |
| **ACT** | Execute with verification | Implement, QA, Test, Educate |
| **REFLECT** | Learn from outcomes | Measure, Reflect, Re-Metabolize |

Use three phases for 90% of work. Escalate to eleven only for Crown Jewels.

## The Eleven Phases (Full Ceremony)

```
PLAN → RESEARCH → DEVELOP → STRATEGIZE → CROSS-SYNERGIZE
                    ↓
IMPLEMENT → QA → TEST → EDUCATE → MEASURE → REFLECT
                                              ↓
                                        (loop or detach)
```

Each phase is a **morphism** in a category where:
- **Objects**: Phase boundaries (states of knowledge)
- **Morphisms**: Phase executions (transformations)
- **Composition**: `(A >> B) >> C ≡ A >> (B >> C)` (associativity)
- **Identity**: Empty phase (pass-through)

## Seven Invariant Properties

1. **Self-Similar** — Each phase contains a hologram of the full cycle
2. **Category-Theoretic** — Phases compose lawfully; identity and associativity hold
3. **Agent-Human Parity** — No privileged author; equally consumable by both
4. **Mutable** — The cycle evolves via re-metabolization
5. **Auto-Continuative** — Each phase generates the next prompt
6. **Accountable** — Skipped phases leave explicit debt
7. **Elastic** — The cycle stretches, compresses, branches, and recombines based on situational dynamics

## The Elasticity Principle

> *"The river does not ask permission to fork around a boulder."*

The N-Phase Cycle is **not** a fixed sequence. It is an **elastic tree generator** that adapts to:

| Signal | Response | Mechanism |
|--------|----------|-----------|
| Complexity spike | Expand phases (3→11) | Phase escalation |
| Momentum stall | Compress phases (11→3) | Phase condensation |
| Scope discovery | Branch parallel tracks | Tree forking |
| Convergence | Merge tracks | Tree joining |
| Serendipity | Lean into tangent | Void.entropy.sip |
| Blockage | Skip with debt | Explicit accountability |

### Dynamic Phase Selection

At every transition, the cycle evaluates:

```
EXPAND when:
  - Complexity(next_phase) > threshold
  - Uncertainty(scope) > threshold
  - Stakes(outcome) require ceremony

COMPRESS when:
  - Pattern(task) is known
  - Momentum > 80% progress per session
  - Entropy budget depleted

BRANCH when:
  - Scope discovers independent tracks
  - Serendipity reveals opportunity
  - Parallel execution reduces critical path

LEAN INTO when:
  - Void.entropy.sip reveals promising tangent
  - Counterfactual thinking suggests pivot
  - Accursed Share beckons
```

### Serendipitous Decision Making

The cycle does not just tolerate serendipity—it **invites** it. At each phase transition:

1. **Sip entropy**: `void.entropy.sip(amount=0.05-0.10)`
2. **Sample alternatives**: What else could we do here?
3. **Evaluate serendipity score**: Does the tangent align with principles?
4. **Commit or note**: Either branch, or record in bounty for future

The decision to branch, compress, or lean in is **situationally emergent**, not pre-planned

## Auto-Inducer Signifiers

End phase output with signifiers to control flow:

| Signifier | Unicode | Meaning |
|-----------|---------|---------|
| `⟿[PHASE]` | U+27FF | Continue to PHASE (linear) |
| `⟂[REASON]` | U+27C2 | Halt, await human input |
| `⤳[OP:args]` | U+2933 | Elastic tree operation |
| *(none)* | — | Await human (backwards compatible) |

### Elastic Operations (⤳)

```
⤳[BRANCH:name]      # Fork new parallel track
⤳[JOIN:tracks]      # Merge tracks at sync point
⤳[COMPRESS:phases]  # Condense phases (11→3)
⤳[EXPAND:phase]     # Expand phase (3→11)
```

**Law**: Every cycle MUST reach `⟂` eventually.

## Entropy Budget

- **Per phase**: 0.05–0.10 (5-10% for exploration)
- **Draw**: `void.entropy.sip(amount=0.07)`
- **Return unused**: `void.entropy.pour`
- **Replenish**: `void.gratitude.tithe`

## Phase Condensation

Phases in the same family can merge when complexity doesn't warrant separation:

| Family | Phases | Can Merge To |
|--------|--------|--------------|
| SENSE | PLAN, RESEARCH, DEVELOP, STRATEGIZE, CROSS-SYNERGIZE | Single SENSE phase |
| ACT | IMPLEMENT, QA, TEST, EDUCATE | Single ACT phase |
| REFLECT | MEASURE, REFLECT | Single REFLECT phase |

**Principle**: Three Phases compress Eleven without loss.

## Elastic Tree Building

The N-Phase Cycle generates **outlines adapted to user tastes, project complexity, and substrate constraints**:

### User Taste Adaptation

| Taste Signal | Tree Shape | Rationale |
|--------------|------------|-----------|
| Prefers depth | Full 11-phase, detailed branches | Ceremony matches preference |
| Prefers speed | 3-phase, aggressive compression | Velocity matches preference |
| Prefers exploration | Wide branching, high entropy budget | Discovery matches preference |
| Prefers certainty | Linear, minimal branching | Predictability matches preference |

### Project Complexity Adaptation

| Complexity Signal | Tree Shape |
|-------------------|------------|
| Single-file change | No tree (direct action) |
| Known pattern | 3-phase linear |
| Novel feature | 11-phase with branches |
| Cross-cutting concern | Multi-track parallel tree |
| Crown Jewel | Full ceremony + meta-reflection |

### Substrate Adaptation

| Substrate | Tree Constraint |
|-----------|-----------------|
| Single session | Complete within session |
| Multi-session | Explicit DETACH/ATTACH handles |
| Multi-agent | Parallel branches with sync points |
| Human-only | Longer phases, async reflection |
| Agent-only | Shorter phases, tighter loops |

### Tree Operations

```
FORK(phase) → [track_a, track_b, ...]  # Split into parallel branches
JOIN(tracks) → phase                     # Merge branches at sync point
PRUNE(branch) → bounty                   # Remove branch, preserve seed
GRAFT(bounty) → branch                   # Attach deferred branch
COMPRESS(phases) → phase                 # Merge adjacent phases
EXPAND(phase) → phases                   # Split phase into sequence
```

These operations preserve the category laws: identity and associativity hold across tree mutations

## Phase Selection

| Task | Phases | Rationale |
|------|--------|-----------|
| Trivial (typo) | 0 | Direct action |
| Quick win (Effort ≤ 2) | ACT only | Known pattern |
| Standard feature | 3 | SENSE → ACT → REFLECT |
| Crown Jewel | 11 | Full ceremony required |

## Metatheoretical Grounding

The N-Phase Cycle synthesizes:

| Framework | Contribution |
|-----------|--------------|
| OODA (Boyd) | Tempo, iteration, competitive advantage |
| PDCA (Deming) | Control loop, hypothesis testing |
| Double-Loop (Argyris) | Question the question, change frames |
| Reflection-in-Action (Schön) | Real-time adjustment within phases |
| Category Theory | Lawful composition, identity, associativity |

## AGENTESE Mapping

| Phase | Primary Context | Affordances |
|-------|-----------------|-------------|
| SENSE | `world.*`, `concept.*` | `manifest`, `witness` |
| ACT | `self.*`, `world.*` | `refine`, `define` |
| REFLECT | `time.*`, `void.*` | `witness`, `tithe` |

## Related

- **Implementation Guides**: `docs/skills/n-phase-cycle/`
- **Auto-Inducer Spec**: `spec/protocols/auto-inducer.md`
- **Forest Protocol**: `plans/_forest.md`, `plans/_focus.md`
- **Design Principles**: `spec/principles.md` (AD-005)

---

*"The form is the function. Each prompt generates its successor by the same principles that generated itself."*
