# ASHC-KBlock Integration: Derivation Context at Creation Time

**Status:** Proposal
**Implementation:** `impl/claude/services/k_block/derivation_service.py` (planned)
**Tests:** (planned: ~40 tests)

> *"The K-Block IS the derivation. Context flows from principle to content."*

---

## Purpose

Bridge ASHC derivation computation with K-Block lifecycle to ensure every K-Block carries principled justification from creation through deletion.

**Why this integration matters:**

1. K-Blocks are the transactional editing containers for all content
2. ASHC's DerivationPath provides categorical morphisms with Galois loss
3. Without integration, K-Blocks exist without derivation context
4. With integration, every K-Block knows its principled justification

The integration answers: *"Why does this content exist? What principles ground it?"*

---

## Core Insight

```
K-Block creation triggers derivation computation.
Derivation context flows into K-Block.
The K-Block carries its own justification.
```

The K-Block's `galois_loss` field already exists. This integration populates it with real Galois loss from ASHC computation, not default zeros.

---

## Type Signatures

### DerivationContext

```python
@dataclass(frozen=True)
class DerivationContext:
    """
    Derivation context computed for a K-Block.

    Captures the categorical morphism from principles to content,
    with Galois loss quantifying semantic coherence.
    """

    kblock_id: str
    derivation_path: DerivationPath | None
    galois_loss: float  # 0.0 = perfect coherence, 1.0 = incoherent
    grounded: bool  # Has path to L1 axioms
    principle_scores: dict[str, float]  # Per-principle alignment
    witnesses: tuple[DerivationWitness, ...]
    computed_at: datetime

    @property
    def coherence(self) -> float:
        """Coherence = 1 - galois_loss."""
        return 1.0 - self.galois_loss

    @property
    def evidence_tier(self) -> EvidenceTier:
        """Map Galois loss to evidence tier."""
        return classify_evidence_tier(self.galois_loss)
```

### GroundingSuggestion

```python
@dataclass(frozen=True)
class GroundingSuggestion:
    """
    Suggested grounding from content to constitutional principle.

    Generated by analyzing K-Block content against the 7 principles:
    TASTEFUL, CURATED, ETHICAL, JOY_INDUCING, COMPOSABLE,
    HETERARCHICAL, GENERATIVE
    """

    principle: str
    confidence: float  # 0.0 - 1.0
    reasoning: str  # Why this principle fits
    content_excerpt: str  # Which part of content signals this

    @property
    def is_strong(self) -> bool:
        """Strong suggestion if confidence >= 0.7."""
        return self.confidence >= 0.7
```

### KBlockDerivationService

```python
class KBlockDerivationService:
    """
    Bridge between K-Block lifecycle and ASHC derivation.

    This service computes derivation context for K-Blocks,
    suggests principle groundings, and creates derivation edges.

    Philosophy:
        "The K-Block IS the derivation. Context flows from principle to content."

    Integration Points:
        - K-Block creation -> compute_derivation()
        - K-Block update -> recompute_derivation()
        - K-Block deletion -> prune_derivation_edges()
        - User action -> suggest_grounding() -> ground_kblock()
    """

    def __init__(
        self,
        galois_computer: GaloisLossComputer,
        derivation_dag: DerivationDAG,
        ashc_self_awareness: ASHCSelfAwareness | None = None,
    ):
        self._galois = galois_computer
        self._dag = derivation_dag
        self._ashc = ashc_self_awareness

    async def compute_derivation(
        self,
        kblock: KBlock,
        use_cache: bool = True,
    ) -> DerivationContext:
        """
        Compute derivation context for a K-Block.

        Flow:
        1. Compute Galois loss via restructure-reconstitute
        2. Check if grounded (has path to L1 axioms)
        3. Score alignment with each constitutional principle
        4. Create DerivationWitness from computation

        This is async and non-blocking (Law L1).
        """
        ...

    async def suggest_grounding(
        self,
        kblock: KBlock,
        max_suggestions: int = 3,
    ) -> list[GroundingSuggestion]:
        """
        Suggest principle groundings based on content analysis.

        Uses Galois loss computation to identify which principles
        the K-Block content aligns with most strongly.

        Returns suggestions ordered by confidence (highest first).
        """
        ...

    async def ground_kblock(
        self,
        kblock_id: str,
        principle: str,
        reasoning: str | None = None,
    ) -> DerivationPath:
        """
        Create derivation edge from principle to K-Block.

        This is the explicit grounding action - user or agent
        decides to ground a K-Block in a specific principle.

        Creates:
        1. DerivationPath from principle to K-Block
        2. DerivationWitness capturing the grounding decision
        3. Edge in DerivationDAG

        Returns the created DerivationPath.

        Raises:
            ValueError: If K-Block not found or principle invalid
            CycleError: If grounding would create DAG cycle
        """
        ...

    async def recompute_derivation(
        self,
        kblock: KBlock,
        invalidate_cache: bool = True,
    ) -> DerivationContext:
        """
        Recompute derivation after K-Block content changes.

        Called on K-Block update to refresh:
        1. Galois loss (content changed, coherence may change)
        2. Principle scores (alignment may shift)
        3. Grounding status (may need re-grounding)

        Law L2: K-Block remains usable during recomputation.
        """
        ...

    async def prune_derivation_edges(
        self,
        kblock_id: str,
    ) -> int:
        """
        Prune derivation edges when K-Block is deleted.

        Removes:
        1. All incoming edges (principles -> this K-Block)
        2. All outgoing edges (this K-Block -> dependents)
        3. DAG node for this K-Block

        Returns count of edges pruned.

        Note: Dependents are NOT automatically deleted.
        They become ungrounded and need re-grounding.
        """
        ...
```

---

## Event Flow

### K-Block Creation

```
┌─────────────────────────────────────────────────────────────┐
│                   K-Block Creation                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. KBlock created (via Harness or direct)                  │
│     │                                                       │
│     ▼                                                       │
│  2. Emit KBlockCreated event                                │
│     │                                                       │
│     ▼                                                       │
│  3. KBlockDerivationService.compute_derivation()            │
│     │ (async, non-blocking - Law L1)                        │
│     │                                                       │
│     ▼                                                       │
│  4. Compute Galois loss via L(content) = d(P, C(R(P)))      │
│     │                                                       │
│     ▼                                                       │
│  5. Emit DerivationComputed event                           │
│     │                                                       │
│     ▼                                                       │
│  6. Update K-Block with derivation context                  │
│     - kblock.galois_loss = context.galois_loss              │
│     - kblock.metadata["derivation_context"] = context       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Grounding Decision

```
┌─────────────────────────────────────────────────────────────┐
│                   Grounding Flow                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. User/Agent requests grounding suggestions               │
│     │                                                       │
│     ▼                                                       │
│  2. suggest_grounding(kblock)                               │
│     │ → Returns [GroundingSuggestion, ...]                  │
│     │                                                       │
│     ▼                                                       │
│  3. User/Agent selects a principle                          │
│     │                                                       │
│     ▼                                                       │
│  4. ground_kblock(kblock_id, principle, reasoning)          │
│     │                                                       │
│     ▼                                                       │
│  5. Create DerivationPath(principle → kblock)               │
│     │ with DerivationWitness                                │
│     │                                                       │
│     ▼                                                       │
│  6. Add edge to DerivationDAG                               │
│     │ (validates acyclicity - Law L3)                       │
│     │                                                       │
│     ▼                                                       │
│  7. Emit KBlockGrounded event                               │
│     │                                                       │
│     ▼                                                       │
│  8. Update K-Block grounding status                         │
│     - kblock.metadata["grounded"] = True                    │
│     - kblock.metadata["grounding_principle"] = principle    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## Event Definitions

```python
@dataclass(frozen=True)
class KBlockCreated:
    """Emitted when a K-Block is created."""
    kblock_id: str
    kblock_path: str
    kblock_kind: KBlockKind
    timestamp: datetime

@dataclass(frozen=True)
class DerivationComputed:
    """Emitted when derivation context is computed."""
    kblock_id: str
    galois_loss: float
    grounded: bool
    principle_scores: dict[str, float]
    evidence_tier: str  # EvidenceTier.name
    timestamp: datetime

@dataclass(frozen=True)
class KBlockGrounded:
    """Emitted when a K-Block is grounded in a principle."""
    kblock_id: str
    principle: str
    derivation_path_id: str
    confidence: float
    timestamp: datetime

@dataclass(frozen=True)
class KBlockUngrounded:
    """Emitted when a K-Block loses its grounding."""
    kblock_id: str
    reason: str  # "deleted_parent", "cycle_detected", "manual"
    timestamp: datetime
```

---

## Galois Loss Integration

The service uses `services/zero_seed/galois/galois_loss.py` for:

### Content Analysis

```python
async def _analyze_content_for_principles(
    self,
    content: str,
) -> dict[str, float]:
    """
    Analyze content to score principle alignment.

    Uses Galois loss computation to measure how well content
    aligns with each constitutional principle.

    For each principle P:
        alignment(P) = 1 - L(content_with_P_context)

    Where content_with_P_context wraps the content with
    principle-specific framing before restructure-reconstitute.
    """
    scores = {}

    for principle in CONSTITUTIONAL_PRINCIPLES:
        # Frame content with principle context
        framed = f"[{principle}]: {content}"

        # Compute Galois loss
        loss = await self._galois.compute_loss(framed)

        # Alignment is inverse of loss
        scores[principle] = 1.0 - loss

    return scores
```

### Grounding Quality

```python
async def _compute_grounding_quality(
    self,
    kblock_content: str,
    principle: str,
) -> float:
    """
    Compute quality of grounding a K-Block in a principle.

    Quality = coherence(kblock_content | principle_context)

    High quality grounding: content naturally fits the principle
    Low quality grounding: content forced into principle

    Uses edge_loss() to measure transition coherence.
    """
    principle_text = PRINCIPLE_DEFINITIONS[principle]

    # Compute edge loss from principle to content
    loss = await self._galois.edge_loss(
        source_content=principle_text,
        edge_kind="grounds",
        target_content=kblock_content,
        source_layer=1,  # Principles are L1
        target_layer=kblock_layer(self._kblock),
    )

    return 1.0 - loss  # Quality = 1 - loss
```

---

## Persistence

### K-Block Record Extension

```python
# In K-Block serialization (to_dict)
{
    # Existing fields...
    "galois_loss": 0.23,  # Computed, not default 0.0
    "metadata": {
        "derivation_context": {
            "computed_at": "2025-01-10T...",
            "grounded": true,
            "principle_scores": {
                "COMPOSABLE": 0.82,
                "GENERATIVE": 0.71,
                ...
            },
            "witnesses": [...]
        },
        "grounding_principle": "COMPOSABLE",
        "grounding_path_id": "deriv_abc123",
    }
}
```

### Derivation Graph Storage

```python
# DerivationDAG persists to same storage as K-Blocks
# Uses D-gent via StorageProvider for dual-track sync

@dataclass
class DerivationEdgeRecord:
    """Persisted derivation edge."""
    path_id: str
    source_id: str  # Principle or parent K-Block
    target_id: str  # K-Block ID
    path_kind: str  # PathKind.name
    galois_loss: float
    witnesses: list[dict]  # Serialized DerivationWitness
    created_at: str  # ISO timestamp
```

### Universe Sync

```python
async def sync_derivation_to_universe(
    derivation_path: DerivationPath,
    d_gent: DGent,
) -> str:
    """
    Sync derivation path to Universe via D-gent.

    Creates a DerivationPathCrystal in the Universe
    for cross-session persistence.

    Returns: Crystal ID
    """
    crystal = DerivationPathCrystal(
        path_id=derivation_path.path_id,
        source_id=derivation_path.source_id,
        target_id=derivation_path.target_id,
        galois_loss=derivation_path.galois_loss,
        witnesses=[w.to_dict() for w in derivation_path.witnesses],
    )

    return await d_gent.persist_crystal(crystal)
```

---

## Laws / Invariants

### Law L1: Derivation is Async and Non-Blocking

```
forall kblock K:
  create(K) completes before compute_derivation(K) completes

K-Block creation must not wait for derivation computation.
UI can show "computing..." state while derivation runs.
```

### Law L2: K-Block Usability During Computation

```
forall kblock K, time t:
  is_computing_derivation(K, t) => is_usable(K, t)

User can edit K-Block while derivation computes.
Editing triggers recomputation (debounced).
```

### Law L3: Derivation Edges Form a DAG

```
forall DerivationDAG D:
  is_acyclic(D)

No cycles in derivation graph.
ground_kblock() validates before creating edge.
```

### Law L4: Galois Loss Bounds

```
forall DerivationContext C:
  0.0 <= C.galois_loss <= 1.0

Loss is always in unit interval.
0.0 = perfect preservation, 1.0 = complete loss.
```

### Law L5: Grounding Requires Valid Principle

```
forall grounding G:
  G.principle in CONSTITUTIONAL_PRINCIPLES

Only the 7 constitutional principles are valid groundings.
```

### Law L6: Pruning Preserves Acyclicity

```
forall DAG D, kblock K:
  is_acyclic(D) => is_acyclic(prune(D, K))

Removing a node cannot create cycles.
(Trivially true but important for implementation confidence.)
```

---

## AGENTESE Integration

```
concept.derivation.kblock.*
  .compute           # Compute derivation for a K-Block
  .suggest           # Suggest grounding principles
  .ground            # Ground K-Block in a principle

self.kblock.*
  .derivation        # Current K-Block's derivation context
  .grounding         # Current grounding status
  .coherence         # Galois coherence (1 - loss)
```

### Example Invocations

```python
# Compute derivation for a K-Block
await logos.invoke(
    "concept.derivation.kblock.compute",
    observer,
    kblock_id="kb_abc123",
)

# Get grounding suggestions
suggestions = await logos.invoke(
    "concept.derivation.kblock.suggest",
    observer,
    kblock_id="kb_abc123",
)

# Ground in a principle
path = await logos.invoke(
    "concept.derivation.kblock.ground",
    observer,
    kblock_id="kb_abc123",
    principle="COMPOSABLE",
    reasoning="Content is modular and composes well",
)
```

---

## Anti-Patterns

- **Blocking on derivation**: Don't wait for derivation before returning K-Block
- **Ignoring ungrounded state**: Surface ungrounded K-Blocks to user
- **Manual galois_loss setting**: Always compute via GaloisLossComputer
- **Cycle creation**: Always validate before adding edges
- **Orphan edges**: Clean up edges when K-Block deleted
- **Cache staleness**: Invalidate on content change

---

## Implementation Reference

### Service Location

```
impl/claude/services/k_block/
  derivation_service.py   # KBlockDerivationService
  events.py               # Event definitions
  _tests/
    test_derivation_service.py
```

### Dependencies

```python
from protocols.ashc.paths import DerivationPath, DerivationWitness
from protocols.ashc.self_awareness import ASHCSelfAwareness
from services.k_block.core.derivation import DerivationDAG
from services.zero_seed.galois import GaloisLossComputer
```

### Wiring Example

```python
# In service bootstrap
def create_kblock_derivation_service(
    storage: StorageProvider,
    llm_client: LLMClientProtocol | None = None,
) -> KBlockDerivationService:
    """Create KBlockDerivationService with dependencies."""

    galois = GaloisLossComputer(
        llm=llm_client or SimpleLLMClient(),
        metric=get_default_metric(),
    )

    dag = DerivationDAG()

    ashc = create_self_awareness(dag=dag)

    return KBlockDerivationService(
        galois_computer=galois,
        derivation_dag=dag,
        ashc_self_awareness=ashc,
    )
```

---

## Connection to Heritage

| Heritage | Connection |
|----------|------------|
| ASHC | DerivationPath, DerivationWitness types |
| K-Block | Core data structure, lifecycle events |
| Zero Seed | Galois loss computation, layer classification |
| Derivation Framework | DAG structure, confidence propagation |
| D-gent | Universe sync for persistence |

---

## The Philosophical Stance

K-Blocks without derivation are content without meaning. The derivation context answers *why* the content exists, not just *that* it exists.

The Galois loss quantifies coherence: how much meaning survives the restructure-reconstitute cycle. High coherence (low loss) means the content is well-formed. Low coherence (high loss) signals the content may be confused or contradictory.

Grounding completes the picture: the derivation path from principle to K-Block IS the justification. An ungrounded K-Block is content without roots.

> *"The proof IS the decision. The K-Block IS the derivation."*

---

*Filed: 2025-01-10*
*Status: Proposal*
