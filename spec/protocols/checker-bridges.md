# Checker Bridges: The Gatekeeper Protocol

> *"LLM hallucinations don't matter for proofs because proof checkers reject invalid proofs."*
> — Martin Kleppmann

**Status**: Implementation
**Heritage**: Kleppmann (§12), Polynomial Functors (§10)
**Phase**: 5 of 6 (ASHC Proof-Generation)
**Created**: 2025-12-21

---

## Purpose

Extend the ASHC proof-checking infrastructure with Lean4 and Verus checker bridges.

Why this needs to exist: The current implementation has only `DafnyChecker`. But formal verification ecosystems are diverse—Lean4 dominates mathematical proofs (Mathlib), Verus dominates Rust systems verification. A single-checker system cannot leverage the full proof landscape.

The checker IS the gatekeeper. Different gatekeepers have different strengths.

---

## The Core Insight

Proof checkers are **interchangeable morphisms** with a common interface:

```
ProofChecker : String → CheckerResult
```

The caller doesn't care which checker verifies the proof—only that verification happens. This is the Composable principle: checkers compose with the proof search pipeline identically.

---

## Formal Definition

```
ProofChecker : Protocol
  name : String
  is_available : Bool
  check : (source: String, timeout: Int) → Async CheckerResult

Lean4Checker : ProofChecker
Dafny Checker : ProofChecker  # (existing)
VerusChecker : ProofChecker
MockChecker : ProofChecker    # (existing, for testing)

CheckerRegistry : Dict[String, ProofChecker]
  register : (name, class) → ()
  get : name → ProofChecker
  available_checkers : () → [String]
```

The registry is a **lazy factory**—checkers instantiate on first `get()` call, not registration. This prevents startup cost when checkers aren't used.

---

## Integration with Existing Infrastructure

### Current Structure (Phase 4 Complete)

```
services/ashc/
├── __init__.py          # Exports
├── contracts.py         # ProofObligation, VerifiedLemma, CheckerResult
├── obligation.py        # Extract obligations from pytest failures
├── search.py            # LLM-assisted proof search
├── persistence.py       # PostgresLemmaDatabase
└── checker.py           # DafnyChecker, MockChecker, CheckerRegistry ← EXTEND HERE
```

### New Checkers Follow DafnyChecker Pattern

```python
class NewChecker:
    def __init__(self, binary_path: str | None = None, *, verify_on_init: bool = True):
        self._binary_path = binary_path or "binary"
        self._available: bool | None = None
        if verify_on_init:
            self._verify_installation()

    @property
    def name(self) -> str: ...

    @property
    def is_available(self) -> bool: ...

    def _verify_installation(self) -> None: ...  # subprocess --version check

    async def check(self, proof_source: str, timeout_ms: int = 30000) -> CheckerResult: ...

    def _parse_errors(self, output: str) -> list[str]: ...

    def _parse_warnings(self, output: str) -> list[str]: ...
```

---

## Lean4Checker Specification

### Purpose

Lean4 is the future of formal verification:
- Dependent types enable expressive specifications
- Tactics language enables interactive proof development
- Mathlib provides extensive library of proven theorems
- Active community with momentum

### Installation

```bash
# Install elan (Lean version manager)
curl https://raw.githubusercontent.com/leanprover/elan/master/elan-init.sh -sSf | sh

# Verify installation
lake --version
```

### Verification Command

```bash
# Verify a file
lake env lean MyFile.lean
```

### Trivial Proof (for testing)

```lean
theorem trivial : ∀ x : Nat, x = x := fun _ => rfl
```

### Temp File Template

```lean
-- Auto-generated by ASHC
-- Proof generated at: {timestamp}

{proof_source}
```

### Error Patterns to Parse

| Pattern | Meaning |
|---------|---------|
| `error:` | Syntax or type error |
| `sorry` | Incomplete proof marker |
| `unsolved goals` | Tactic didn't complete |
| `type mismatch` | Type error in proof |

### Gotchas

1. **lake vs lean**: Use `lake env lean` not just `lean` to get correct environment
2. **sorry handling**: Proofs containing `sorry` should be treated as FAILED (incomplete)
3. **Unicode**: Lean uses unicode extensively (∀, →, ×); ensure UTF-8 encoding

---

## VerusChecker Specification

### Purpose

Verus verifies Rust code with ownership-aware reasoning:
- Linear types match Rust's ownership model
- Similar to Dafny but for systems code
- Good for low-level proofs (memory safety, concurrency)

### Installation

```bash
# Clone and build Verus
git clone https://github.com/verus-lang/verus
cd verus
./tools/install.sh

# Verify installation
verus --version
```

### Verification Command

```bash
verus verify myfile.rs
```

### Trivial Proof (for testing)

```rust
use vstd::prelude::*;

verus! {
    proof fn trivial()
        ensures true
    {
    }
}
```

### Temp File Template

```rust
// Auto-generated by ASHC
// Proof generated at: {timestamp}
use vstd::prelude::*;

verus! {
    {proof_source}
}
```

### Error Patterns to Parse

| Pattern | Meaning |
|---------|---------|
| `error:` | Compilation error |
| `verification failed` | Proof doesn't hold |
| `assertion failed` | Runtime assertion violation |
| `precondition not satisfied` | Caller didn't meet requires |
| `postcondition not satisfied` | Implementation didn't meet ensures |

### Gotchas

1. **Rust environment**: Verus requires Rust toolchain; may need `rustup` setup
2. **verus! macro**: All verified code must be inside the `verus!` macro
3. **vstd imports**: Standard library must be imported explicitly

---

## Laws

### 1. Protocol Conformance

All checkers implement the same `ProofChecker` protocol:

```python
@runtime_checkable
class ProofChecker(Protocol):
    @property
    def name(self) -> str: ...

    @property
    def is_available(self) -> bool: ...

    async def check(
        self,
        proof_source: str,
        timeout_ms: int = 30000,
    ) -> CheckerResult: ...
```

**Verification**: `isinstance(checker, ProofChecker)` must be `True`.

### 2. Graceful Unavailability

Checkers that aren't installed return `is_available = False` and raise `CheckerUnavailable` on `check()`:

```python
if not checker.is_available:
    with pytest.raises(CheckerUnavailable):
        await checker.check("any proof")
```

**Verification**: Unavailable checker never hangs or crashes.

### 3. No Zombie Processes

All checkers must handle timeouts without leaving zombie processes:

```python
async def check(self, proof_source: str, timeout_ms: int) -> CheckerResult:
    try:
        # ... subprocess logic ...
        stdout, stderr = await asyncio.wait_for(
            proc.communicate(),
            timeout=timeout_ms / 1000,
        )
    except asyncio.TimeoutError:
        proc.kill()         # Kill the process
        await proc.wait()   # Reap the zombie
        return CheckerResult(success=False, errors=("Verification timeout",), ...)
```

**Verification**: After timeout, no orphan processes remain.

### 4. Temp File Cleanup

All checkers must clean up temporary files even on exceptions:

```python
temp_path: str | None = None
try:
    fd, temp_path = tempfile.mkstemp(suffix=".lean", prefix="ashc_proof_")
    # ... use temp file ...
finally:
    if temp_path and os.path.exists(temp_path):
        os.unlink(temp_path)
```

**Verification**: Temp directory doesn't accumulate `ashc_proof_*` files.

---

## Test Specification

### Unit Tests (No External Dependencies)

```python
class TestLean4CheckerUnit:
    def test_lazy_verification(self) -> None:
        """Lean4Checker can be created with lazy verification."""
        checker = Lean4Checker(verify_on_init=False)
        assert checker.name == "lean4"

    def test_custom_path(self) -> None:
        """Lean4Checker accepts custom lean path."""
        checker = Lean4Checker(binary_path="/custom/lean", verify_on_init=False)
        assert checker._binary_path == "/custom/lean"


class TestVerusCheckerUnit:
    def test_lazy_verification(self) -> None:
        """VerusChecker can be created with lazy verification."""
        checker = VerusChecker(verify_on_init=False)
        assert checker.name == "verus"
```

### Integration Tests (Require Checker Installed)

```python
def lean4_available() -> bool:
    """Check if Lean4 is available for integration tests."""
    try:
        checker = Lean4Checker(verify_on_init=True)
        return checker.is_available
    except CheckerUnavailable:
        return False


requires_lean4 = pytest.mark.skipif(
    not lean4_available(),
    reason="Lean4 not installed. Install: curl https://...",
)


@pytest.mark.integration
class TestLean4CheckerIntegration:
    @requires_lean4
    @pytest.mark.asyncio
    async def test_verifies_trivial_proof(self) -> None:
        """Lean4 accepts obviously true proofs."""
        checker = Lean4Checker()
        proof = "theorem trivial : ∀ x : Nat, x = x := fun _ => rfl"

        result = await checker.check(proof)

        assert result.success
        assert result.errors == ()

    @requires_lean4
    @pytest.mark.asyncio
    async def test_rejects_sorry(self) -> None:
        """Lean4 rejects proofs with sorry."""
        checker = Lean4Checker()
        proof = "theorem incomplete : 1 = 2 := sorry"

        result = await checker.check(proof)

        assert not result.success  # sorry = incomplete proof


@pytest.mark.integration
class TestVerusCheckerIntegration:
    @requires_verus
    @pytest.mark.asyncio
    async def test_verifies_trivial_proof(self) -> None:
        """Verus accepts obviously true proofs."""
        checker = VerusChecker()
        proof = """
proof fn trivial()
    ensures true
{
}
"""
        result = await checker.check(proof)

        assert result.success
```

---

## Registry Integration

After implementing, register new checkers:

```python
# At bottom of checker.py
_default_registry.register("lean4", Lean4Checker)
_default_registry.register("verus", VerusChecker)
```

The `available_checkers()` function returns all installed checkers:

```python
>>> from services.ashc import available_checkers
>>> available_checkers()
['mock', 'dafny', 'lean4']  # verus not installed in this environment
```

---

## Exit Criteria

- [ ] `Lean4Checker` implements `ProofChecker` protocol
- [ ] `VerusChecker` implements `ProofChecker` protocol
- [ ] Both checkers handle unavailability gracefully (`is_available` property)
- [ ] Both checkers have timeout handling (no zombie processes)
- [ ] Tests skip when checker not installed (`@pytest.mark.skipif`)
- [ ] `available_checkers()` returns all installed checkers
- [ ] Existing tests still pass (152 ASHC tests)
- [ ] Temp file cleanup verified (no accumulation)

---

## Anti-patterns

- **Blocking subprocess calls**: Use `asyncio.create_subprocess_exec`, not `subprocess.run`
- **Ignoring exit codes**: Parse exit code, not output presence (Dafny outputs to stderr even on success)
- **Silent failures**: Raise `CheckerUnavailable` explicitly, don't return empty results
- **Uncleaned temp files**: Always use `try/finally` for cleanup
- **Hardcoded timeouts**: Accept `timeout_ms` parameter, respect it

---

## Connection to Proof-Generation Pipeline

Checkers plug into `ProofSearcher`:

```python
class ProofSearcher:
    def __init__(
        self,
        gateway: MorpheusGateway,
        checker: ProofChecker,  # ← Any checker works here
        lemma_db: LemmaDatabase | None = None,
        config: ProofSearchConfig | None = None,
    ): ...
```

The searcher doesn't care which checker is used—polymorphism via protocol:

```python
# Use Dafny for imperative proofs
searcher = ProofSearcher(gateway, DafnyChecker(), lemma_db)

# Use Lean4 for mathematical proofs
searcher = ProofSearcher(gateway, Lean4Checker(), lemma_db)

# Use Verus for Rust systems proofs
searcher = ProofSearcher(gateway, VerusChecker(), lemma_db)
```

---

## Implementation Notes

### Async Best Practices

```python
async def check(self, proof_source: str, timeout_ms: int = 30000) -> CheckerResult:
    proc = await asyncio.create_subprocess_exec(
        self._binary_path,
        *args,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE,
    )

    try:
        stdout, stderr = await asyncio.wait_for(
            proc.communicate(),
            timeout=timeout_ms / 1000,
        )
    except asyncio.TimeoutError:
        proc.kill()
        await proc.wait()
        return CheckerResult(success=False, errors=("Verification timeout",), ...)
```

### Version Check Pattern

```python
def _verify_installation(self) -> None:
    import subprocess

    try:
        result = subprocess.run(
            [self._binary_path, "--version"],
            capture_output=True,
            timeout=10,
        )
        if result.returncode != 0:
            self._available = False
            raise CheckerUnavailable(self.name, f"Returned exit code {result.returncode}")
        self._available = True
    except FileNotFoundError:
        self._available = False
        raise CheckerUnavailable(self.name, "Not found. Install: ...")
    except subprocess.TimeoutExpired:
        self._available = False
        raise CheckerUnavailable(self.name, "Timed out during version check")
```

---

## Cross-References

- **Parent Spec**: `spec/protocols/proof-generation.md`
- **Implementation**: `impl/claude/services/ashc/checker.py`
- **Tests**: `impl/claude/services/ashc/_tests/test_checker.py`
- **Contracts**: `impl/claude/services/ashc/contracts.py`
- **Search Pipeline**: `impl/claude/services/ashc/search.py`

---

*"The proof checker is the gatekeeper. If the proof checks, the theorem holds. The LLM can hallucinate all it wants—mechanical verification is the source of truth."*
