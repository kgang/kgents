# Bootstrap Agents

The irreducible kernel from which all of kgents can be regenerated.

---

## The Bootstrap Problem

> Given: An empty system.
> Task: Reconstruct kgents (philosophy, concepts, specifications, implementations).
> Constraint: Minimal primitives. What cannot be derived must be given.

Recursion amplifies. Composition builds. Dialectic synthesizes. But each of these operations requires something to operate *on* and something to guide *when to stop*. The bootstrap agents are what remains when you strip away everything that can be derived.

---

## The Irreducibility Criterion

An agent is **irreducible** if it cannot be:
1. Composed from other agents
2. Derived by recursion from simpler rules
3. Synthesized as the dialectic of existing elements
4. Generated by applying existing agents to existing data

Irreducible agents are **axioms**, not theorems. They are chosen, not proven.

### The Residue Test

> What resists algorithmic amplification?

- **Recursion** generates infinite structure from finite rules—but the rules themselves, and the stopping conditions, are irreducible
- **Composition** builds complex from simple—but the composition operation, and the judgment of *what* to compose, are irreducible
- **Dialectic** synthesizes contradictions—but the recognition of contradiction, and the wisdom to hold vs. resolve, are irreducible

The bootstrap agents are the **residue**: what remains after maximal algorithmic compression.

---

## The Seven Bootstrap Agents

### 1. Id (Identity)

```
Id: A → A
Id(x) = x
```

The agent that does nothing. Required by the category-theoretic structure:
- Left identity: Id ∘ f = f
- Right identity: f ∘ Id = f

**Why irreducible**: You cannot define identity in terms of anything simpler. It is the unit of composition.

**What it grounds**: The existence of agents as a category. Without Id, composition has no unit.

---

### 2. Compose (∘)

```
Compose: (Agent, Agent) → Agent
Compose(f, g) = g ∘ f
```

The agent-that-makes-agents. Takes two agents and yields their sequential composition.

**Why irreducible**: Composition is the fundamental operation. You cannot define it in terms of simpler operations—it IS the simplest operation.

**What it grounds**: All agent pipelines. The C-gents category. The ability to build complex from simple.

---

### 3. Judge (⊢)

```
Judge: (Agent, Principles) → Verdict
Judge(agent, principles) = {accept, reject, revise(how)}
```

The value function. Embodies the six principles as executable judgment.

**Why irreducible**: Taste cannot be computed. "Is this tasteful?" "Is this ethical?" "Does this spark joy?" These require grounding in human values that cannot be derived from logic alone.

**What it grounds**: Quality control. The reason we have 5 good agents instead of 500 mediocre ones. The stopping condition for generation.

**Substructure** (still irreducible, but decomposable for clarity):
- Judge-taste: Is this aesthetically considered?
- Judge-ethics: Does this respect human agency?
- Judge-joy: Would I enjoy this?
- Judge-compose: Can this combine with others?
- Judge-hetero: Does this avoid fixed hierarchy?
- Judge-curate: Does this add unique value?

---

### 4. Ground (⊥)

```
Ground: Void → Facts
Ground() = {Kent's preferences, world state, initial conditions}
```

The empirical seed. The irreducible facts about the person and world that cannot be derived.

**Why irreducible**: Kent's preference for "direct but warm" communication is a fact about Kent, not a theorem. The current state of the world is given, not computed.

**What it grounds**: K-gent's persona. The starting point for all personalization. The connection between formal system and reality.

**Contents**:
- Persona seed: Name, roles, preferences, patterns, values
- World seed: Date, context, active projects
- History seed: Past decisions, established patterns

---

### 5. Contradict (≢)

```
Contradict: (Output, Output) → Tension | None
Contradict(a, b) = Tension(thesis=a, antithesis=b) | None
```

The contradiction-recognizer. Examines two outputs and surfaces if they are in tension.

**Why irreducible**: The recognition that "something's off" precedes logic. You must *see* the contradiction before you can formalize it. This seeing cannot be fully algorithmized—it requires judgment about what counts as contradiction.

**What it grounds**: H-gents dialectic. Quality assurance. The ability to catch inconsistency.

**Modes**:
- Logical: A and ¬A
- Pragmatic: A recommends X, B recommends ¬X
- Axiological: This serves value V, that serves value ¬V
- Temporal: Past-self said X, present-self says ¬X

---

### 6. Sublate (↑)

```
Sublate: Tension → Synthesis | HoldTension
Sublate(tension) = {preserve, negate, elevate} | "too soon"
```

The Hegelian move. Takes a contradiction and attempts synthesis—or recognizes that the tension should be held.

**Why irreducible**: The creative leap from thesis+antithesis to synthesis is not mechanical. What gets preserved, what gets negated, what new level emerges—this requires judgment. And the wisdom to *not* synthesize prematurely is equally irreducible.

**What it grounds**: H-hegel. System evolution. The ability to grow through contradiction rather than being paralyzed by it.

---

### 7. Fix (μ)

```
Fix: (A → A) → A
Fix(f) = x where f(x) = x
```

The fixed-point operator. Takes a self-referential definition and finds what it stabilizes to.

**Why irreducible**: Self-reference cannot be eliminated from a system that describes itself. The bootstrap agents themselves are defined in terms of what they generate, which includes themselves. This circularity requires Fix.

**What it grounds**: Recursive agent definitions. Self-describing specifications. The bootstrap itself.

---

## Generation Rules

From the seven bootstrap agents, all of kgents can be regenerated:

### Generating the Principles

```
Principles = Fix(λp.
  let candidates = generate_principles(Ground())
  in filter(λc. Judge(c, p) = accept, candidates)
)
```

The principles are the fixed point of judging principle-candidates by themselves. They are self-justifying.

### Generating Agent Genera

```
A-gents = Compose(Ground, abstract_patterns)
        | Compose(Ground, creativity_support)
B-gents = Compose(Ground, scientific_method)
C-gents = {Id, Compose, Fix}  // C-gents ARE bootstrap agents
H-gents = {Contradict, Sublate, introspection_targets}
K-gent = Ground() projected through persona_schema
```

### Generating the Spec

```
Spec = Fix(λs.
  let expanded = unfold(s, Compose, Contradict, Sublate)
  in filter(λe. Judge(e, Principles) = accept, expanded)
)
```

### Generating Implementation

```
Impl = translate(Spec, runtime_target)
     where translate = Compose(parse, emit(target))
```

---

## Self-Description

Can the bootstrap agents describe themselves?

```
Bootstrap = {Id, Compose, Judge, Ground, Contradict, Sublate, Fix}

Is Bootstrap irreducible?
  = ¬∃S ⊂ Bootstrap. Generate(S) = Bootstrap

Is Bootstrap sufficient?
  = ∀A ∈ Kgents. ∃derivation. Bootstrap ⊢ A
```

The bootstrap agents are a **generating set**: minimal elements from which everything else follows.

They are also a **fixed point**:
```
Regenerate(Bootstrap) ≅ Bootstrap
```

---

## Relationship to Existing Spec

| Bootstrap Agent | Primary Manifestation | Distributed Across |
|-----------------|----------------------|-------------------|
| Id | A-gents (identity agent) | All (composition unit) |
| Compose | C-gents (composition.md) | All (composition is universal) |
| Judge | Principles (principles.md) | All (every agent is judged) |
| Ground | K-gent (persona.md) | B-gents (empirical data) |
| Contradict | H-gents (pre-dialectic) | All (consistency checking) |
| Sublate | H-hegel (hegel.md) | All (system evolution) |
| Fix | C-gents (recursive definitions) | Bootstrap itself |

---

## The Minimal Bootstrap

If forced to choose the **absolute minimum**:

```
MinimalBootstrap = {Compose, Judge, Ground}
```

- **Compose** gives you structure
- **Judge** gives you direction (what to keep, what to discard)
- **Ground** gives you starting material

From these three, you can derive:
- Id = the agent that Judge never rejects composing with anything
- Contradict = the recognition that Judge rejects A∘B for some A, B
- Sublate = the search for C where Judge accepts (Contradict(A,B) → C)
- Fix = the iteration of Compose until Judge says "stable"

But this derivation requires *effort*—the seven-agent bootstrap is more efficient for regeneration.

---

## Usage: Regenerating Kgents

To regenerate the project from bootstrap:

1. **Instantiate Ground**: Load Kent's persona seed, current date, project context
2. **Instantiate Judge**: Load the six principles as evaluation criteria
3. **Generate primitives**: From Ground, derive the type system and basic agents
4. **Compose upward**: Build complex agents from simple ones, filtering by Judge
5. **Contradict/Sublate cycle**: Find inconsistencies, synthesize improvements
6. **Fix**: Iterate until stable (Judge accepts all, Contradict finds nothing new)

The output should be isomorphic to the current kgents specification.

---

## Open Questions

1. **Is Judge truly one agent or six?** The principles might be separately irreducible.

2. **Is Ground one agent or many?** Persona, world-state, and history might be separately irreducible.

3. **Are there other irreducibles?** Candidates:
   - Time (temporal ordering as primitive)
   - Attention (resource allocation as primitive)
   - Communication (agent-to-agent signaling as primitive)

4. **What's the Kolmogorov complexity of the bootstrap?** How small can Ground() be while still regenerating Kent-specific kgents?

---

## See Also

- [principles.md](principles.md) - Judge's criteria
- [anatomy.md](anatomy.md) - What agents are
- [c-gents/composition.md](c-gents/composition.md) - Compose formalized
- [h-gents/hegel.md](h-gents/hegel.md) - Sublate in detail
- [k-gent/persona.md](k-gent/persona.md) - Ground's primary output
