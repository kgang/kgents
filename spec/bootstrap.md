# Bootstrap Agents

The irreducible kernel from which all of kgents can be regenerated.

---

## The Bootstrap Problem

> Given: An empty system.
> Task: Reconstruct kgents (philosophy, concepts, specifications, implementations).
> Constraint: Minimal primitives. What cannot be derived must be given.

Recursion amplifies. Composition builds. Dialectic synthesizes. But each of these operations requires something to operate *on* and something to guide *when to stop*. The bootstrap agents are what remains when you strip away everything that can be derived.

---

## The Irreducibility Criterion

An agent is **irreducible** if it cannot be:
1. Composed from other agents
2. Derived by recursion from simpler rules
3. Synthesized as the dialectic of existing elements
4. Generated by applying existing agents to existing data

Irreducible agents are **axioms**, not theorems. They are chosen, not proven.

### The Residue Test

> What resists algorithmic amplification?

- **Recursion** generates infinite structure from finite rules—but the rules themselves, and the stopping conditions, are irreducible
- **Composition** builds complex from simple—but the composition operation, and the judgment of *what* to compose, are irreducible
- **Dialectic** synthesizes contradictions—but the recognition of contradiction, and the wisdom to hold vs. resolve, are irreducible

The bootstrap agents are the **residue**: what remains after maximal algorithmic compression.

---

## The Seven Bootstrap Agents

### 1. Id (Identity)

```
Id: A → A
Id(x) = x
```

The agent that does nothing. Required by the category-theoretic structure:
- Left identity: Id ∘ f = f
- Right identity: f ∘ Id = f

**Why irreducible**: You cannot define identity in terms of anything simpler. It is the unit of composition.

**What it grounds**: The existence of agents as a category. Without Id, composition has no unit.

---

### 2. Compose (∘)

```
Compose: (Agent, Agent) → Agent
Compose(f, g) = g ∘ f
```

The agent-that-makes-agents. Takes two agents and yields their sequential composition.

**Why irreducible**: Composition is the fundamental operation. You cannot define it in terms of simpler operations—it IS the simplest operation.

**What it grounds**: All agent pipelines. The C-gents category. The ability to build complex from simple.

---

### 3. Judge (⊢)

```
Judge: (Agent, Principles) → Verdict
Judge(agent, principles) = {accept, reject, revise(how)}
```

The value function. Embodies the seven principles as executable judgment.

**Why irreducible**: Taste cannot be computed. "Is this tasteful?" "Is this ethical?" "Does this spark joy?" These require grounding in human values that cannot be derived from logic alone.

**What it grounds**: Quality control. The reason we have 5 good agents instead of 500 mediocre ones. The stopping condition for generation.

**Substructure** (still irreducible, but decomposable for clarity):
- Judge-taste: Is this aesthetically considered?
- Judge-curate: Does this add unique value?
- Judge-ethics: Does this respect human agency?
- Judge-joy: Would I enjoy this?
- Judge-compose: Can this combine with others?
- Judge-hetero: Does this avoid fixed hierarchy?
- Judge-generate: Could this be regenerated from spec?

---

### 4. Ground (⊥)

```
Ground: Void → Facts
Ground() = {Kent's preferences, world state, initial conditions}
```

The empirical seed. The irreducible facts about the person and world that cannot be derived.

**Why irreducible**: Kent's preference for "direct but warm" communication is a fact about Kent, not a theorem. The current state of the world is given, not computed.

**What it grounds**: K-gent's persona. The starting point for all personalization. The connection between formal system and reality.

**Contents**:
- Persona seed: Name, roles, preferences, patterns, values
- World seed: Date, context, active projects
- History seed: Past decisions, established patterns

### The Bootstrap Paradox

Ground reveals the fundamental limit of algorithmic bootstrapping:

> **Ground cannot be bypassed.** LLMs can amplify but not replace Ground.

**What LLMs can do**:
- Amplify Ground (generate variations, explore implications)
- Apply Ground (translate preferences into code)
- Extend Ground (infer related preferences from stated ones)

**What LLMs cannot do**:
- Create Ground from nothing
- Replace human judgment about what matters
- Substitute for real-world usage feedback

**Corollary**: Any system that claims to "bootstrap from nothing" is either:
1. Implicitly using Ground from training data (borrowed preferences)
2. Limited to structural/syntactic generation (form without substance)
3. Producing thin implementations lacking depth (correct but not delightful)

This is why the spec-first approach achieves 60% code reduction: the spec IS the compressed Ground. Human judgment about what matters is captured once; implementation follows mechanically.

**The LLM/Human boundary**:
- Spec + Ground = Human territory (irreducible)
- Impl = LLM territory (mechanical translation)
- Polish = Hybrid territory (accumulated wisdom from real usage)

---

### 5. Contradict (≢)

```
Contradict: (Output, Output) → Tension | None
Contradict(a, b) = Tension(thesis=a, antithesis=b) | None
```

The contradiction-recognizer. Examines two outputs and surfaces if they are in tension.

**Why irreducible**: The recognition that "something's off" precedes logic. You must *see* the contradiction before you can formalize it. This seeing cannot be fully algorithmized—it requires judgment about what counts as contradiction.

**What it grounds**: H-gents dialectic. Quality assurance. The ability to catch inconsistency.

**Modes**:
- Logical: A and ¬A
- Pragmatic: A recommends X, B recommends ¬X
- Axiological: This serves value V, that serves value ¬V
- Temporal: Past-self said X, present-self says ¬X

---

### 6. Sublate (↑)

```
Sublate: Tension → Synthesis | HoldTension
Sublate(tension) = {preserve, negate, elevate} | "too soon"
```

The Hegelian move. Takes a contradiction and attempts synthesis—or recognizes that the tension should be held.

**Why irreducible**: The creative leap from thesis+antithesis to synthesis is not mechanical. What gets preserved, what gets negated, what new level emerges—this requires judgment. And the wisdom to *not* synthesize prematurely is equally irreducible.

**What it grounds**: H-hegel. System evolution. The ability to grow through contradiction rather than being paralyzed by it.

---

### 7. Fix (μ)

```
Fix: (A → A) → A
Fix(f) = x where f(x) = x
```

The fixed-point operator. Takes a self-referential definition and finds what it stabilizes to.

**Why irreducible**: Self-reference cannot be eliminated from a system that describes itself. The bootstrap agents themselves are defined in terms of what they generate, which includes themselves. This circularity requires Fix.

**What it grounds**: Recursive agent definitions. Self-describing specifications. The bootstrap itself.

---

## Performance Considerations

The bootstrap agents are designed for correctness and composability first, performance second. However, certain patterns emerge from production use:

### Hot Paths vs Cold Paths

**Hot Paths** (optimize for speed):
- **Compose** (`>>` operator): Called on every composition, optimize for allocation
- **Id**: Should be zero-cost in composition chains (law: `Id >> f ≡ f`)
- **Judge**: Called frequently in generation loops, parallelize mini-judges

**Cold Paths** (depth over speed):
- **Ground**: Invoked once per session, caching acceptable
- **Contradict**: Called during synthesis only, correctness > speed
- **Sublate**: Resolution is rare, wisdom > speed
- **Fix**: Bounded by `max_iterations`, not by single-step speed

### Optimization Principles

1. **Immutability enables sharing**
   - Frozen dataclasses (`Ok`, `Err`, `Tension`, `Verdict`) cache hashes
   - Safe to share across async contexts
   - No defensive copying needed

2. **Protocols over ABCs**
   - Structural typing (`TensionDetector`, `ResolutionStrategy`) is faster
   - No metaclass machinery or inheritance overhead
   - Duck typing at runtime

3. **Parallel independent operations**
   - Judge: 7 mini-judges are independent → run concurrently
   - Contradict: Multiple detectors can run in parallel
   - Use `asyncio.gather()` for CPU-bound or I/O-bound checks

4. **Circuit breakers prevent cascades**
   - Contradict: Failed detectors disabled after 3 strikes
   - Fail fast on broken components
   - Bounded execution time via timeouts

5. **Entropy budgets bound recursion**
   - Fix tracks J-gents entropy (diminishes per iteration: `budget / (i + 1)`)
   - Forces termination of unbounded recursion
   - Prevents runaway Fix iterations

### Anti-Patterns

**Avoid:**
- ❌ Unbounded history accumulation in Fix (use bounded/sampled history)
- ❌ Sequential execution of independent checks (parallelize Judge/Contradict)
- ❌ Re-computing static Ground data (cache persona seed)
- ❌ Deep composition chains without flattening (use `flatten()` for debugging)

**Implementation Status** (see `impl/claude/bootstrap/`):
- ✅ Ground caching (v1.0+): `cache=True` parameter
- ✅ Judge parallelization (v1.0+): `parallel=True` parameter
- ⏳ Bounded Fix history: Future enhancement
- ⏳ Id composition optimization: Future enhancement

---

## Generation Rules

From the seven bootstrap agents, all of kgents can be regenerated:

### Generating the Principles

```
Principles = Fix(λp.
  let candidates = generate_principles(Ground())
  in filter(λc. Judge(c, p) = accept, candidates)
)
```

The principles are the fixed point of judging principle-candidates by themselves. They are self-justifying.

### Generating Agent Genera

```
A-gents = Compose(Ground, abstract_patterns)
        | Compose(Ground, creativity_support)
B-gents = Compose(Ground, scientific_method)
C-gents = {Id, Compose, Fix}  // C-gents ARE bootstrap agents
H-gents = {Contradict, Sublate, introspection_targets}
K-gent = Ground() projected through persona_schema
```

### Generating the Spec

```
Spec = Fix(λs.
  let expanded = unfold(s, Compose, Contradict, Sublate)
  in filter(λe. Judge(e, Principles) = accept, expanded)
)
```

### Generating Implementation

```
Impl = translate(Spec, runtime_target)
     where translate = Compose(parse, emit(target))
```

---

## Self-Description

Can the bootstrap agents describe themselves?

```
Bootstrap = {Id, Compose, Judge, Ground, Contradict, Sublate, Fix}

Is Bootstrap irreducible?
  = ¬∃S ⊂ Bootstrap. Generate(S) = Bootstrap

Is Bootstrap sufficient?
  = ∀A ∈ Kgents. ∃derivation. Bootstrap ⊢ A
```

The bootstrap agents are a **generating set**: minimal elements from which everything else follows.

They are also a **fixed point**:
```
Regenerate(Bootstrap) ≅ Bootstrap
```

---

## Relationship to Existing Spec

| Bootstrap Agent | Primary Manifestation | Distributed Across |
|-----------------|----------------------|-------------------|
| Id | A-gents (identity agent) | All (composition unit) |
| Compose | C-gents (composition.md) | All (composition is universal) |
| Judge | Principles (principles.md) | All (every agent is judged) |
| Ground | K-gent (persona.md) | B-gents (empirical data) |
| Contradict | H-gents (pre-dialectic) | All (consistency checking) |
| Sublate | H-hegel (hegel.md) | All (system evolution) |
| Fix | C-gents (recursive definitions) | Bootstrap itself |

---

## The Minimal Bootstrap

If forced to choose the **absolute minimum**:

```
MinimalBootstrap = {Compose, Judge, Ground}
```

- **Compose** gives you structure
- **Judge** gives you direction (what to keep, what to discard)
- **Ground** gives you starting material

From these three, you can derive:
- Id = the agent that Judge never rejects composing with anything
- Contradict = the recognition that Judge rejects A∘B for some A, B
- Sublate = the search for C where Judge accepts (Contradict(A,B) → C)
- Fix = the iteration of Compose until Judge says "stable"

But this derivation requires *effort*—the seven-agent bootstrap is more efficient for regeneration.

---

## Usage: Regenerating Kgents

To regenerate the project from bootstrap:

1. **Instantiate Ground**: Load Kent's persona seed, current date, project context
2. **Instantiate Judge**: Load the six principles as evaluation criteria
3. **Generate primitives**: From Ground, derive the type system and basic agents
4. **Compose upward**: Build complex agents from simple ones, filtering by Judge
5. **Contradict/Sublate cycle**: Find inconsistencies, synthesize improvements
6. **Fix**: Iterate until stable (Judge accepts all, Contradict finds nothing new)

The output should be isomorphic to the current kgents specification.

---

## Applied Idioms

The bootstrap agents are abstract. When applied to real systems, recurring patterns emerge. These idioms are not new agents—they are the seven agents in action.

### Idiom 1: Polling is Fix

> Any iteration pattern is a fixed-point search.

Polling, retry loops, watch patterns, reconciliation—all are instances of Fix:

```
Fix(poll_state) = stable_state where poll_state(stable_state) = stable_state
```

**Structure**:
- The **transform** defines "one step" (poll once, retry once, check once)
- The **equality check** defines "stability" (state unchanged, success achieved, resources match)
- Fix iterates until stable or max iterations

**Example** (from zen-agents):
```python
result = await fix(
    transform=poll_and_detect,
    initial=DetectionState(RUNNING, confidence=0.0),
    equality_check=lambda a, b: a.state == b.state and b.confidence >= 0.8
)
```

**Benefits**:
- Termination conditions are explicit (not buried in while-loop logic)
- Composes with other Fix operations
- Separates "what" (detect state) from "how" (polling mechanics)

**Anti-pattern**: `while True` loops with inline break conditions.

---

### Idiom 2: Conflict is Data

> Tensions should be first-class citizens.

The Contradict/Sublate pattern generalizes beyond dialectics to system robustness:

```
Contradict: (A, B) → Tension | None
Sublate: Tension → Resolution | HoldTension
```

**Structure**:
1. **Detect** tensions explicitly (don't let them surface as runtime errors)
2. **Surface** them to the appropriate resolver (user, automated policy, or hold)
3. **Resolve or hold**—premature synthesis is worse than held tension

**Applies to**:
- Name collisions → detect before creation fails
- Resource conflicts → warn before exhaustion
- Configuration contradictions → surface at load time
- Concurrent modifications → explicit merge policies

**Example** (from zen-agents):
```python
@dataclass
class SessionConflict:
    conflict_type: str  # NAME_COLLISION, PORT_CONFLICT, WORKTREE_CONFLICT
    suggested_resolution: str

conflicts = await session_contradict.invoke((config, ground_state))
if conflicts:
    resolution = await session_sublate.invoke(conflicts[0])
```

**Anti-pattern**: Silent failures, swallowed exceptions, "last write wins" without warning.

---

### Idiom 3: Compose, Don't Concatenate

> If a function does A then B then C, it should BE the composition of A, B, C.

This is Compose applied as a design discipline:

```
Pipeline = A >> B >> C
# Not:
def do_everything():
    a_result = do_a()
    b_result = do_b(a_result)
    c_result = do_c(b_result)
    return c_result
```

**Benefits**:
- Each step is testable in isolation
- Clear data flow between steps
- Steps are replaceable/mockable
- Debugging: "which step failed?"

**Applies at all scales**:
- **Method level**: Extract steps as separate agents
- **Class level**: Compose services rather than inherit
- **System level**: Pipeline architectures over monoliths

**Example** (from zen-agents):
```python
NewSessionPipeline = (
    Judge(config)      # validate
    >> Create(config)  # make session object
    >> Spawn(session)  # create tmux
    >> Detect(session) # Fix-based state detection
)
```

**Anti-pattern**: 130-line methods mixing validation, I/O, state mutation, and error handling.

### Idiom 7: Reality is Trichotomous

> Classification precedes computation.

Before expanding a task, classify its reality. This idiom derives from Fix + Judge: Fix requires knowing WHETHER to iterate; Judge determines the nature of the task.

**The Trichotomy**:

| Reality | Characteristic | Action |
|---------|---------------|--------|
| DETERMINISTIC | Atomic, bounded, single-step | Execute directly (no iteration) |
| PROBABILISTIC | Complex, decomposable, multi-step | Iterate with budget (Fix with limit) |
| CHAOTIC | Unbounded, unstable, recursive | Collapse to Ground (refuse iteration) |

**Derivation**:

```python
# Reality classification = Judge applied to task structure
RealityClassifier: (Task, EntropyBudget) → Reality

# DETERMINISTIC: Task where Judge says "no decomposition needed"
is_atomic(task) and Judge(task, "can_execute_directly") = accept

# PROBABILISTIC: Task where Judge says "decompose and iterate"
is_complex(task) and Judge(task, "can_decompose") = accept

# CHAOTIC: Task where Judge says "stop, collapse to safety"
is_unbounded(task) or Judge(task, "stable") = reject
```

**Application (J-gents)**:

```python
async def invoke(self, intent: str) -> T:
    reality = await classify_reality(intent)

    match reality:
        case DETERMINISTIC:
            return await execute_atomic(intent)  # Direct execution
        case PROBABILISTIC:
            return await Fix(decompose)(intent)  # Iterate until stable
        case CHAOTIC:
            return Ground()  # Refuse to proceed
```

**Benefits**:
- Prevents runaway recursion (CHAOTIC → Ground)
- Optimizes simple tasks (DETERMINISTIC → no overhead)
- Enables resource budgeting (PROBABILISTIC → controlled iteration)

**See**: `spec/j-gents/reality.md` for full specification

---

## Open Questions

1. **Is Judge truly one agent or six?** The principles might be separately irreducible.

2. **Is Ground one agent or many?** Persona, world-state, and history might be separately irreducible.

3. **Are there other irreducibles?** Candidates:
   - Time (temporal ordering as primitive)
   - Attention (resource allocation as primitive)
   - Communication (agent-to-agent signaling as primitive)

4. **What's the Kolmogorov complexity of the bootstrap?** How small can Ground() be while still regenerating Kent-specific kgents?

---

### Idiom 4: Events are Sublate Traces

> State changes should emit events. Events are the "trace" of Sublate in action.

When state transitions (session created, killed, removed), the system should surface this:

```python
# WRONG: Silent state change
del self._sessions[id]
return True

# RIGHT: Emit event (Sublate trace)
del self._sessions[id]
await self._emit_event(SessionRemoved(session_id=id))
return True
```

**Why**: Events are how distributed components (UI, persistence, other services) learn about Sublate. Without events, tensions go undetected.

---

### Idiom 5: Ground Includes Environment

> Shell, platform, package structure are Ground—not assumptions.

The zen-agents bugs revealed implicit Ground:

```python
# WRONG: Assumes bash (not in Ground)
command = "read -p 'prompt' var"

# RIGHT: POSIX is Ground (works on bash, zsh, sh)
command = "printf 'prompt ' && read var"
```

**Ground checklist** for new implementations:
- Shell environment (POSIX, not bash-specific)
- Package structure (`pyproject.toml`, not `sys.path` hacks)
- Config defaults (merge, don't overwrite)
- Framework constraints (read the docs)

---

### Idiom 6: Fix Needs Memory

> Fixed-point iteration requires carrying state between iterations.

The zen-agents StateDetector bug: confidence never accumulated because each poll was stateless.

```python
# WRONG: Stateless (confidence always 0.2)
def detect(session) -> Result:
    return Result(confidence=0.2)

# RIGHT: Stateful (accumulates until convergence)
def detect(session, previous: Result) -> Result:
    if current_state == previous.state:
        return Result(
            state=current_state,
            confidence=min(1.0, previous.confidence + 0.2)
        )
    return Result(state=current_state, confidence=0.2)
```

**Pattern**: Fix carries `previous` state through iterations. The transform is `(State, Input) -> State`, not just `Input -> State`.

---

### Idiom 6.1: Bounded History (Performance Variant)

> Fixed-point iteration requires carrying state, but unbounded history is wasteful.

The current Fix implementation accumulates full history: `history: list[A] = [initial]`. For long-running iterations or large state objects, this consumes O(n × value_size) memory.

**Three History Strategies:**

**1. Full History (default)**
```python
# All iterations stored
FixConfig(max_iterations=100)
# Memory: O(n × value_size)
# Benefit: Complete debugging trace
```

**2. Bounded History**
```python
# Keep last N iterations only
@dataclass(frozen=True)
class BoundedFixConfig(FixConfig[A]):
    max_history_size: int = 100

    def should_keep(self, iteration: int, total: int) -> bool:
        # Keep last max_history_size iterations
        return iteration >= (total - self.max_history_size)

# Memory: O(min(n, max_history_size) × value_size)
# Benefit: Bounded memory, recent history for debugging
```

**3. Sampled History (logarithmic)**
```python
@dataclass(frozen=True)
class SampledFixConfig(FixConfig[A]):
    def should_keep(self, iteration: int) -> bool:
        # Keep powers of 2: iterations 0, 1, 2, 4, 8, 16, 32, ...
        return iteration == 0 or (iteration & (iteration - 1)) == 0

# Memory: O(log n × value_size)
# Benefit: Key checkpoints preserved (exponential sampling)
```

**Trade-off Matrix:**

| Strategy | Memory | Debugging | Use Case |
|----------|--------|-----------|----------|
| Full | O(n) | Complete trace | Development, small state |
| Bounded | O(1) | Recent context | Production, large state |
| Sampled | O(log n) | Checkpoints | Long iterations, analysis |

**Recommendation:**
- **Development**: Full history for complete debugging
- **Production**: Bounded history (last 10-100 iterations)
- **Analysis**: Sampled history for convergence studies

**Implementation Status**: Future enhancement to `impl/claude/bootstrap/fix.py`.

---

### Meta-Idiom: Autopoiesis Score

> Measure self-reference: what percentage of code was generated using kgents agents?

```
Autopoiesis Score = (lines generated by kgents) / (total lines)
```

- zen-agents score: ~5% (mostly manual coding)
- Target for future implementations: >50%

**Implication**: Use `ClaudeCLIRuntime` from line 1, not as a late integration. K-gent can name things. CreativityCoach can explore design. HypothesisEngine can validate architecture.

---

## See Also

- [principles.md](principles.md) - Judge's criteria
- [anatomy.md](anatomy.md) - What agents are
- [c-gents/composition.md](c-gents/composition.md) - Compose formalized
- [h-gents/hegel.md](h-gents/hegel.md) - Sublate in detail
- [k-gent/persona.md](k-gent/persona.md) - Ground's primary output
- `AUTONOMOUS_BOOTSTRAP_PROTOCOL.md` - Post-mortem and anti-patterns
