# Artifacts: Agent Living Objects

An **artifact** is the permanent, versioned, living document produced by F-gent's Forge Loop.

---

## Philosophy

> "An artifact is not just code—it is the crystallization of intent, contract, and implementation into a reusable whole."

Artifacts are **living objects**:
- They contain human-editable intent
- They contain machine-executable code
- They evolve through re-forging
- They maintain lineage and provenance

---

## The ALO Format: Agent Living Object

### File Structure

```markdown
---
# METADATA (YAML Frontmatter)
id: "agent_summarizer_v1"
type: "f_gent_artifact"
version: "1.0.0"
created_at: "2025-12-08T10:30:00Z"
created_by: "f-gent-instance-42"
parent_version: null  # For re-forged artifacts, reference previous version
status: "active"  # active | deprecated | experimental
hash: "a3f5c21e..."  # SHA-256 of artifact content (integrity check)
tags: ["summarization", "NLP", "executive"]
---

# 1. THE INTENT (Human-Editable)

> *This section contains the original natural language intent.*
> *Humans can edit this section to trigger re-forging.*

**Purpose**: Summarize technical papers for executive reading.

**Behavior**:
- Extract key findings from research papers
- Translate technical jargon to accessible language
- Provide confidence score for summary quality

**Constraints**:
- Output length < 500 words
- No hallucinations (all citations must exist in input)
- Concise, objective tone
- JSON output format

**Tone**: Professional, objective, devoid of unnecessary jargon.

---

# 2. THE CONTRACT (Machine-Verified)

> *This section defines the agent's interface and guarantees.*
> *Generated by F-gent during Forge Loop Phase 2.*

## Type Signature

```python
class SummarizerAgent(Agent[str, SummaryOutput]):
    """
    Agent that summarizes technical papers for executive audiences.
    """
    ...
```

**Input**: `str` (paper text or markdown)
**Output**: `SummaryOutput` (structured JSON)

```python
@dataclass
class SummaryOutput:
    title: str
    key_findings: list[str]
    confidence_score: float  # Range: 0.0 - 1.0
```

## Invariants

- **Length constraint**: `len(summary_text) < 500` words
- **Citation verification**: All claims traceable to input text
- **Confidence score**: `0.0 <= confidence_score <= 1.0`
- **JSON compliance**: Output matches `SummaryOutput` schema

## Composition Rules

**Sequential composition**:
```python
PDFParser[Path, str] >> SummarizerAgent[str, SummaryOutput]
→ Pipeline[Path, SummaryOutput]
```

**Parallel composition**:
```python
SummarizerAgent[str, SummaryOutput] × TagExtractor[str, Tags]
→ EnrichedSummarizer[str, (SummaryOutput, Tags)]
```

---

# 3. THE EXAMPLES (Test-Driven Validation)

> *This section contains test cases that validate correct behavior.*
> *Used during Forge Loop Phase 4 (Validate).*

## Example 1: Standard Paper

**Input**:
```
Title: Attention Is All You Need

Abstract: We propose a new network architecture, the Transformer,
based solely on attention mechanisms...
[rest of paper text]
```

**Expected Output**:
```json
{
  "title": "Attention Is All You Need",
  "key_findings": [
    "Introduces Transformer architecture using only attention mechanisms",
    "Eliminates recurrence and convolutions from sequence modeling",
    "Achieves state-of-the-art results on machine translation tasks"
  ],
  "confidence_score": 0.95
}
```

## Example 2: Short Paper (Edge Case)

**Input**:
```
Title: Brief Note on Algorithm X

Abstract: Algorithm X improves runtime by 10%.
```

**Expected Output**:
```json
{
  "title": "Brief Note on Algorithm X",
  "key_findings": [
    "Algorithm X provides 10% runtime improvement"
  ],
  "confidence_score": 0.85
}
```

---

# 4. THE IMPLEMENTATION (Auto-Generated)

> **WARNING: AUTO-GENERATED ZONE. DO NOT EDIT DIRECTLY.**
>
> This code is synthesized by F-gent from the Intent and Contract.
> To change behavior, edit Section 1 (Intent) and invoke F-gent to re-forge.
>
> **Generated**: 2025-12-08T10:30:00Z
> **Generator**: f-gent-instance-42
> **Validation**: ✓ Parsed | ✓ Type-checked | ✓ Security-scanned | ✓ Tests passed

```python
from dataclasses import dataclass
from typing import Protocol
from agents.c import Agent

@dataclass
class SummaryOutput:
    title: str
    key_findings: list[str]
    confidence_score: float

class SummarizerAgent(Agent[str, SummaryOutput]):
    """
    Summarize technical papers for executive reading.

    Guarantees:
    - Output length < 500 words
    - No hallucinations (citations exist in input)
    - Confidence score in [0.0, 1.0]
    """

    def __init__(self, llm_backend: Optional[LLM] = None):
        self.llm = llm_backend or default_llm()

    async def invoke(self, paper_text: str) -> SummaryOutput:
        # Extract title
        title = self._extract_title(paper_text)

        # Generate summary with length constraint
        findings = await self._generate_findings(paper_text, max_words=500)

        # Verify citations
        verified_findings = self._verify_citations(findings, paper_text)

        # Compute confidence
        confidence = self._compute_confidence(verified_findings, paper_text)

        return SummaryOutput(
            title=title,
            key_findings=verified_findings,
            confidence_score=confidence
        )

    def _extract_title(self, text: str) -> str:
        # Extract title from paper text
        lines = text.split("\n")
        for line in lines:
            if line.startswith("Title:"):
                return line.replace("Title:", "").strip()
        return "Untitled"

    async def _generate_findings(
        self,
        text: str,
        max_words: int
    ) -> list[str]:
        # Use LLM to extract key findings
        prompt = f"""
        Extract 3-5 key findings from this paper.
        Each finding should be 1-2 sentences, totaling < {max_words} words.

        Paper:
        {text}
        """
        response = await self.llm.generate(prompt)
        findings = self._parse_findings(response)
        return findings

    def _verify_citations(
        self,
        findings: list[str],
        source_text: str
    ) -> list[str]:
        # Remove findings that cannot be verified in source
        verified = []
        for finding in findings:
            if self._can_verify(finding, source_text):
                verified.append(finding)
        return verified

    def _can_verify(self, claim: str, source: str) -> bool:
        # Simplified verification (keyword matching)
        # Production would use semantic similarity
        keywords = claim.lower().split()
        source_lower = source.lower()
        return any(kw in source_lower for kw in keywords if len(kw) > 4)

    def _compute_confidence(
        self,
        findings: list[str],
        source_text: str
    ) -> float:
        # Confidence based on verification success rate
        if not findings:
            return 0.0
        verified_ratio = len(findings) / max(len(findings), 1)
        return min(verified_ratio * 0.95, 1.0)

    def _parse_findings(self, llm_response: str) -> list[str]:
        # Parse LLM response into list of findings
        lines = llm_response.strip().split("\n")
        findings = [
            line.strip("- ").strip()
            for line in lines
            if line.strip()
        ]
        return findings[:5]  # Max 5 findings
```

---

# CHANGELOG

## v1.0.0 (2025-12-08)
- Initial creation
- Implements basic summarization with citation verification
- Tested on 2 examples

---
```

---

## Metadata Schema

The YAML frontmatter contains artifact metadata:

```yaml
id: string                  # Unique identifier (agent_name_version)
type: "f_gent_artifact"    # Always this value
version: string             # Semantic version (major.minor.patch)
created_at: datetime        # ISO 8601 timestamp
created_by: string          # F-gent instance ID
parent_version: string?     # Previous version (for re-forged artifacts)
status: enum                # active | deprecated | experimental | retired
hash: string                # SHA-256 of artifact (excluding hash field itself)
tags: list[string]          # Searchable tags for L-gent
dependencies: list[Dep]?    # External dependencies (APIs, libraries)
```

### Status Lifecycle

```
experimental → active → deprecated → retired
     ↓           ↓
   (testing)  (production)
```

- **experimental**: Newly forged, undergoing validation
- **active**: Production-ready, stable contract
- **deprecated**: Superseded by newer version, avoid for new uses
- **retired**: No longer maintained, do not use

---

## Versioning Strategy

### Semantic Versioning: `MAJOR.MINOR.PATCH`

#### Patch (`1.0.0 → 1.0.1`)
**When**: Implementation bug fix, performance improvement
**Contract**: Unchanged
**Compatibility**: Fully backward compatible
**Example**:
```diff
- # Bug: confidence score could exceed 1.0
+ # Fixed: confidence clamped to [0.0, 1.0]
  return min(confidence, 1.0)
```

#### Minor (`1.0.0 → 1.1.0`)
**When**: New capability added, contract extended (backward compatible)
**Contract**: Expanded (new optional fields, stronger invariants)
**Compatibility**: Old consumers unaffected
**Example**:
```diff
  @dataclass
  class SummaryOutput:
      title: str
      key_findings: list[str]
      confidence_score: float
+     keywords: list[str] = field(default_factory=list)  # New optional field
```

#### Major (`1.0.0 → 2.0.0`)
**When**: Breaking change (contract modified, behavior changed)
**Contract**: Incompatible with previous version
**Compatibility**: May break existing consumers
**Example**:
```diff
- class SummarizerAgent(Agent[str, SummaryOutput]):
+ class SummarizerAgent(Agent[Document, SummaryOutput]):
  # Input type changed: str → Document (breaking)
```

---

## Integrity & Provenance

### Hash Computation

```python
def compute_artifact_hash(alo_file: str) -> str:
    """
    Compute SHA-256 hash of artifact for integrity verification.
    Excludes the hash field itself from computation.
    """
    content = read_alo_file(alo_file)
    # Remove YAML frontmatter hash field
    content_without_hash = remove_hash_field(content)
    return hashlib.sha256(content_without_hash.encode()).hexdigest()
```

**Purpose**:
- Detect drift (has artifact been modified outside F-gent?)
- Verify authenticity (is this the artifact L-gent registered?)
- Enable immutability checks

### Lineage Tracking

Each re-forged artifact references its parent:

```yaml
# Child artifact metadata
version: "1.1.0"
parent_version: "1.0.0"
```

**Enables**:
- Trace evolution history (1.0.0 → 1.0.1 → 1.1.0 → 2.0.0)
- Understand why changes were made (via commit messages, changelogs)
- Rollback to previous version if needed

---

## Re-Forging Workflow

When an artifact needs updating:

### 1. Trigger Re-Forge

**Reasons**:
- User edits Section 1 (Intent) and requests re-forge
- Runtime drift detected (failures in production)
- E-gent proposes evolution hypothesis

### 2. Load Existing Artifact

```python
old_artifact = read_alo_file("agent_summarizer_v1.alo.md")
old_intent = extract_intent(old_artifact)
old_contract = extract_contract(old_artifact)
```

### 3. Analyze Delta

**What changed**:
- Intent modifications (user edits)
- Environmental changes (API schemas, dependencies)
- Error patterns (production failures)

### 4. Re-Enter Forge Loop

- Start at Phase 2 (Contract synthesis) with updated intent
- Contract may change if intent changed significantly
- Implementation regenerated from scratch

### 5. Version Increment

```python
new_version = determine_version_increment(old_contract, new_contract)
# Patch: 1.0.0 → 1.0.1
# Minor: 1.0.0 → 1.1.0
# Major: 1.0.0 → 2.0.0
```

### 6. Approval (if breaking)

If major version (breaking change):
```
F-gent: "Re-forged artifact has breaking changes:
  - Input type changed: str → Document
  - This will affect 3 downstream agents: [list]

  Proceed with breaking change? (yes/no)"
```

### 7. Crystallize New Version

- Create `agent_summarizer_v1_1_0.alo.md` (or `v2_0_0` if major)
- Update metadata: `parent_version: "1.0.0"`
- Register with L-gent
- Optionally deprecate old version

---

## Artifact Discovery (L-gent Integration)

### Registration

When F-gent crystallizes artifact:
```python
l_gent.register(
    artifact_id="agent_summarizer_v1",
    path="artifacts/agent_summarizer_v1.alo.md",
    contract=contract,
    tags=["summarization", "NLP", "executive"],
    hash=artifact_hash
)
```

### Query Interface

Users/agents can discover artifacts:

```python
# Find by output type
l_gent.find_by_output_type(SummaryOutput)
→ [agent_summarizer_v1, enhanced_summarizer_v2]

# Find by tag
l_gent.find_by_tag("summarization")
→ [agent_summarizer_v1, abstract_summarizer_v1]

# Find composable agents
l_gent.find_composable_with(pdf_parser, direction="downstream")
→ [agent_summarizer_v1]  # PDF → str → SummaryOutput

# Semantic search (if VectorAgent backend)
l_gent.semantic_search("agents that summarize text")
→ [agent_summarizer_v1, text_condenser_v1]
```

---

## Human Editing Workflow

### Scenario: User Wants to Modify Artifact

1. **Open `.alo.md` file**
2. **Edit Section 1 (Intent)**:
   ```diff
     **Constraints**:
     - Output length < 500 words
   + - Include methodology summary
     - No hallucinations
   ```
3. **Save file**
4. **Invoke F-gent re-forge**:
   ```bash
   f-gent reforge agent_summarizer_v1.alo.md
   ```
5. **F-gent analyzes delta**:
   - Intent added: "Include methodology summary"
   - Contract needs update: Add `methodology: str` to `SummaryOutput`
   - Version: Minor bump (1.0.0 → 1.1.0)
6. **Approve contract changes** (if breaking)
7. **New artifact generated**: `agent_summarizer_v1_1_0.alo.md`

### Section Edit Permissions

| Section | Human Editable? | Re-Forge Trigger? |
|---------|-----------------|-------------------|
| Metadata | ❌ No (managed by F-gent) | N/A |
| Intent | ✅ Yes | Yes (re-forge with new intent) |
| Contract | ⚠️  View-only (informational) | Auto-updated from Intent |
| Examples | ✅ Yes (add test cases) | Yes (validation updated) |
| Implementation | ❌ No (auto-generated) | Auto-updated from Contract |

**Golden rule**: Never manually edit Section 4 (Implementation). To change behavior, edit Intent and re-forge.

---

## Artifact Ecosystem Roles

### F-gent (Creator)
- Forges new artifacts from intent
- Re-forges existing artifacts when triggered
- Ensures contract integrity

### L-gent (Librarian)
- Catalogs artifacts (searchable index)
- Provides discovery (by type, tag, composition)
- Tracks lineage (version history)

### E-gent (Evolver)
- Proposes improvements (hypotheses)
- Triggers F-gent re-forging
- Validates evolved artifacts

### C-gent (Composer)
- Uses artifacts as building blocks
- Composes pipelines from artifacts
- Validates composition type safety

### K-gent (User)
- Requests new artifacts (intent)
- Edits existing artifacts (intent modification)
- Approves breaking changes

---

## Example: Artifact Lifecycle

### Initial Creation (v1.0.0)

**User intent**: "Summarize papers"
**F-gent**: Forges `agent_summarizer_v1_0_0.alo.md`
**L-gent**: Registers artifact
**Status**: `active`

### Bug Fix (v1.0.1)

**Issue**: Confidence score exceeds 1.0 in edge case
**F-gent**: Re-forges with fix
**Version**: Patch bump (1.0.0 → 1.0.1)
**Status**: v1.0.1 `active`, v1.0.0 `deprecated`

### Feature Addition (v1.1.0)

**User request**: "Add keywords extraction"
**F-gent**: Re-forges with expanded contract
**Version**: Minor bump (1.0.1 → 1.1.0)
**Contract**: Added `keywords: list[str]` to output (backward compatible)
**Status**: v1.1.0 `active`, v1.0.1 `deprecated`

### Breaking Change (v2.0.0)

**Environmental change**: Input now requires structured `Document` instead of raw `str`
**F-gent**: Re-forges with new contract
**Version**: Major bump (1.1.0 → 2.0.0)
**Contract**: `Agent[str, ...] → Agent[Document, ...]`
**Approval**: Human reviews impact on 3 downstream agents, approves
**Status**: v2.0.0 `active`, v1.1.0 `deprecated`, v1.0.x `retired`

---

## Anti-Patterns

### ❌ Manual Code Edits

**Wrong**:
```
User edits Section 4 (Implementation) directly
→ Hash mismatch on next L-gent query
→ Drift detected, integrity compromised
```

**Right**:
```
User edits Section 1 (Intent)
→ Invokes F-gent re-forge
→ New implementation generated, hash updated
```

### ❌ Undocumented Versions

**Wrong**:
```yaml
version: "1.1.0"
# No changelog entry explaining change
```

**Right**:
```markdown
# CHANGELOG

## v1.1.0 (2025-12-09)
- Added keywords extraction to output
- Strengthened citation verification
```

### ❌ Orphaned Artifacts

**Wrong**:
```
Artifact created but not registered with L-gent
→ Not discoverable, not composable, ecosystem unaware
```

**Right**:
```
F-gent crystallizes → immediately registers with L-gent
→ Discoverable, composable, ecosystem-integrated
```

---

## See Also

- [forge.md](forge.md) - How artifacts are created
- [contracts.md](contracts.md) - Contract structure and synthesis
- [README.md](README.md) - F-gent philosophy
- [../e-gents/](../e-gents/) - Artifact evolution
- [../d-gents/persistence.md](../d-gents/persistence.md) - Artifact storage backends
