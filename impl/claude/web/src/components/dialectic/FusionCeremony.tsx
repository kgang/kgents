/**
 * FusionCeremony - The Main Dialectical Synthesis UI
 *
 * "Make disagreement beautiful. Create a UI where Kent and Claude can synthesize."
 *
 * From the Constitution (Article VI):
 * "The goal is not Kent's decisions or AI's decisions.
 *  The goal is fused decisions better than either alone."
 *
 * DESIGN PRINCIPLES (Kent's voice):
 * - "Daring, bold, creative, opinionated but not gaudy"
 * - "simplistic, brutalistic?, dense, intelligent design"
 * - Not compromise (which loses information), but Aufhebung (which transcends both)
 *
 * Layout:
 *   ┌─────────────────────────────────────────────────────────────┐
 *   │                     FUSION CEREMONY                         │
 *   │                   ┌─────────────┐                          │
 *   │                   │   COCONE    │                          │
 *   │                   │  (visual)   │                          │
 *   │                   └─────────────┘                          │
 *   ├───────────────┬─────────────────────┬──────────────────────┤
 *   │    THESIS     │     SYNTHESIS       │    ANTITHESIS        │
 *   │   (Kent)      │    (the fusion)     │    (Claude)          │
 *   │               │                     │                      │
 *   └───────────────┴─────────────────────┴──────────────────────┘
 */

import { useState, useCallback, useMemo, useRef } from 'react';
import { sublate } from '@/api/dialectic';
import { ThesisPanel } from './ThesisPanel';
import { AntithesisPanel } from './AntithesisPanel';
import { SynthesisPanel } from './SynthesisPanel';
import { CoconeVisualization } from './CoconeVisualization';
import type { FusionCeremonyProps, CeremonyState, ExportData, ExportFormat } from './types';
import { INITIAL_CEREMONY_STATE } from './types';
import './FusionCeremony.css';

// =============================================================================
// Export Utilities
// =============================================================================

/**
 * Generate export data from ceremony state.
 */
function generateExportData(state: CeremonyState): ExportData | null {
  if (!state.fusionId || !state.result) return null;

  return {
    topic: state.topic,
    kentPosition: {
      content: state.thesis?.content || '',
      reasoning: state.thesis?.reasoning || '',
    },
    claudePosition: {
      content: state.antithesis?.content || '',
      reasoning: state.antithesis?.reasoning || '',
    },
    synthesis: state.synthesis
      ? {
          content: state.synthesis.content,
          reasoning: state.synthesis.reasoning,
          preservedFromKent: state.synthesis.preservedFromKent,
          preservedFromClaude: state.synthesis.preservedFromClaude,
          transcends: state.synthesis.transcends,
        }
      : null,
    result: state.result,
    trustDelta: state.trustDelta || 0,
    fusionId: state.fusionId,
    timestamp: new Date().toISOString(),
  };
}

/**
 * Export fusion as Markdown.
 */
function exportAsMarkdown(data: ExportData): string {
  const lines = [
    `# Dialectical Fusion: ${data.topic}`,
    '',
    `**Fusion ID:** ${data.fusionId}`,
    `**Result:** ${data.result}`,
    `**Trust Delta:** ${data.trustDelta > 0 ? '+' : ''}${data.trustDelta.toFixed(2)}`,
    `**Date:** ${new Date(data.timestamp).toLocaleDateString()}`,
    '',
    '---',
    '',
    "## Kent's Position (Thesis)",
    '',
    data.kentPosition.content,
    '',
    `> **Reasoning:** ${data.kentPosition.reasoning}`,
    '',
    "## Claude's Position (Antithesis)",
    '',
    data.claudePosition.content,
    '',
    `> **Reasoning:** ${data.claudePosition.reasoning}`,
    '',
    '---',
    '',
    '## Synthesis (Aufhebung)',
    '',
  ];

  if (data.synthesis) {
    lines.push(
      data.synthesis.content,
      '',
      `> **Reasoning:** ${data.synthesis.reasoning}`,
      '',
      '### What Was Preserved',
      '',
      `**From Kent:** ${data.synthesis.preservedFromKent}`,
      '',
      `**From Claude:** ${data.synthesis.preservedFromClaude}`,
      '',
      '### What Transcends Both',
      '',
      data.synthesis.transcends
    );
  } else {
    lines.push('*No explicit synthesis generated.*');
  }

  lines.push('', '---', '', '*Generated by kgents Fusion Ceremony*');

  return lines.join('\n');
}

/**
 * Copy text to clipboard.
 */
async function copyToClipboard(text: string): Promise<boolean> {
  try {
    await navigator.clipboard.writeText(text);
    return true;
  } catch (err) {
    console.error('Failed to copy:', err);
    return false;
  }
}

// =============================================================================
// FusionCeremony Component
// =============================================================================

/**
 * FusionCeremony Component
 *
 * The main UI for dialectical synthesis between Kent and Claude.
 *
 * @example
 * <FusionCeremony
 *   initialTopic="Database architecture"
 *   onFusionComplete={(state) => console.log('Fusion complete:', state)}
 * />
 */
export function FusionCeremony({
  initialTopic = '',
  initialKentView = '',
  initialClaudeView = '',
  onFusionComplete,
  className = '',
}: FusionCeremonyProps) {
  // ==========================================================================
  // State
  // ==========================================================================

  const [state, setState] = useState<CeremonyState>({
    ...INITIAL_CEREMONY_STATE,
    topic: initialTopic,
    thesis: initialKentView ? { content: initialKentView, reasoning: '', holder: 'kent' } : null,
    antithesis: initialClaudeView
      ? { content: initialClaudeView, reasoning: '', holder: 'claude' }
      : null,
  });

  // Form fields (separate from state for responsiveness)
  const [topic, setTopic] = useState(initialTopic);
  const [kentView, setKentView] = useState(initialKentView);
  const [kentReasoning, setKentReasoning] = useState('');
  const [claudeView, setClaudeView] = useState(initialClaudeView);
  const [claudeReasoning, setClaudeReasoning] = useState('');

  // Export state
  const [exportCopied, setExportCopied] = useState(false);

  // Ref for the ceremony container (for export as image)
  const ceremonyRef = useRef<HTMLDivElement>(null);

  // ==========================================================================
  // Derived State
  // ==========================================================================

  const canSynthesize = useMemo(() => {
    return topic.trim() && kentView.trim() && claudeView.trim();
  }, [topic, kentView, claudeView]);

  const isProcessing = state.phase === 'processing';
  const isComplete = state.phase === 'complete';

  // Build positions for visualization
  const thesisPosition = useMemo(
    () =>
      kentView ? { content: kentView, reasoning: kentReasoning, holder: 'kent' as const } : null,
    [kentView, kentReasoning]
  );

  const antithesisPosition = useMemo(
    () =>
      claudeView
        ? { content: claudeView, reasoning: claudeReasoning, holder: 'claude' as const }
        : null,
    [claudeView, claudeReasoning]
  );

  // ==========================================================================
  // Handlers
  // ==========================================================================

  /**
   * Handle synthesis (sublation).
   */
  const handleSynthesize = useCallback(async () => {
    if (!canSynthesize || isProcessing) return;

    // Set processing state
    setState((prev) => ({
      ...prev,
      phase: 'processing',
      error: null,
    }));

    try {
      const result = await sublate({
        topic,
        kentView,
        kentReasoning,
        claudeView,
        claudeReasoning,
      });

      const newState: CeremonyState = {
        phase: 'complete',
        topic,
        thesis: { content: kentView, reasoning: kentReasoning, holder: 'kent' },
        antithesis: { content: claudeView, reasoning: claudeReasoning, holder: 'claude' },
        synthesis: result.synthesis,
        result: result.result,
        reasoning: result.reasoning,
        trustDelta: result.trustDelta,
        fusionId: result.fusionId,
        markId: result.markId,
        error: null,
      };

      setState(newState);
      onFusionComplete?.(newState);
    } catch (err) {
      setState((prev) => ({
        ...prev,
        phase: 'error',
        error: err instanceof Error ? err.message : 'Synthesis failed',
      }));
    }
  }, [
    canSynthesize,
    isProcessing,
    topic,
    kentView,
    kentReasoning,
    claudeView,
    claudeReasoning,
    onFusionComplete,
  ]);

  /**
   * Reset the ceremony.
   */
  const handleReset = useCallback(() => {
    setState(INITIAL_CEREMONY_STATE);
    setTopic('');
    setKentView('');
    setKentReasoning('');
    setClaudeView('');
    setClaudeReasoning('');
    setExportCopied(false);
  }, []);

  /**
   * Export the fusion.
   */
  const handleExport = useCallback(
    async (format: ExportFormat) => {
      const exportData = generateExportData(state);
      if (!exportData) return;

      switch (format) {
        case 'markdown': {
          const markdown = exportAsMarkdown(exportData);
          const success = await copyToClipboard(markdown);
          if (success) {
            setExportCopied(true);
            setTimeout(() => setExportCopied(false), 2000);
          }
          break;
        }
        case 'json': {
          const json = JSON.stringify(exportData, null, 2);
          const success = await copyToClipboard(json);
          if (success) {
            setExportCopied(true);
            setTimeout(() => setExportCopied(false), 2000);
          }
          break;
        }
        case 'image':
          // Future: Use html2canvas or similar
          console.info('Image export not yet implemented');
          break;
        case 'link':
          // Future: Generate shareable link
          console.info('Link export not yet implemented');
          break;
      }
    },
    [state]
  );

  // ==========================================================================
  // Keyboard Shortcuts
  // ==========================================================================

  // Ctrl/Cmd + Enter to synthesize
  const handleKeyDown = useCallback(
    (e: React.KeyboardEvent) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 'Enter' && canSynthesize && !isProcessing) {
        e.preventDefault();
        handleSynthesize();
      }
    },
    [canSynthesize, isProcessing, handleSynthesize]
  );

  // ==========================================================================
  // Render
  // ==========================================================================

  return (
    <div
      ref={ceremonyRef}
      className={`fusion-ceremony ${className}`}
      onKeyDown={handleKeyDown}
      data-phase={state.phase}
    >
      {/* Header */}
      <header className="fusion-ceremony__header">
        <h1 className="fusion-ceremony__title">Fusion Ceremony</h1>
        <p className="fusion-ceremony__subtitle">
          Synthesis through dialectic. Not compromise, but Aufhebung.
        </p>
      </header>

      {/* Cocone Visualization */}
      <div className="fusion-ceremony__cocone">
        <CoconeVisualization
          thesis={thesisPosition}
          antithesis={antithesisPosition}
          synthesis={state.synthesis}
          phase={state.phase}
        />
      </div>

      {/* Main Content - Three Panels */}
      <div className="fusion-ceremony__panels">
        {/* Thesis Panel (Kent) */}
        <ThesisPanel
          topic={topic}
          onTopicChange={setTopic}
          content={kentView}
          onContentChange={setKentView}
          reasoning={kentReasoning}
          onReasoningChange={setKentReasoning}
          disabled={isProcessing || isComplete}
        />

        {/* Synthesis Panel (Center) */}
        <SynthesisPanel
          synthesis={state.synthesis}
          result={state.result}
          reasoning={state.reasoning}
          trustDelta={state.trustDelta}
          loading={isProcessing}
        />

        {/* Antithesis Panel (Claude) */}
        <AntithesisPanel
          content={claudeView}
          onContentChange={setClaudeView}
          reasoning={claudeReasoning}
          onReasoningChange={setClaudeReasoning}
          thesisContent={kentView}
          disabled={isProcessing || isComplete}
        />
      </div>

      {/* Error Display */}
      {state.error && (
        <div className="fusion-ceremony__error">
          <span className="fusion-ceremony__error-icon">!</span>
          <span className="fusion-ceremony__error-text">{state.error}</span>
        </div>
      )}

      {/* Actions */}
      <footer className="fusion-ceremony__footer">
        {!isComplete ? (
          <div className="fusion-ceremony__actions">
            <button
              className="fusion-button fusion-button--primary"
              onClick={handleSynthesize}
              disabled={!canSynthesize || isProcessing}
            >
              {isProcessing ? 'Synthesizing...' : 'Synthesize'}
            </button>
            <span className="fusion-ceremony__hint">
              <kbd>Ctrl</kbd> + <kbd>Enter</kbd> to synthesize
            </span>
          </div>
        ) : (
          <div className="fusion-ceremony__actions fusion-ceremony__actions--complete">
            <button className="fusion-button fusion-button--secondary" onClick={handleReset}>
              New Fusion
            </button>
            <div className="fusion-ceremony__export">
              <button
                className="fusion-button fusion-button--ghost"
                onClick={() => handleExport('markdown')}
                title="Copy as Markdown"
              >
                {exportCopied ? 'Copied!' : 'Copy Markdown'}
              </button>
              <button
                className="fusion-button fusion-button--ghost"
                onClick={() => handleExport('json')}
                title="Copy as JSON"
              >
                Copy JSON
              </button>
            </div>
          </div>
        )}
      </footer>

      {/* Fusion ID (when complete) */}
      {state.fusionId && (
        <div className="fusion-ceremony__meta">
          <span className="fusion-ceremony__meta-label">Fusion ID:</span>
          <code className="fusion-ceremony__meta-value">{state.fusionId}</code>
          {state.markId && (
            <>
              <span className="fusion-ceremony__meta-separator">|</span>
              <span className="fusion-ceremony__meta-label">Mark:</span>
              <code className="fusion-ceremony__meta-value">{state.markId}</code>
            </>
          )}
        </div>
      )}
    </div>
  );
}

export default FusionCeremony;
