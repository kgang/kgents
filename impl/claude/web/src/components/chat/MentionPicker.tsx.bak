/**
 * MentionPicker — Autocomplete for @mentions in chat
 *
 * "Vim and iterm as primitives. Fuzzy finding like fzf/telescope.nvim"
 *
 * Triggers on `@` character in textarea. Supports:
 * - @file:path/to/file.py → File contents
 * - @symbol:ClassName.method → Definition + docstring
 * - @spec:protocols/chat-web.md → Spec file
 * - @witness:recent → Recent marks
 * - @web:https://example.com → Fetched page
 * - @terminal:last → Last command output
 * - @project:files → Project file tree
 *
 * Key behaviors:
 * - Fuzzy search with simple includes (can upgrade to Fuse.js later)
 * - Keyboard navigation: j/k for up/down (vim-like)
 * - Arrow keys also work (for non-vim users)
 * - Enter to select, Escape to dismiss
 * - Position relative to cursor in textarea
 * - Show recently used @mentions at top
 * - Debounced search (300ms)
 *
 * STARK BIOME styling: steel frame, earned glow on selection
 *
 * @see spec/protocols/chat-web.md Part VI
 */

import { memo, useState, useEffect, useCallback, useRef, useMemo } from 'react';
import { FileText, Code, BookOpen, Eye, Globe, Terminal, FolderTree, Clock } from 'lucide-react';
import './MentionPicker.css';

// =============================================================================
// Types
// =============================================================================

export type MentionType = 'file' | 'symbol' | 'spec' | 'witness' | 'web' | 'terminal' | 'project';

export interface MentionSuggestion {
  type: MentionType;
  value: string;
  label: string;
  description?: string;
  recent?: boolean;
}

export interface MentionPickerProps {
  /** Whether the picker is open */
  isOpen: boolean;

  /** Current search query (after @ trigger) */
  query: string;

  /** Callback when a mention is selected */
  onSelect: (suggestion: MentionSuggestion) => void;

  /** Callback to close the picker */
  onClose: () => void;

  /** Position relative to textarea cursor */
  position?: { top: number; left: number };

  /** Recently used mentions (shown at top) */
  recentMentions?: MentionSuggestion[];

  /** Available file paths for @file: */
  availableFiles?: string[];

  /** Available symbols for @symbol: */
  availableSymbols?: string[];

  /** Available specs for @spec: */
  availableSpecs?: string[];
}

// =============================================================================
// Icons
// =============================================================================

const MENTION_ICONS: Record<MentionType, typeof FileText> = {
  file: FileText,
  symbol: Code,
  spec: BookOpen,
  witness: Eye,
  web: Globe,
  terminal: Terminal,
  project: FolderTree,
};

const MENTION_LABELS: Record<MentionType, string> = {
  file: 'File',
  symbol: 'Symbol',
  spec: 'Spec',
  witness: 'Witness',
  web: 'Web',
  terminal: 'Terminal',
  project: 'Project',
};

// =============================================================================
// Mention Type Detection
// =============================================================================

function detectMentionType(query: string): MentionType | null {
  if (query.startsWith('file:')) return 'file';
  if (query.startsWith('symbol:')) return 'symbol';
  if (query.startsWith('spec:')) return 'spec';
  if (query.startsWith('witness:')) return 'witness';
  if (query.startsWith('web:')) return 'web';
  if (query.startsWith('terminal:')) return 'terminal';
  if (query.startsWith('project:')) return 'project';
  return null;
}

// =============================================================================
// Fuzzy Matching
// =============================================================================

/** Simple fuzzy match - checks if search term exists in target (case-insensitive) */
function fuzzyMatch(searchTerm: string, target: string): boolean {
  if (!searchTerm) return true;
  return target.toLowerCase().includes(searchTerm.toLowerCase());
}

// =============================================================================
// Generate Suggestions
// =============================================================================

function generateSuggestions(
  query: string,
  availableFiles: string[] = [],
  availableSymbols: string[] = [],
  availableSpecs: string[] = [],
  recentMentions: MentionSuggestion[] = []
): MentionSuggestion[] {
  const suggestions: MentionSuggestion[] = [];

  // If no query, show all types
  if (!query) {
    return [
      { type: 'file', value: '', label: '@file:', description: 'Inject file contents' },
      { type: 'symbol', value: '', label: '@symbol:', description: 'Inject symbol definition' },
      { type: 'spec', value: '', label: '@spec:', description: 'Inject spec file' },
      { type: 'witness', value: '', label: '@witness:', description: 'Inject witness marks' },
      { type: 'web', value: '', label: '@web:', description: 'Inject web page' },
      { type: 'terminal', value: '', label: '@terminal:', description: 'Inject terminal output' },
      { type: 'project', value: '', label: '@project:', description: 'Inject project file tree' },
    ];
  }

  const mentionType = detectMentionType(query);
  const searchTerm = mentionType ? query.split(':')[1] || '' : query;

  // Recent mentions at top (if they match)
  if (recentMentions.length > 0) {
    const matchingRecent = recentMentions.filter((m) =>
      fuzzyMatch(searchTerm, m.value)
    );
    suggestions.push(...matchingRecent.map((m) => ({ ...m, recent: true })));
  }

  // File mentions
  if (!mentionType || mentionType === 'file') {
    const matchingFiles = availableFiles
      .filter((f) => fuzzyMatch(searchTerm, f))
      .slice(0, 5)
      .map((f) => ({
        type: 'file' as MentionType,
        value: f,
        label: `@file:${f}`,
        description: 'File contents',
      }));
    suggestions.push(...matchingFiles);
  }

  // Symbol mentions
  if (!mentionType || mentionType === 'symbol') {
    const matchingSymbols = availableSymbols
      .filter((s) => fuzzyMatch(searchTerm, s))
      .slice(0, 5)
      .map((s) => ({
        type: 'symbol' as MentionType,
        value: s,
        label: `@symbol:${s}`,
        description: 'Definition + docstring',
      }));
    suggestions.push(...matchingSymbols);
  }

  // Spec mentions
  if (!mentionType || mentionType === 'spec') {
    const matchingSpecs = availableSpecs
      .filter((s) => fuzzyMatch(searchTerm, s))
      .slice(0, 5)
      .map((s) => ({
        type: 'spec' as MentionType,
        value: s,
        label: `@spec:${s}`,
        description: 'Spec file',
      }));
    suggestions.push(...matchingSpecs);
  }

  // Witness mentions (predefined options)
  if (!mentionType || mentionType === 'witness') {
    const witnessOptions = [
      { value: 'recent', description: 'Last 10 marks' },
      { value: 'today', description: "Today's marks" },
      { value: 'week', description: 'This week' },
    ];
    const matchingWitness = witnessOptions
      .filter((w) => fuzzyMatch(searchTerm, w.value))
      .map((w) => ({
        type: 'witness' as MentionType,
        value: w.value,
        label: `@witness:${w.value}`,
        description: w.description,
      }));
    suggestions.push(...matchingWitness);
  }

  // Terminal mentions (predefined options)
  if (!mentionType || mentionType === 'terminal') {
    const terminalOptions = [
      { value: 'last', description: 'Last command output' },
      { value: 'history', description: 'Command history' },
    ];
    const matchingTerminal = terminalOptions
      .filter((t) => fuzzyMatch(searchTerm, t.value))
      .map((t) => ({
        type: 'terminal' as MentionType,
        value: t.value,
        label: `@terminal:${t.value}`,
        description: t.description,
      }));
    suggestions.push(...matchingTerminal);
  }

  // Web mentions (manual input)
  if (mentionType === 'web' && searchTerm) {
    suggestions.push({
      type: 'web',
      value: searchTerm,
      label: `@web:${searchTerm}`,
      description: 'Fetch web page',
    });
  }

  // Project mentions (predefined options)
  if (!mentionType || mentionType === 'project') {
    const projectOptions = [
      { value: 'files', description: 'Project file tree' },
      { value: 'structure', description: 'Directory structure' },
    ];
    const matchingProject = projectOptions
      .filter((p) => fuzzyMatch(searchTerm, p.value))
      .map((p) => ({
        type: 'project' as MentionType,
        value: p.value,
        label: `@project:${p.value}`,
        description: p.description,
      }));
    suggestions.push(...matchingProject);
  }

  return suggestions;
}

// =============================================================================
// Component
// =============================================================================

export const MentionPicker = memo(function MentionPicker({
  isOpen,
  query,
  onSelect,
  onClose,
  position = { top: 0, left: 0 },
  recentMentions = [],
  availableFiles = [],
  availableSymbols = [],
  availableSpecs = [],
}: MentionPickerProps) {
  const [selectedIndex, setSelectedIndex] = useState(0);
  const [debouncedQuery, setDebouncedQuery] = useState(query);
  const listRef = useRef<HTMLDivElement>(null);

  // Debounce search query (300ms)
  useEffect(() => {
    const timeout = setTimeout(() => {
      setDebouncedQuery(query);
    }, 300);

    return () => clearTimeout(timeout);
  }, [query]);

  // Generate suggestions
  const suggestions = useMemo(
    () =>
      generateSuggestions(
        debouncedQuery,
        availableFiles,
        availableSymbols,
        availableSpecs,
        recentMentions
      ),
    [debouncedQuery, availableFiles, availableSymbols, availableSpecs, recentMentions]
  );

  // Reset selected index when suggestions change
  useEffect(() => {
    setSelectedIndex(0);
  }, [suggestions]);

  // Scroll selected item into view
  useEffect(() => {
    if (listRef.current) {
      const selectedElement = listRef.current.children[selectedIndex] as HTMLElement;
      if (selectedElement) {
        selectedElement.scrollIntoView({ block: 'nearest' });
      }
    }
  }, [selectedIndex]);

  // Handle keyboard navigation
  const handleKeyDown = useCallback(
    (e: KeyboardEvent) => {
      if (!isOpen) return;

      switch (e.key) {
        case 'ArrowDown':
        case 'j': // vim-like down
          e.preventDefault();
          setSelectedIndex((i) => (i + 1) % suggestions.length);
          break;

        case 'ArrowUp':
        case 'k': // vim-like up
          e.preventDefault();
          setSelectedIndex((i) => (i - 1 + suggestions.length) % suggestions.length);
          break;

        case 'Enter':
          e.preventDefault();
          if (suggestions[selectedIndex]) {
            onSelect(suggestions[selectedIndex]);
          }
          break;

        case 'Escape':
          e.preventDefault();
          onClose();
          break;
      }
    },
    [isOpen, suggestions, selectedIndex, onSelect, onClose]
  );

  useEffect(() => {
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [handleKeyDown]);

  if (!isOpen || suggestions.length === 0) return null;

  return (
    <div
      className="mention-picker"
      style={{
        top: position.top,
        left: position.left,
      }}
    >
      <div className="mention-picker__header">
        <span className="mention-picker__title">@mentions</span>
        <span className="mention-picker__count">
          {suggestions.length} {suggestions.length === 1 ? 'result' : 'results'}
        </span>
      </div>

      <div ref={listRef} className="mention-picker__list">
        {suggestions.map((suggestion, index) => {
          const Icon = MENTION_ICONS[suggestion.type];
          const isSelected = index === selectedIndex;

          return (
            <button
              key={`${suggestion.type}-${suggestion.value}-${index}`}
              className={`mention-picker__item ${isSelected ? 'mention-picker__item--selected' : ''}`}
              onClick={() => onSelect(suggestion)}
              onMouseEnter={() => setSelectedIndex(index)}
            >
              <Icon size={16} className="mention-picker__item-icon" />
              <div className="mention-picker__item-content">
                <div className="mention-picker__item-label">
                  {suggestion.recent && (
                    <Clock size={12} className="mention-picker__item-recent-icon" />
                  )}
                  {suggestion.label}
                </div>
                {suggestion.description && (
                  <div className="mention-picker__item-description">{suggestion.description}</div>
                )}
              </div>
              <span className="mention-picker__item-type">{MENTION_LABELS[suggestion.type]}</span>
            </button>
          );
        })}
      </div>

      <div className="mention-picker__footer">
        <kbd>↑↓</kbd> or <kbd>j/k</kbd> • <kbd>Enter</kbd> select • <kbd>Esc</kbd> close
      </div>
    </div>
  );
});

export default MentionPicker;
