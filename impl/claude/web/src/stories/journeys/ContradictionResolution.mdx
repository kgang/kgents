{/* @jsxImportSource react */}
import { Meta, Canvas, Story, Source } from '@storybook/blocks';

<Meta title="Journeys/3. Contradiction Resolution - Detecting and Resolving Tensions" />

# Journey 3: Contradiction Resolution

> "Contradictions are features, not bugs."

The Contradiction Resolution journey covers how kgents detects, surfaces,
and helps resolve tensions between beliefs, values, and implementations.

## Philosophy

Most systems hide contradictions. kgents **celebrates** them.

A contradiction is not a failure—it's an opportunity for synthesis.
The system actively surfaces tensions because:

1. **Apparent contradictions** reveal unclear thinking
2. **Productive tensions** drive creative synthesis
3. **Genuine contradictions** signal system evolution needs

---

## Types of Contradictions

### Apparent Contradictions

Seeming conflicts that dissolve under scrutiny:

```
Thesis: "Agents should be stateless"
Antithesis: "Memory is essential for learning"
Resolution: SCOPE — "Stateless at invocation level,
            persistent at agent lifecycle level"
```

**Visual**: Steel-blue indicator (low severity)

### Productive Tensions

Real tensions that drive synthesis:

```
Thesis: "All agents should be pure functions"
Antithesis: "State machines are necessary for complex behavior"
Resolution: SYNTHESIS — "PolyAgent[S,A,B] combines both:
            pure at each step, stateful across transitions"
```

**Visual**: Life-sage indicator (medium severity)

### Genuine Contradictions

Irreconcilable conflicts requiring system change:

```
Thesis: "Users own all their data"
Antithesis: "Analytics require data aggregation"
Resolution: SUPERSEDE — "New principle: Aggregation must be
            opt-in and locally computed"
```

**Visual**: Glow-spore indicator (high severity)

---

## The Five Resolution Strategies

| Strategy | Icon | Description | Example |
|----------|------|-------------|---------|
| **Synthesis** | + | Create a third thing, better than either | Thesis + Antithesis = Novel insight |
| **Scope** | subset | Narrow the scope of claims | "Always true" becomes "True in domain D" |
| **Temporal** | clock | Both true at different times | "X was true then, Y is true now" |
| **Context** | grid | Both true in different contexts | "X for context A, Y for context B" |
| **Supersede** | arrow | One claim supersedes the other | "New evidence: Y replaces X" |

### Choosing a Strategy

```
Is either claim wrong? → SUPERSEDE
Did circumstances change? → TEMPORAL
Do they apply differently? → CONTEXT
Can scope be narrowed? → SCOPE
Can we transcend both? → SYNTHESIS (preferred)
```

---

## Super-Additive Loss Detection

The system detects contradictions through **loss accumulation**:

```typescript
// Loss formula
const combinedLoss = lossBetween(thesis, antithesis);

// Super-additive detection
if (combinedLoss > thesis.loss + antithesis.loss) {
  // Contradiction detected!
  // The combination is worse than the sum of parts
  surfaceContradiction(thesis, antithesis);
}
```

**Intuition**: When putting two beliefs together creates MORE incoherence
than they have individually, there's a contradiction.

---

## Contradiction Primitives

### ContradictionBadge

Lightning bolt indicator for marking contradictions:

```tsx
import { ContradictionBadge } from '@/primitives/Contradiction';

<ContradictionBadge
  hasContradiction={true}
  severity="medium"
  onClick={() => showResolutionPanel()}
  tooltip="Productive tension detected"
/>
```

**Design Notes**:
- Lightning bolt icon (energy, tension)
- Severity determines color (steel/sage/spore)
- Subtle breathing animation when active

### ContradictionPolaroid

Side-by-side comparison for visual analysis:

```tsx
import { ContradictionPolaroid } from '@/primitives/Contradiction';

<ContradictionPolaroid
  thesis={{
    content: "All agents should be stateless",
    source: "spec/principles.md"
  }}
  antithesis={{
    content: "Memory is essential for agent learning",
    source: "impl/services/brain/README.md"
  }}
  contradictionType="productive"
  onResolve={(strategy) => handleResolution(strategy)}
/>
```

**Design Notes**:
- Polaroid-style cards (thesis left, antithesis right)
- Source attribution for traceability
- Quick-resolve buttons for common strategies

### ResolutionPanel

Full resolution interface with all five strategies:

```tsx
import { ResolutionPanel } from '@/primitives/Contradiction';

<ResolutionPanel
  thesis="All agents should be stateless"
  antithesis="Memory is essential for agent learning"
  onSelectStrategy={(strategy) => {
    applyResolution(strategy);
    setShowPanel(false);
  }}
  suggestedStrategy="synthesis"
  onClose={() => setShowPanel(false)}
/>
```

**Design Notes**:
- Full-width panel (modal-like)
- Strategy cards with icon, description, example
- Suggested strategy highlighted with glow
- Loading state for AI-assisted resolution

---

## Backend Integration

### Contradiction Detection API

```typescript
// POST /api/contradiction/detect
interface DetectRequest {
  kblock_ids: string[];  // K-Blocks to check
}

interface DetectResponse {
  contradictions: Contradiction[];
}

interface Contradiction {
  id: string;
  thesis: { content: string; source?: string };
  antithesis: { content: string; source?: string };
  type: 'genuine' | 'productive' | 'apparent';
  severity: 'low' | 'medium' | 'high';
  superAdditiveLoss: number;
  suggestedStrategy?: ResolutionStrategy;
}
```

### Resolution API

```typescript
// POST /api/contradiction/resolve
interface ResolveRequest {
  contradiction_id: string;
  strategy: ResolutionStrategy;
  synthesis?: string;  // For SYNTHESIS strategy
  notes?: string;      // Resolution reasoning
}

interface ResolveResponse {
  resolved: boolean;
  newKblockId?: string;  // If synthesis creates new K-Block
  markId: string;        // Witness mark for the resolution
}
```

---

## The Resolution Flow

### Step 1: Detection

The system continuously monitors for contradictions:
- New K-Block created → Check against existing K-Blocks
- Loss threshold exceeded → Surface contradiction
- User triggers audit → Full contradiction scan

### Step 2: Notification

```tsx
// In navigation or sidebar
<ContradictionBadge
  hasContradiction={hasUnresolved}
  count={unresolvedCount}
/>
```

### Step 3: Investigation

User clicks badge → Opens ContradictionPolaroid:
- See both sides clearly
- Review sources
- Consider context

### Step 4: Resolution

User selects strategy → Opens ResolutionPanel:
- Choose from five strategies
- Optionally write synthesis
- System suggests based on loss analysis

### Step 5: Witness

Resolution is witnessed as a mark:
```json
{
  "action": "Resolved contradiction via SYNTHESIS",
  "reasoning": "Pure functions and state machines coexist in PolyAgent",
  "tags": ["composable", "generative"]
}
```

---

## STARK BIOME Aesthetics

### Color Encoding

| Severity | Color | CSS Variable |
|----------|-------|--------------|
| Low (apparent) | Steel-blue | `--color-steel-500` |
| Medium (productive) | Life-sage | `--color-life-sage` |
| High (genuine) | Glow-spore | `--color-glow-spore` |

### Animation

- Badge: Subtle pulse when contradictions exist
- Polaroid: Hover reveals source attribution
- Panel: Strategy cards scale on hover

### Typography

- Thesis/Antithesis: `--font-sans`, `--font-size-md`
- Sources: `--font-mono`, `--font-size-xs`, `--text-muted`
- Strategy labels: `--font-weight-semibold`

---

## Constitutional Alignment

Contradiction resolution serves multiple principles:

| Principle | How Contradiction Resolution Serves It |
|-----------|----------------------------------------|
| **Ethical** | Surfaces hidden assumptions |
| **Composable** | Ensures beliefs can coexist |
| **Heterarchical** | No belief is sacred—all can be questioned |
| **Generative** | Synthesis creates new, better insights |

---

## Example: Full Contradiction Flow

```tsx
// 1. User creates new K-Block
const newKBlock = {
  content: "All UI components should be client-side only",
  layer: 4,  // Spec layer
};

// 2. System detects contradiction with existing K-Block
const existingKBlock = {
  content: "Server-side rendering improves SEO",
  layer: 4,
};

// 3. Super-additive loss detected
// loss(new + existing) > loss(new) + loss(existing)

// 4. Contradiction surfaced
<ContradictionBadge hasContradiction={true} severity="productive" />

// 5. User investigates
<ContradictionPolaroid
  thesis={newKBlock}
  antithesis={existingKBlock}
  contradictionType="productive"
/>

// 6. User resolves via CONTEXT strategy
<ResolutionPanel
  suggestedStrategy="context"
  onSelectStrategy={(strategy) => {
    // "Client-side for interactive components,
    //  SSR for static/SEO-critical pages"
    resolve(strategy, synthesis);
  }}
/>

// 7. Mark created, coherence restored
```

---

## The Deeper Meaning

Contradiction resolution embodies a key kgents insight:

**Coherence is not conformity.**

A coherent system doesn't eliminate tension—it **holds tension productively**.
The goal is not to have no contradictions, but to:

1. **Surface** contradictions (don't hide them)
2. **Understand** their nature (apparent vs genuine)
3. **Resolve** through synthesis when possible
4. **Evolve** when genuine contradiction demands change

---

*"Synthesis is always the goal. The third thing, better than either."*

Contradictions are where growth happens.
