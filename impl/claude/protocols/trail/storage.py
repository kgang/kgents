"""
Trail Storage Adapter: D-gent Universe integration for trail persistence.

Implements durable storage for trails with:
- Postgres/SQLite/Memory persistence via D-gent Universe
- Semantic search via embeddings (future)
- Version conflict detection
- Fork/merge lineage tracking

AGENTESE: self.trail.*

Teaching:
    gotcha: Universe doesn't support joinsâ€”we fetch trails and steps separately
            then merge in-memory. This is intentional for simplicity.

    gotcha: All data stored as frozen dataclasses (Trail, TrailStep, etc.)
            Universe handles serialization via Schema.

    gotcha: IDs are generated by the adapter, not by the dataclass.
            Dataclasses are pure data; ID generation is persistence concern.

See: docs/skills/metaphysical-fullstack.md
See: agents/d/universe/universe.py
See: agents/d/schemas/trail.py
"""

from __future__ import annotations

import hashlib
import json
import logging
import uuid
from dataclasses import dataclass, field, replace
from datetime import UTC, datetime
from typing import TYPE_CHECKING, Any, cast

from agents.d.datum import Datum
from agents.d.schemas.trail import (
    TRAIL_ANNOTATION_SCHEMA,
    TRAIL_COMMITMENT_SCHEMA,
    TRAIL_SCHEMA,
    TRAIL_STEP_SCHEMA,
    Trail,
    TrailAnnotation,
    TrailCommitment,
    TrailStep,
)
from agents.d.universe import Query, Schema, Universe, get_universe

if TYPE_CHECKING:
    from protocols.exploration.types import (
        Claim,
        Evidence as ExplorationEvidence,
        Observer,
        Trail as ExplorationTrail,
        TrailStep as ExplorationTrailStep,
    )

logger = logging.getLogger(__name__)


# =============================================================================
# ID Generation
# =============================================================================


def generate_trail_id() -> str:
    """Generate a unique trail ID."""
    return f"trail-{uuid.uuid4().hex[:12]}"


def generate_step_id() -> str:
    """Generate a unique step ID."""
    return f"step-{uuid.uuid4().hex[:12]}"


def generate_annotation_id() -> str:
    """Generate a unique annotation ID."""
    return f"ann-{uuid.uuid4().hex[:12]}"


def generate_commitment_id() -> str:
    """Generate a unique commitment ID."""
    return f"comm-{uuid.uuid4().hex[:12]}"


# =============================================================================
# Result Dataclasses
# =============================================================================


@dataclass
class TrailSaveResult:
    """Result of a trail save operation."""

    trail_id: str
    name: str
    step_count: int
    version: int
    timestamp: datetime
    datum_id: str | None = None


@dataclass
class TrailLoadResult:
    """Result of a trail load operation."""

    trail_id: str
    name: str
    steps: list[dict[str, Any]]
    annotations: dict[int, str]
    version: int
    created_at: datetime
    updated_at: datetime
    forked_from_id: str | None = None
    topics: list[str] = field(default_factory=list)


@dataclass
class TrailSearchResult:
    """Result of a semantic search operation."""

    trail_id: str
    name: str
    score: float
    step_count: int
    topics: list[str]


@dataclass
class VersionConflict:
    """Raised when trail version conflicts on update."""

    trail_id: str
    expected_version: int
    actual_version: int
    message: str = ""


@dataclass
class TrailStatus:
    """Trail storage health status."""

    total_trails: int
    total_steps: int
    active_trails: int
    forked_trails: int
    storage_backend: str


# =============================================================================
# Trail Storage Adapter
# =============================================================================


class TrailStorageAdapter:
    """
    D-gent Universe adapter for trail persistence.

    Uses Universe for storage with schema-aware serialization.
    All data stored as frozen dataclasses (Trail, TrailStep, etc.)

    Domain Semantics:
    - Trails are first-class knowledge artifacts
    - Steps are immutable once persisted (append-only)
    - Forks create independent lineages
    - Version conflicts are detected on update

    Example:
        storage = TrailStorageAdapter()

        result = await storage.save_trail(exploration_trail)
        loaded = await storage.load_trail(trail_id)
    """

    def __init__(
        self,
        universe: Universe | None = None,
    ) -> None:
        self.universe = universe or get_universe()
        self._ensure_schemas_registered()

    def _ensure_schemas_registered(self) -> None:
        """Register Trail schemas with Universe."""
        # Register all trail-related schemas
        # Cast to Schema[Any] to satisfy Protocol variance requirements
        self.universe.register_schema(cast(Schema[Any], TRAIL_SCHEMA))
        self.universe.register_schema(cast(Schema[Any], TRAIL_STEP_SCHEMA))
        self.universe.register_schema(cast(Schema[Any], TRAIL_ANNOTATION_SCHEMA))
        self.universe.register_schema(cast(Schema[Any], TRAIL_COMMITMENT_SCHEMA))

    # =========================================================================
    # Save Operations
    # =========================================================================

    async def save_trail(
        self,
        trail: "ExplorationTrail",
        observer: "Observer | None" = None,
    ) -> TrailSaveResult:
        """
        Save an exploration trail to Universe.

        AGENTESE: self.trail.save

        Persists:
        1. Trail metadata (name, description, observer)
        2. All steps (immutable, append-only)
        3. Annotations (mutable)

        Args:
            trail: The exploration Trail from types.py
            observer: Optional observer context

        Returns:
            TrailSaveResult with trail_id and storage details
        """
        # Use provided ID, or generate one if not provided
        trail_id = trail.id if trail.id and trail.id.startswith("trail-") else generate_trail_id()
        now = datetime.now(UTC)

        # Check if trail exists (for version tracking)
        existing = await self.universe.get(trail_id)
        version = 1
        if existing and isinstance(existing, Trail):
            version += 1  # Bump version on update

        # Create Trail dataclass
        trail_data = Trail(
            name=trail.name or "Untitled Trail",
            description="",  # ExplorationTrail doesn't have description field
            created_by_id=observer.id if observer else "unknown",
            is_active=True,
            forked_from_id=None,  # TODO: support forking
            parent_step_index=None,
        )

        # Store trail with custom ID
        trail_dict = TRAIL_SCHEMA.to_dict(trail_data)
        datum = Datum.create(
            content=json.dumps(trail_dict).encode("utf-8"),
            metadata={"schema": "trail.trail", "id": trail_id},
        )
        # Override datum ID with our trail_id
        datum = replace(datum, id=trail_id)
        await self.universe.store_datum(datum)

        # Save all steps
        for i, step in enumerate(trail.steps):
            await self._save_step(trail_id, i, step, observer)

        # Save annotations
        for step_index, annotation_text in trail.annotations.items():
            annotation_data = TrailAnnotation(
                trail_id=trail_id,
                step_index=step_index,
                content=annotation_text,
                author_id=observer.id if observer else None,
            )
            await self._save_annotation(annotation_data)

        return TrailSaveResult(
            trail_id=trail_id,
            name=trail_data.name,
            step_count=len(trail.steps),
            version=version,
            timestamp=now,
        )

    async def _save_step(
        self,
        trail_id: str,
        index: int,
        step: "ExplorationTrailStep",
        observer: "Observer | None",
    ) -> None:
        """
        Save a single step (internal helper).

        Args:
            trail_id: Parent trail ID
            index: Step index in trail
            step: ExplorationTrailStep from types.py
            observer: Optional observer context
        """
        step_id = generate_step_id()

        step_data = TrailStep(
            trail_id=trail_id,
            index=index,
            action=step.edge_taken or "navigate",
            content=step.node,
            reasoning=step.annotation,
            tool_name=None,
            tool_input={},
            tool_output=None,
        )

        # Store step with custom ID
        step_dict = TRAIL_STEP_SCHEMA.to_dict(step_data)
        datum = Datum.create(
            content=json.dumps(step_dict).encode("utf-8"),
            metadata={"schema": "trail.step", "trail_id": trail_id, "id": step_id},
        )
        # Override datum ID with our step_id
        datum = replace(datum, id=step_id)
        await self.universe.store_datum(datum)

    async def _save_annotation(self, annotation: TrailAnnotation) -> None:
        """
        Save a trail annotation (internal helper).

        Args:
            annotation: TrailAnnotation dataclass
        """
        ann_id = generate_annotation_id()

        # Store annotation with custom ID
        ann_dict = TRAIL_ANNOTATION_SCHEMA.to_dict(annotation)
        datum = Datum.create(
            content=json.dumps(ann_dict).encode("utf-8"),
            metadata={
                "schema": "trail.annotation",
                "trail_id": annotation.trail_id,
                "id": ann_id,
            },
        )
        # Override datum ID with our ann_id
        datum = replace(datum, id=ann_id)
        await self.universe.store_datum(datum)

    async def create_trail(
        self,
        name: str,
        steps: list[dict[str, Any]],
        topics: list[str] | None = None,
        observer: "Observer | None" = None,
    ) -> TrailSaveResult:
        """
        Create a new trail from raw dict data (for UI).

        AGENTESE: self.trail.create

        This is a simplified interface for the Trail Builder UI that accepts
        raw step dicts instead of ExplorationTrail objects.

        Args:
            name: Trail name
            steps: List of step dicts with {action, content, reasoning, ...}
            topics: Optional topic tags (ignored in current schema)
            observer: Who is creating the trail

        Returns:
            TrailSaveResult with trail_id and metadata
        """
        trail_id = generate_trail_id()
        now = datetime.now(UTC)

        # Create Trail dataclass
        trail_data = Trail(
            name=name,
            description="",
            created_by_id=observer.id if observer else "unknown",
            is_active=True,
            forked_from_id=None,
            parent_step_index=None,
        )

        # Store trail with custom ID
        trail_dict = TRAIL_SCHEMA.to_dict(trail_data)
        datum = Datum.create(
            content=json.dumps(trail_dict).encode("utf-8"),
            metadata={"schema": "trail.trail", "id": trail_id},
        )
        datum = replace(datum, id=trail_id)
        await self.universe.store_datum(datum)

        # Save steps
        for i, step_dict in enumerate(steps):
            step_id = generate_step_id()
            step_data = TrailStep(
                trail_id=trail_id,
                index=i,
                action=step_dict.get("action", step_dict.get("edge", "navigate")),
                content=step_dict.get("content", step_dict.get("source_path", "")),
                reasoning=step_dict.get("reasoning"),
                tool_name=step_dict.get("tool_name"),
                tool_input=step_dict.get("tool_input", {}),
                tool_output=step_dict.get("tool_output"),
            )

            step_datum_dict = TRAIL_STEP_SCHEMA.to_dict(step_data)
            step_datum = Datum.create(
                content=json.dumps(step_datum_dict).encode("utf-8"),
                metadata={"schema": "trail.step", "trail_id": trail_id, "id": step_id},
            )
            step_datum = replace(step_datum, id=step_id)
            await self.universe.store_datum(step_datum)

        return TrailSaveResult(
            trail_id=trail_id,
            name=name,
            step_count=len(steps),
            version=1,
            timestamp=now,
        )

    # =========================================================================
    # Load Operations
    # =========================================================================

    async def load_trail(self, trail_id: str) -> TrailLoadResult | None:
        """
        Load a trail from Universe.

        AGENTESE: self.trail.manifest

        Args:
            trail_id: The trail ID to load

        Returns:
            TrailLoadResult with all trail data, or None if not found
        """
        # Load trail
        trail_obj = await self.universe.get(trail_id)
        if trail_obj is None or not isinstance(trail_obj, Trail):
            return None

        # Load steps - query all data with trail_id in metadata
        # Since Universe doesn't support joins, we filter in-memory
        all_data = await self.universe.query(Query(limit=10000))

        steps_data = []
        annotations_dict = {}

        for obj in all_data:
            if isinstance(obj, TrailStep) and obj.trail_id == trail_id:
                steps_data.append(obj)
            elif isinstance(obj, TrailAnnotation) and obj.trail_id == trail_id:
                annotations_dict[obj.step_index] = obj.content

        # Sort steps by index
        steps_data.sort(key=lambda s: s.index)

        # Convert steps to dict format expected by TrailLoadResult
        steps_dicts = [
            {
                "index": s.index,
                "parent_index": None,  # Not in TrailStep schema
                "source_path": s.content,
                "edge": s.action,
                "destination_paths": [s.content],  # Simplified
                "reasoning": s.reasoning,
                "loop_status": "OK",  # Not in TrailStep schema
                "created_at": None,  # Not tracked in current schema
            }
            for s in steps_data
        ]

        # Note: created_at/updated_at not tracked in Trail schema v1
        # Using current time as fallback
        now = datetime.now(UTC)

        return TrailLoadResult(
            trail_id=trail_id,
            name=trail_obj.name,
            steps=steps_dicts,
            annotations=annotations_dict,
            version=1,  # Not tracked in Trail schema v1
            created_at=now,
            updated_at=now,
            forked_from_id=trail_obj.forked_from_id,
            topics=[],  # Not in Trail schema v1
        )

    async def list_trails(
        self,
        limit: int = 50,
        created_by_id: str | None = None,
        active_only: bool = True,
    ) -> list[TrailLoadResult]:
        """
        List trails with optional filters.

        AGENTESE: self.trail.list

        Args:
            limit: Maximum trails to return (default 50)
            created_by_id: Filter by creator
            active_only: Only return active trails (default True)

        Returns:
            List of TrailLoadResult objects, newest first

        Teaching:
            gotcha: Universe doesn't have perfect indexing yet, so we query
                    by prefix ("trail-") and filter in-memory. This works
                    because we use custom IDs with the trail- prefix.

            gotcha: Without timestamp tracking in Universe, we can't sort by
                    creation time. This is a known limitation of the current
                    Trail schema v1.
        """
        # Query trails by prefix and schema
        all_trails_data = await self.universe.query(
            Query(prefix="trail-", schema="trail.trail", limit=limit * 2)
        )

        # We need IDs to load trails, but Universe doesn't return them
        # For now, return empty list - this needs Universe enhancement
        logger.warning(
            "list_trails not fully implemented - Universe needs to return datum IDs with objects"
        )
        return []

    # =========================================================================
    # Stubs for Non-Essential Methods
    # =========================================================================

    async def fork_trail(
        self,
        trail_id: str,
        new_name: str,
        fork_point: int | None = None,
        observer: "Observer | None" = None,
    ) -> TrailSaveResult:
        """Fork a trail (stub - not implemented with Universe yet)."""
        raise NotImplementedError("fork_trail not implemented with Universe yet")

    async def search_semantic(
        self,
        query_embedding: list[float],
        limit: int = 10,
    ) -> list[TrailSearchResult]:
        """Search trails by semantic similarity (stub - not implemented with Universe yet)."""
        raise NotImplementedError("search_semantic not implemented with Universe yet")

    async def update_step_embedding(
        self,
        step_id: str,
        embedding: list[float],
    ) -> bool:
        """Update embedding for a step (stub - not implemented with Universe yet)."""
        raise NotImplementedError("update_step_embedding not implemented with Universe yet")

    async def backfill_embeddings(
        self,
        embedder_fn: Any,
        limit: int = 100,
    ) -> int:
        """Backfill embeddings (stub - not implemented with Universe yet)."""
        raise NotImplementedError("backfill_embeddings not implemented with Universe yet")

    async def search_by_topics(
        self,
        topics: list[str],
        limit: int = 20,
    ) -> list[TrailLoadResult]:
        """Search trails by topic (stub - not implemented with Universe yet)."""
        raise NotImplementedError("search_by_topics not implemented with Universe yet")

    async def save_evidence(
        self,
        trail_id: str,
        evidence: "ExplorationEvidence",
        source_step_index: int | None = None,
    ) -> str:
        """Save evidence (stub - not implemented with Universe yet)."""
        raise NotImplementedError("save_evidence not implemented with Universe yet")

    async def save_commitment(
        self,
        trail_id: str,
        claim: "Claim",
        level: str,
        evidence_ids: list[str],
        observer: "Observer | None" = None,
    ) -> str:
        """Save commitment (stub - not implemented with Universe yet)."""
        raise NotImplementedError("save_commitment not implemented with Universe yet")

    async def manifest(self) -> TrailStatus:
        """
        Get trail storage health status.

        AGENTESE: self.trail.status

        Returns:
            TrailStatus with counts and health metrics
        """
        # Get universe stats
        stats = await self.universe.stats()

        # Count trails and steps by querying
        all_data = await self.universe.query(Query(limit=10000))

        total_trails = sum(1 for obj in all_data if isinstance(obj, Trail))
        active_trails = sum(1 for obj in all_data if isinstance(obj, Trail) and obj.is_active)
        forked_trails = sum(
            1 for obj in all_data if isinstance(obj, Trail) and obj.forked_from_id is not None
        )
        total_steps = sum(1 for obj in all_data if isinstance(obj, TrailStep))

        return TrailStatus(
            total_trails=total_trails,
            total_steps=total_steps,
            active_trails=active_trails,
            forked_trails=forked_trails,
            storage_backend=stats.backend,
        )


__all__ = [
    "TrailStorageAdapter",
    "TrailSaveResult",
    "TrailLoadResult",
    "TrailSearchResult",
    "TrailStatus",
    "VersionConflict",
    "generate_trail_id",
    "generate_step_id",
    "generate_annotation_id",
    "generate_commitment_id",
]
