"""
Tests for Wave 3 Phase 2: Dynamic Sections

Tests for:
- ForestSection: Reading from plans/_forest.md
- ContextSection: Git status, phase, session info
- GitSource: Git repository context

These tests use real filesystem and git operations where possible,
with fixtures for reproducibility.
"""

from __future__ import annotations

import asyncio
import tempfile
from datetime import datetime
from pathlib import Path

import pytest
from protocols.prompt.compiler import CompilationContext
from protocols.prompt.section_base import NPhase, Section
from protocols.prompt.sections.context import (
    CombinedContextSource,
    ContextSectionCompiler,
    GitContextSectionCompiler,
    PhaseSource,
    SessionSource,
    create_context_soft_section,
)
from protocols.prompt.sections.forest import (
    ForestSectionCompiler,
    ForestSource,
    create_forest_soft_section,
)
from protocols.prompt.sources.git_source import GitBranchSource, GitSource

# =============================================================================
# Fixtures
# =============================================================================


@pytest.fixture
def tmp_project(tmp_path: Path) -> Path:
    """Create a temporary project structure."""
    # Create directories
    (tmp_path / "plans").mkdir()
    (tmp_path / "spec").mkdir()
    (tmp_path / "docs").mkdir()

    return tmp_path


@pytest.fixture
def forest_file(tmp_project: Path) -> Path:
    """Create a sample _forest.md file."""
    forest_content = """# Forest Health: 2025-12-16

> Generated by self.forest.manifest

---

## Summary

- **Total Plans**: 59
- **Active**: 33
- **Dormant**: 0
- **Blocked**: 0
- **Complete**: 18
- **Average Progress**: 21%

---

## Active Trees

| Plan | Progress | Last Touched | Status | Notes |
|------|----------|--------------|--------|-------|
| plans/evergreen-prompt | 50% | 2025-12-16 | active | Wave 3 in progress |
| plans/agent-town/unified | 30% | 2025-12-15 | active | Phase 9 pending |
| plans/core-apps/brain | 10% | 2025-12-14 | active | Holographic brain |
| plans/meta | 0% | 2025-12-13 | active | Forest compliance |
| plans/old-plan | 5% | 2025-12-01 | active | Older plan |

---

## Complete Trees

| Plan | Completed | Notes |
|------|-----------|-------|
| plans/elastic-primitives | 2025-12-16 | Done |
"""
    forest_path = tmp_project / "plans" / "_forest.md"
    forest_path.write_text(forest_content)
    return forest_path


@pytest.fixture
def context_with_forest(tmp_project: Path, forest_file: Path) -> CompilationContext:
    """Create a compilation context with forest path."""
    return CompilationContext(
        project_root=tmp_project,
        forest_path=tmp_project / "plans",
    )


@pytest.fixture
def context_with_focus(tmp_project: Path, forest_file: Path) -> CompilationContext:
    """Create a context with focus intent."""
    return CompilationContext(
        project_root=tmp_project,
        forest_path=tmp_project / "plans",
        focus_intent="evergreen",
    )


@pytest.fixture
def context_with_phase(tmp_project: Path) -> CompilationContext:
    """Create a context with a current phase."""
    return CompilationContext(
        project_root=tmp_project,
        current_phase=NPhase.IMPLEMENT,
    )


@pytest.fixture
def git_repo(tmp_path: Path) -> Path:
    """Create a temporary git repository."""
    import subprocess

    repo_path = tmp_path / "git_repo"
    repo_path.mkdir()

    # Initialize git repo
    subprocess.run(["git", "init"], cwd=repo_path, check=True, capture_output=True)
    subprocess.run(
        ["git", "config", "user.email", "test@example.com"],
        cwd=repo_path,
        check=True,
        capture_output=True,
    )
    subprocess.run(
        ["git", "config", "user.name", "Test User"],
        cwd=repo_path,
        check=True,
        capture_output=True,
    )

    # Create initial commit
    readme = repo_path / "README.md"
    readme.write_text("# Test Repo")
    subprocess.run(["git", "add", "."], cwd=repo_path, check=True, capture_output=True)
    subprocess.run(
        ["git", "commit", "-m", "Initial commit"],
        cwd=repo_path,
        check=True,
        capture_output=True,
    )

    return repo_path


@pytest.fixture
def context_with_git(git_repo: Path) -> CompilationContext:
    """Create a context with a git repository."""
    return CompilationContext(project_root=git_repo)


# =============================================================================
# Forest Source Tests
# =============================================================================


class TestForestSource:
    """Tests for ForestSource."""

    @pytest.mark.asyncio
    async def test_fetch_reads_forest_file(
        self, context_with_forest: CompilationContext
    ) -> None:
        """ForestSource reads and parses _forest.md."""
        source = ForestSource()
        result = await source.fetch(context_with_forest)

        assert result.success
        assert result.content is not None
        assert "Forest Protocol" in result.content
        assert len(result.reasoning_trace) > 0

    @pytest.mark.asyncio
    async def test_extracts_summary(
        self, context_with_forest: CompilationContext
    ) -> None:
        """ForestSource extracts summary statistics."""
        source = ForestSource()
        result = await source.fetch(context_with_forest)

        assert result.success
        assert "33 active" in result.content
        assert "18 complete" in result.content

    @pytest.mark.asyncio
    async def test_extracts_active_trees(
        self, context_with_forest: CompilationContext
    ) -> None:
        """ForestSource extracts active trees table."""
        source = ForestSource()
        result = await source.fetch(context_with_forest)

        assert result.success
        assert "evergreen-prompt" in result.content
        assert "50%" in result.content

    @pytest.mark.asyncio
    async def test_limits_active_trees(
        self, context_with_forest: CompilationContext
    ) -> None:
        """ForestSource limits to max_active_trees."""
        source = ForestSource(max_active_trees=3)
        result = await source.fetch(context_with_forest)

        assert result.success
        # Should have top 3 most recently touched
        # The table header row + 3 data rows
        table_rows = [
            line
            for line in result.content.splitlines()
            if line.startswith("|") and "---" not in line and "Plan" not in line
        ]
        assert len(table_rows) <= 3

    @pytest.mark.asyncio
    async def test_focus_intent_filters_trees(
        self, context_with_focus: CompilationContext
    ) -> None:
        """ForestSource filters by focus intent when provided."""
        source = ForestSource()
        result = await source.fetch(context_with_focus)

        assert result.success
        # Should prioritize "evergreen" plans
        assert "evergreen" in result.content.lower()

    @pytest.mark.asyncio
    async def test_missing_forest_file(self, tmp_project: Path) -> None:
        """ForestSource fails gracefully when _forest.md missing."""
        context = CompilationContext(
            project_root=tmp_project,
            forest_path=tmp_project / "plans",  # No _forest.md
        )
        source = ForestSource()
        result = await source.fetch(context)

        assert not result.success
        assert "not found" in " ".join(result.reasoning_trace).lower()

    @pytest.mark.asyncio
    async def test_rigidity_is_soft(
        self, context_with_forest: CompilationContext
    ) -> None:
        """ForestSource has appropriate soft rigidity."""
        source = ForestSource()
        result = await source.fetch(context_with_forest)

        assert source.rigidity == 0.4  # Soft section
        assert result.rigidity == 0.4


# =============================================================================
# Forest Section Compiler Tests
# =============================================================================


class TestForestSectionCompiler:
    """Tests for ForestSectionCompiler."""

    def test_compile_produces_section(
        self, context_with_forest: CompilationContext
    ) -> None:
        """Compiler produces valid Section."""
        compiler = ForestSectionCompiler()
        section = compiler.compile(context_with_forest)

        assert isinstance(section, Section)
        assert section.name == "forest"
        assert "Forest Protocol" in section.content

    def test_compile_includes_reasoning_trace(
        self, context_with_forest: CompilationContext
    ) -> None:
        """Compiled section includes reasoning trace."""
        compiler = ForestSectionCompiler()
        section = compiler.compile(context_with_forest)

        assert len(section.reasoning_trace) > 0
        # Should include crystallization steps
        assert any("Crystallizing" in t for t in section.reasoning_trace)

    def test_fallback_when_no_forest(self, tmp_project: Path) -> None:
        """Compiler uses fallback when forest unavailable."""
        context = CompilationContext(
            project_root=tmp_project,
            forest_path=tmp_project / "plans",
        )
        compiler = ForestSectionCompiler()
        section = compiler.compile(context)

        assert "unavailable" in section.content.lower()

    def test_properties(self) -> None:
        """Compiler properties are correctly set."""
        compiler = ForestSectionCompiler()

        assert compiler.name == "forest"
        assert compiler.required is False  # Optional section
        assert len(compiler.phases) == 0  # All phases


# =============================================================================
# Phase Source Tests
# =============================================================================


class TestPhaseSource:
    """Tests for PhaseSource."""

    @pytest.mark.asyncio
    async def test_fetch_with_phase(
        self, context_with_phase: CompilationContext
    ) -> None:
        """PhaseSource returns phase info when set."""
        source = PhaseSource()
        result = await source.fetch(context_with_phase)

        assert result.success
        assert "Implement" in result.content
        assert "production code" in result.content.lower()

    @pytest.mark.asyncio
    async def test_fetch_without_phase(self, tmp_project: Path) -> None:
        """PhaseSource returns empty when no phase set."""
        context = CompilationContext(project_root=tmp_project)
        source = PhaseSource()
        result = await source.fetch(context)

        assert not result.success
        assert "No phase set" in " ".join(result.reasoning_trace)

    @pytest.mark.asyncio
    async def test_all_phases_have_descriptions(self, tmp_project: Path) -> None:
        """All NPhase values produce descriptions."""
        for phase in NPhase:
            context = CompilationContext(
                project_root=tmp_project,
                current_phase=phase,
            )
            source = PhaseSource()
            result = await source.fetch(context)

            assert result.success
            assert result.content is not None
            assert phase.name.replace("_", " ").title() in result.content


# =============================================================================
# Session Source Tests
# =============================================================================


class TestSessionSource:
    """Tests for SessionSource."""

    @pytest.mark.asyncio
    async def test_fetch_produces_timestamp(self, tmp_project: Path) -> None:
        """SessionSource includes timestamp."""
        context = CompilationContext(project_root=tmp_project)
        source = SessionSource()
        result = await source.fetch(context)

        assert result.success
        # Should include date in YYYY-MM-DD format
        today = datetime.now().strftime("%Y-%m-%d")
        assert today in result.content

    @pytest.mark.asyncio
    async def test_includes_focus_intent(self, tmp_project: Path) -> None:
        """SessionSource includes focus intent when set."""
        context = CompilationContext(
            project_root=tmp_project,
            focus_intent="testing",
        )
        source = SessionSource()
        result = await source.fetch(context)

        assert "testing" in result.content
        assert "Focus" in result.content

    @pytest.mark.asyncio
    async def test_includes_pressure_budget(self, tmp_project: Path) -> None:
        """SessionSource includes pressure budget when not default."""
        context = CompilationContext(
            project_root=tmp_project,
            pressure_budget=0.5,
        )
        source = SessionSource()
        result = await source.fetch(context)

        assert "50%" in result.content
        assert "Budget" in result.content

    @pytest.mark.asyncio
    async def test_soft_rigidity(self, tmp_project: Path) -> None:
        """SessionSource has soft rigidity."""
        source = SessionSource()
        assert source.rigidity == 0.3


# =============================================================================
# Git Source Tests
# =============================================================================


class TestGitSource:
    """Tests for GitSource."""

    @pytest.mark.asyncio
    async def test_fetch_in_git_repo(
        self, context_with_git: CompilationContext
    ) -> None:
        """GitSource reads git status in a repository."""
        source = GitSource()
        result = await source.fetch(context_with_git)

        assert result.success
        assert "Git Context" in result.content
        # Should show branch (main or master depending on git version)
        assert "Branch" in result.content

    @pytest.mark.asyncio
    async def test_fetch_not_git_repo(self, tmp_project: Path) -> None:
        """GitSource fails gracefully outside git repo."""
        context = CompilationContext(project_root=tmp_project)
        source = GitSource()
        result = await source.fetch(context)

        assert not result.success
        assert "Not a git repository" in " ".join(result.reasoning_trace)

    @pytest.mark.asyncio
    async def test_shows_modified_files(
        self, context_with_git: CompilationContext
    ) -> None:
        """GitSource shows modified files."""
        # Create a modified file
        readme = context_with_git.project_root / "README.md"
        readme.write_text("# Modified")

        source = GitSource()
        result = await source.fetch(context_with_git)

        assert result.success
        assert "Modified" in result.content or "Working Tree" in result.content

    @pytest.mark.asyncio
    async def test_shows_recent_commits(
        self, context_with_git: CompilationContext
    ) -> None:
        """GitSource shows recent commits."""
        source = GitSource()
        result = await source.fetch(context_with_git)

        assert result.success
        assert "Recent Commits" in result.content
        assert "Initial commit" in result.content


class TestGitBranchSource:
    """Tests for GitBranchSource."""

    @pytest.mark.asyncio
    async def test_fetch_branch_name(
        self, context_with_git: CompilationContext
    ) -> None:
        """GitBranchSource returns just the branch name."""
        source = GitBranchSource()
        result = await source.fetch(context_with_git)

        assert result.success
        assert "Branch" in result.content
        # Should not include full git status
        assert "Recent Commits" not in result.content

    @pytest.mark.asyncio
    async def test_higher_rigidity(self, context_with_git: CompilationContext) -> None:
        """GitBranchSource has higher rigidity than full GitSource."""
        branch_source = GitBranchSource()
        full_source = GitSource()

        assert branch_source.rigidity > full_source.rigidity


# =============================================================================
# Context Section Compiler Tests
# =============================================================================


class TestContextSectionCompiler:
    """Tests for ContextSectionCompiler."""

    def test_compile_produces_section(
        self, context_with_git: CompilationContext
    ) -> None:
        """Compiler produces valid Section with context."""
        compiler = ContextSectionCompiler()
        section = compiler.compile(context_with_git)

        assert isinstance(section, Section)
        assert section.name == "context"

    def test_compile_with_phase(self, context_with_git: CompilationContext) -> None:
        """Compiler includes phase when set in a git repo."""
        # Update the context to include a phase
        context = CompilationContext(
            project_root=context_with_git.project_root,
            current_phase=NPhase.RESEARCH,
        )
        compiler = ContextSectionCompiler()
        section = compiler.compile(context)

        # Should include branch info and/or phase info
        # Since we're in a git repo, it should show something
        assert "Session Context" in section.content
        # The phase may be shown via PhaseSource
        # Check reasoning trace shows phase was tried
        assert len(section.reasoning_trace) > 0

    def test_properties(self) -> None:
        """Compiler properties are correctly set."""
        compiler = ContextSectionCompiler()

        assert compiler.name == "context"
        assert compiler.required is False
        assert len(compiler.phases) == 0


class TestGitContextSectionCompiler:
    """Tests for GitContextSectionCompiler."""

    def test_compile_produces_detailed_git(
        self, context_with_git: CompilationContext
    ) -> None:
        """Compiler produces detailed git context."""
        compiler = GitContextSectionCompiler()
        section = compiler.compile(context_with_git)

        assert isinstance(section, Section)
        assert section.name == "git_context"
        assert "Git Context" in section.content

    def test_fallback_outside_git(self, tmp_project: Path) -> None:
        """Compiler uses fallback outside git repo."""
        context = CompilationContext(project_root=tmp_project)
        compiler = GitContextSectionCompiler()
        section = compiler.compile(context)

        assert "Not in a git repository" in section.content


# =============================================================================
# Combined Context Source Tests
# =============================================================================


class TestCombinedContextSource:
    """Tests for CombinedContextSource."""

    @pytest.mark.asyncio
    async def test_combines_multiple_sources(
        self, context_with_git: CompilationContext
    ) -> None:
        """CombinedContextSource combines git, phase, and session."""
        context = CompilationContext(
            project_root=context_with_git.project_root,
            current_phase=NPhase.DEVELOP,
        )
        source = CombinedContextSource()
        result = await source.fetch(context)

        assert result.success
        assert "Session Context" in result.content
        # Should include multiple components
        assert "Branch" in result.content or "Session" in result.content

    @pytest.mark.asyncio
    async def test_selective_inclusion(self, tmp_project: Path) -> None:
        """CombinedContextSource respects include flags."""
        context = CompilationContext(project_root=tmp_project)
        source = CombinedContextSource(
            include_git=False,
            include_phase=False,
            include_session=True,
        )
        result = await source.fetch(context)

        assert result.success
        # Only session should be included
        assert "Session" in result.content
        assert "Branch" not in result.content


# =============================================================================
# Integration Tests
# =============================================================================


class TestDynamicSectionsIntegration:
    """Integration tests for dynamic sections."""

    @pytest.mark.asyncio
    async def test_create_forest_soft_section(
        self, context_with_forest: CompilationContext
    ) -> None:
        """create_forest_soft_section creates valid SoftSection."""
        soft = create_forest_soft_section()

        # Crystallize with context that HAS forest file
        result = await soft.crystallize(context_with_forest)

        assert result.section.name == "forest"
        # When forest file exists, ForestSource succeeds with rigidity 0.4
        # But since sources include TemplateSource first (higher priority),
        # we need to verify based on what actually happens
        # The ForestSource has FILE priority (80), TemplateSource has TEMPLATE (100)
        # So TemplateSource is tried first! Let's verify the behavior.
        # Actually the test should check content, not rigidity in this case
        assert "Forest Protocol" in result.section.content

    @pytest.mark.asyncio
    async def test_create_context_soft_section(
        self, context_with_git: CompilationContext
    ) -> None:
        """create_context_soft_section creates valid SoftSection with git context."""
        soft = create_context_soft_section()

        result = await soft.crystallize(context_with_git)

        assert result.section.name == "context"
        # In a git repo, should have some context
        assert "Session Context" in result.section.content

    @pytest.mark.asyncio
    async def test_reasoning_trace_accumulation(
        self, context_with_forest: CompilationContext
    ) -> None:
        """Reasoning traces accumulate through crystallization."""
        # Use ForestSectionCompiler which correctly orders sources
        compiler = ForestSectionCompiler()
        soft = compiler._create_soft_section()

        result = await soft.crystallize(context_with_forest)

        # Should have traces from crystallization
        traces = result.reasoning_trace
        assert len(traces) > 2
        assert any("Crystallizing" in t for t in traces)
        # Should try ForestSource first (it's added before TemplateSource)
        assert any("forest" in t.lower() for t in traces)


# =============================================================================
# Category Law Tests
# =============================================================================


class TestCategoryLaws:
    """Tests for category laws on dynamic sections."""

    @pytest.mark.asyncio
    async def test_crystallization_idempotence(
        self, context_with_forest: CompilationContext
    ) -> None:
        """
        Crystallization is idempotent.

        crystallize(from_hard(crystallize(s))) == crystallize(s)
        """
        from protocols.prompt.soft_section import SoftSection

        soft = create_forest_soft_section()

        # First crystallization
        result1 = await soft.crystallize(context_with_forest)

        # Convert back to SoftSection and crystallize again
        soft2 = SoftSection.from_hard(result1.section)
        result2 = await soft2.crystallize(context_with_forest)

        # Content should be identical
        assert result1.section.content == result2.section.content

    def test_compilation_determinism(
        self, context_with_forest: CompilationContext
    ) -> None:
        """Same context produces same output."""
        compiler = ForestSectionCompiler()

        section1 = compiler.compile(context_with_forest)
        section2 = compiler.compile(context_with_forest)

        assert section1.content == section2.content
        assert section1.name == section2.name

    @pytest.mark.asyncio
    async def test_source_ordering(
        self, context_with_forest: CompilationContext
    ) -> None:
        """Sources are tried in priority order."""
        from protocols.prompt.soft_section import SoftSection
        from protocols.prompt.sources.base import TemplateSource

        # Create SoftSection with multiple sources
        # TemplateSource has TEMPLATE=100 priority (highest)
        # ForestSource has FILE=80 priority
        # So TemplateSource is tried first
        soft = SoftSection(
            name="test",
            sources=[
                TemplateSource(name="template", template="template content"),
                ForestSource(),
            ],
        )

        result = await soft.crystallize(context_with_forest)

        # TemplateSource has higher priority, so it should win
        assert result.section.content == "template content"
        assert result.effective_rigidity == 1.0  # Template rigidity

        # Now test with ForestSource having explicit higher priority
        from protocols.prompt.sources.base import SourcePriority

        soft2 = SoftSection(
            name="test2",
            sources=[
                ForestSource(priority=SourcePriority.TEMPLATE),  # Override to highest
                TemplateSource(name="template", template="template content"),
            ],
        )

        result2 = await soft2.crystallize(context_with_forest)

        # ForestSource should now win
        assert "Forest Protocol" in result2.section.content
        assert result2.effective_rigidity < 1.0


# =============================================================================
# Edge Cases
# =============================================================================


class TestEdgeCases:
    """Test edge cases and error handling."""

    def test_empty_forest_file(self, tmp_project: Path) -> None:
        """Handles empty _forest.md gracefully."""
        forest_path = tmp_project / "plans" / "_forest.md"
        forest_path.write_text("")

        context = CompilationContext(
            project_root=tmp_project,
            forest_path=tmp_project / "plans",
        )
        compiler = ForestSectionCompiler()
        section = compiler.compile(context)

        # Should use fallback or produce minimal content
        assert section.content  # Should not be empty

    def test_malformed_forest_file(self, tmp_project: Path) -> None:
        """Handles malformed _forest.md gracefully."""
        forest_path = tmp_project / "plans" / "_forest.md"
        forest_path.write_text("Not valid markdown table format\n\nJust text.")

        context = CompilationContext(
            project_root=tmp_project,
            forest_path=tmp_project / "plans",
        )
        compiler = ForestSectionCompiler()
        section = compiler.compile(context)

        # Should not crash, produce some content
        assert section.content

    def test_no_active_trees(self, tmp_project: Path) -> None:
        """Handles forest with no active trees."""
        forest_content = """# Forest Health

## Summary
- **Active**: 0
- **Complete**: 10

## Active Trees

| Plan | Progress | Last Touched | Status | Notes |
|------|----------|--------------|--------|-------|

## Complete Trees
| Plan | Completed | Notes |
"""
        forest_path = tmp_project / "plans" / "_forest.md"
        forest_path.write_text(forest_content)

        context = CompilationContext(
            project_root=tmp_project,
            forest_path=tmp_project / "plans",
        )
        compiler = ForestSectionCompiler()
        section = compiler.compile(context)

        assert section.content
        # Should handle empty table gracefully
