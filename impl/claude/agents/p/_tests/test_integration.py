"""
Integration tests for P-gents protocol adapters.

Tests E-gent, B-gent, and F-gent parsers conforming to P-gents Parser[A].
"""

import pytest


class TestEgentIntegration:
    """Test E-gent parser integration."""

    @pytest.mark.skip(reason="agents.e.parser.p_integration not yet implemented")
    def test_code_parser_structured_format(self):
        """Test E-gent code parser with structured format."""
        from agents.e.parser.p_integration import code_parser

        parser = code_parser()

        response = """
## METADATA
```json
{"description": "Test module"}
```

## CODE
```python
def hello():
    return "world"
```
"""
        result = parser.parse(response)

        assert result.success
        assert result.value is not None
        assert "def hello():" in result.value.code
        assert result.confidence > 0.5
        assert "e-gent" in result.strategy

    @pytest.mark.skip(reason="agents.e.parser.p_integration not yet implemented")
    def test_code_parser_pure_code_block(self):
        """Test E-gent code parser with pure code block."""
        from agents.e.parser.p_integration import code_parser

        parser = code_parser()

        response = """
```python
def test():
    pass
```
"""
        result = parser.parse(response)

        assert result.success
        assert result.value is not None
        assert "def test():" in result.value.code

    @pytest.mark.skip(reason="agents.e.parser.p_integration not yet implemented")
    def test_code_parser_failure(self):
        """Test E-gent code parser with invalid input."""
        from agents.e.parser.p_integration import code_parser

        parser = code_parser()

        response = "No code here, just text"
        result = parser.parse(response)

        assert not result.success
        assert result.error is not None
        assert result.confidence == 0.0


class TestBgentIntegration:
    """Test B-gent hypothesis parser integration."""

    def test_hypothesis_parser_complete(self):
        """Test B-gent hypothesis parser with complete response."""
        from agents.b.p_integration import hypothesis_parser

        parser = hypothesis_parser()

        response = """
HYPOTHESES:
1. STATEMENT: The system is overloaded
   CONFIDENCE: 0.8
   NOVELTY: exploratory
   FALSIFIABLE_BY:
   - System load drops below 50%
   SUPPORTS_OBSERVATIONS: 0, 1
   ASSUMPTIONS:
   - Load is measured correctly

REASONING_CHAIN:
1. High response times observed
2. CPU usage at 95%

SUGGESTED_TESTS:
- Monitor load for 24 hours
"""
        result = parser.parse(response)

        assert result.success
        assert result.value is not None
        assert len(result.value.hypotheses) == 1
        assert result.value.hypotheses[0].statement == "The system is overloaded"
        assert result.value.hypotheses[0].confidence == 0.8
        assert len(result.value.reasoning_chain) == 2
        assert len(result.value.suggested_tests) == 1
        assert result.confidence > 0.5
        assert "b-gent" in result.strategy

    def test_hypothesis_parser_failure(self):
        """Test B-gent hypothesis parser with invalid input."""
        from agents.b.p_integration import hypothesis_parser

        parser = hypothesis_parser()

        response = "Not a hypothesis response"
        result = parser.parse(response)

        assert not result.success
        assert result.error is not None
        assert result.confidence == 0.0


class TestFgentIntegration:
    """Test F-gent artifact parser integration."""

    def test_artifact_parser_complete(self):
        """Test F-gent artifact parser with complete .alo.md."""
        from agents.f.p_integration import artifact_parser

        parser = artifact_parser()

        response = """---
id: "test_agent_v1"
type: "f_gent_artifact"
version: "1.0.0"
created_at: "2025-01-01T00:00:00Z"
created_by: "f-gent"
parent_version: null
status: "experimental"
hash: "abc123"
tags: []
dependencies: []
---

# 1. THE INTENT (Human-Editable)

> *This section contains the original natural language intent.*
> *Humans can edit this section to trigger re-forging.*

**Purpose**: Test agent for integration tests

**Behavior**:
- Does something useful

---

# 2. THE CONTRACT (Machine-Verified)

> *This section defines the agent's interface and guarantees.*
> *Generated by F-gent during Forge Loop Phase 2.*

## Type Signature

**Agent Name**: `TestAgent`
**Input Type**: `str`
**Output Type**: `str`

---

# 4. THE IMPLEMENTATION

```python
def invoke(input: str) -> str:
    return input.upper()
```
"""
        result = parser.parse(response)

        assert result.success
        assert result.value is not None
        assert result.value.metadata.id == "test_agent_v1"
        assert str(result.value.metadata.version) == "1.0.0"
        assert result.value.contract.agent_name == "TestAgent"
        assert result.value.contract.input_type == "str"
        assert result.value.contract.output_type == "str"
        assert "def invoke" in result.value.source_code.code
        assert result.confidence > 0.5
        assert "f-gent" in result.strategy

    def test_artifact_parser_failure(self):
        """Test F-gent artifact parser with invalid input."""
        from agents.f.p_integration import artifact_parser

        parser = artifact_parser()

        response = "Not an artifact"
        result = parser.parse(response)

        assert not result.success
        assert result.error is not None
        assert result.confidence == 0.0


class TestComposition:
    """Test composition of different parsers."""

    @pytest.mark.skip(reason="agents.e.parser.p_integration not yet implemented")
    def test_fallback_composition(self):
        """Test fallback composition of E-gent and B-gent parsers."""
        from agents.e.parser.p_integration import code_parser
        from agents.b.p_integration import hypothesis_parser

        # This won't actually work type-wise since they parse to different types,
        # but it demonstrates the composition interface
        # In practice, you'd use type-compatible parsers or use Any

        # Just verify the parsers can be constructed and used
        e_parser = code_parser()
        b_parser = hypothesis_parser()

        assert e_parser is not None
        assert b_parser is not None
