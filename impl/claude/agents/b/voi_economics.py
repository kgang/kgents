"""
Value of Information (VoI): Economics of Observation

Implements Part III of spec/b-gents/banker.md:
- EpistemicCapital: Knowledge-about-the-system currency
- VoILedger: Observation economics tracking
- VoIOptimizer: Observation budget allocation
- AdaptiveObserver: Dynamic observation frequency
- UnifiedValueAccounting: UVP + VoI integration

The VoI framework addresses the economic puzzle of observation:
How do we value work that produces no artifacts, only knowledge?

Standard UVP fails for observation because:
- O-gent consumes Gas (tokens for LLM-as-Judge checks)
- But produces no direct Impact (no code, no tests, no artifacts)
- Naive RoC calculation: 0 / Gas = 0 → "Bankruptcy!"

VoI recognizes that observation prevents catastrophic failures.
The value isn't in what it produces, but in what it *prevents*.

VoI = E[Value with Information] - E[Value without Information]
    = P(disaster) × Cost(disaster) × P(detection | observation)
"""

from __future__ import annotations

import asyncio
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from typing import Any, Callable, Optional

from .metered_functor import Gas
from .value_ledger import ValueLedger

# =============================================================================
# Observation Depth and Finding Types
# =============================================================================


class ObservationDepth(Enum):
    """
    Depth levels for observation.

    Cost increases with depth, but so does detection probability.
    """

    TELEMETRY_ONLY = "telemetry_only"  # Just metrics (cheapest)
    SEMANTIC_SPOT = "semantic_spot"  # Sample semantic checks
    SEMANTIC_FULL = "semantic_full"  # Full semantic analysis (most expensive)
    AXIOLOGICAL = "axiological"  # Full economic audit


class FindingType(Enum):
    """Type of observation finding."""

    ANOMALY_DETECTED = "anomaly_detected"  # Issue found
    HEALTH_CONFIRMED = "health_confirmed"  # All good
    FALSE_POSITIVE = "false_positive"  # False alarm
    INCONCLUSIVE = "inconclusive"  # Could not determine


@dataclass
class ObservationFinding:
    """Result of an observation."""

    type: FindingType
    confidence: float = 0.5  # 0.0 to 1.0
    anomaly: Optional[str] = None  # Description if anomaly detected
    details: dict[str, Any] = field(default_factory=dict)
    timestamp: datetime = field(default_factory=datetime.now)


# =============================================================================
# Epistemic Capital
# =============================================================================


# Cost constants
ALERT_FATIGUE_COST = 0.5  # Cost of a false positive (attention waste)
CONFIRMATION_VALUE = 0.1  # Base value of confirming system health


@dataclass
class EpistemicCapital:
    """
    The value of knowledge-about-the-system.

    Unit: Bits of decision-relevant information
    Physics: Generated by observation, consumed by decisions
    Role: "Insurance" - prevents catastrophic losses

    This is the third currency alongside Gas and Impact.
    """

    observations: int = 0  # Number of observations made
    anomalies_detected: int = 0  # Issues caught before propagation
    disasters_prevented: float = 0.0  # Estimated Impact saved
    false_positives: int = 0  # Unnecessary alerts (negative value)
    confirmations: int = 0  # Health confirmations

    # Running totals
    total_voi_generated: float = 0.0  # Total Value of Information
    total_gas_consumed: float = 0.0  # Total Gas spent on observation

    @property
    def net_epistemic_value(self) -> float:
        """
        Net value of observation.

        Positive = observation is paying for itself
        Negative = over-observing (noise > signal)
        """
        value_saved = self.disasters_prevented
        confirmation_value = self.confirmations * CONFIRMATION_VALUE
        noise_cost = self.false_positives * ALERT_FATIGUE_COST
        return value_saved + confirmation_value - noise_cost

    @property
    def signal_to_noise_ratio(self) -> float:
        """Ratio of true findings to false positives."""
        signal = self.anomalies_detected + self.confirmations
        noise = self.false_positives
        if noise == 0:
            return float("inf") if signal > 0 else 0.0
        return signal / noise

    @property
    def rovi(self) -> float:
        """Return on Value of Information (RoVI)."""
        if self.total_gas_consumed <= 0:
            return 0.0
        return self.total_voi_generated / self.total_gas_consumed


# =============================================================================
# Observation Records
# =============================================================================


@dataclass
class ObservationRecord:
    """Record of a single observation event."""

    observer_id: str
    target_id: str
    gas: Gas
    finding: ObservationFinding
    depth: ObservationDepth = ObservationDepth.TELEMETRY_ONLY
    timestamp: datetime = field(default_factory=datetime.now)
    voi: float = 0.0  # Calculated Value of Information


@dataclass
class Intervention:
    """Record of an intervention triggered by observation."""

    observation_id: str
    action: str
    outcome: "InterventionOutcome"
    timestamp: datetime = field(default_factory=datetime.now)


@dataclass
class InterventionOutcome:
    """Outcome of an intervention."""

    success: bool
    value_saved: float = 0.0
    description: str = ""


# =============================================================================
# VoI Receipt
# =============================================================================


@dataclass
class VoIReceipt:
    """Receipt for an observation transaction."""

    observation: ObservationRecord
    voi: float
    cumulative_epistemic_capital: EpistemicCapital


# =============================================================================
# VoI Ledger
# =============================================================================


class VoILedger:
    """
    Tracks the economics of observation.

    Separate from the main ValueLedger because observation
    operates on a different value calculus.
    """

    def __init__(self, main_ledger: Optional[ValueLedger] = None):
        self.main_ledger = main_ledger
        self.observations: dict[str, list[ObservationRecord]] = {}
        self.interventions: list[Intervention] = []
        self.epistemic_capital: dict[str, EpistemicCapital] = {}

        # Disaster cost estimates by category
        self.disaster_costs: dict[str, float] = {
            "security_breach": 1000.0,
            "data_corruption": 500.0,
            "service_outage": 200.0,
            "performance_degradation": 50.0,
            "compliance_violation": 300.0,
            "resource_exhaustion": 100.0,
            "default": 100.0,
        }

    def get_epistemic_capital(self, observer_id: str) -> EpistemicCapital:
        """Get or create epistemic capital for an observer."""
        if observer_id not in self.epistemic_capital:
            self.epistemic_capital[observer_id] = EpistemicCapital()
        return self.epistemic_capital[observer_id]

    def log_observation(
        self,
        observer_id: str,
        target_id: str,
        gas_consumed: Gas,
        finding: ObservationFinding,
        depth: ObservationDepth = ObservationDepth.TELEMETRY_ONLY,
    ) -> VoIReceipt:
        """
        Record an observation event.
        """
        record = ObservationRecord(
            observer_id=observer_id,
            target_id=target_id,
            gas=gas_consumed,
            finding=finding,
            depth=depth,
        )

        # Calculate immediate VoI
        voi = self.calculate_voi(finding)
        record.voi = voi

        # Store observation
        self.observations.setdefault(observer_id, []).append(record)

        # Update epistemic capital
        capital = self.get_epistemic_capital(observer_id)
        capital.observations += 1
        capital.total_gas_consumed += gas_consumed.cost_usd
        capital.total_voi_generated += voi

        # Update capital based on finding type
        if finding.type == FindingType.ANOMALY_DETECTED:
            capital.anomalies_detected += 1
            capital.disasters_prevented += voi
        elif finding.type == FindingType.HEALTH_CONFIRMED:
            capital.confirmations += 1
        elif finding.type == FindingType.FALSE_POSITIVE:
            capital.false_positives += 1

        return VoIReceipt(
            observation=record,
            voi=voi,
            cumulative_epistemic_capital=capital,
        )

    def calculate_voi(self, finding: ObservationFinding) -> float:
        """
        Calculate Value of Information for a finding.

        Uses counterfactual reasoning:
        "What would have happened without this observation?"
        """
        if finding.type == FindingType.ANOMALY_DETECTED:
            # Estimate disaster cost if undetected
            disaster_cost = self.estimate_disaster_cost(finding.anomaly or "default")
            detection_prob = finding.confidence
            return disaster_cost * detection_prob

        elif finding.type == FindingType.HEALTH_CONFIRMED:
            # Confirmation has value too (reduces uncertainty)
            # But less than anomaly detection
            return CONFIRMATION_VALUE * finding.confidence

        elif finding.type == FindingType.FALSE_POSITIVE:
            # Negative value: wasted attention
            return -ALERT_FATIGUE_COST

        return 0.0

    def estimate_disaster_cost(self, anomaly_type: str) -> float:
        """Estimate cost of a disaster based on type."""
        # Check for known categories
        anomaly_lower = anomaly_type.lower()
        for category, cost in self.disaster_costs.items():
            if category in anomaly_lower:
                return cost
        return self.disaster_costs["default"]

    def log_intervention(
        self,
        observation_id: str,
        action_taken: str,
        outcome: InterventionOutcome,
    ) -> None:
        """
        Record when observation led to corrective action.

        This closes the loop: observation → intervention → outcome
        """
        intervention = Intervention(
            observation_id=observation_id,
            action=action_taken,
            outcome=outcome,
        )
        self.interventions.append(intervention)

        # Retroactively update VoI based on actual outcome
        self.update_voi_retrospectively(observation_id, outcome)

    def update_voi_retrospectively(
        self, observation_id: str, outcome: InterventionOutcome
    ) -> None:
        """Update VoI based on actual intervention outcome."""
        # Find the observation record
        for records in self.observations.values():
            for record in records:
                if (
                    f"{record.observer_id}_{record.timestamp.isoformat()}"
                    == observation_id
                ):
                    # Update with actual value saved
                    old_voi = record.voi
                    record.voi = outcome.value_saved

                    # Update epistemic capital
                    capital = self.get_epistemic_capital(record.observer_id)
                    capital.total_voi_generated += outcome.value_saved - old_voi
                    capital.disasters_prevented += outcome.value_saved - old_voi
                    return

    def get_observer_rovi(self, observer_id: str) -> float:
        """
        Return on Value of Information (RoVI) for an observer.

        RoVI = Total VoI Generated / Total Gas Consumed

        This is the O-gent equivalent of RoC.
        """
        records = self.observations.get(observer_id, [])
        if not records:
            return 0.0

        total_voi = sum(r.voi for r in records)
        total_gas = sum(r.gas.cost_usd for r in records)

        return total_voi / total_gas if total_gas > 0 else 0.0

    def get_observer_stats(self, observer_id: str) -> dict[str, Any]:
        """Get statistics for an observer."""
        capital = self.get_epistemic_capital(observer_id)
        records = self.observations.get(observer_id, [])

        return {
            "observer_id": observer_id,
            "total_observations": capital.observations,
            "anomalies_detected": capital.anomalies_detected,
            "confirmations": capital.confirmations,
            "false_positives": capital.false_positives,
            "disasters_prevented_value": capital.disasters_prevented,
            "net_epistemic_value": capital.net_epistemic_value,
            "signal_to_noise_ratio": capital.signal_to_noise_ratio,
            "total_gas_consumed": capital.total_gas_consumed,
            "total_voi_generated": capital.total_voi_generated,
            "rovi": capital.rovi,
            "observation_count": len(records),
        }

    def system_rovi(self) -> float:
        """System-wide Return on Value of Information."""
        total_voi = sum(
            cap.total_voi_generated for cap in self.epistemic_capital.values()
        )
        total_gas = sum(
            cap.total_gas_consumed for cap in self.epistemic_capital.values()
        )
        return total_voi / total_gas if total_gas > 0 else 0.0

    def total_gas(self) -> float:
        """Total gas consumed by all observers."""
        return sum(cap.total_gas_consumed for cap in self.epistemic_capital.values())

    def false_positive_rate(self) -> float:
        """System-wide false positive rate."""
        total_observations = sum(
            cap.observations for cap in self.epistemic_capital.values()
        )
        total_false_positives = sum(
            cap.false_positives for cap in self.epistemic_capital.values()
        )
        return (
            total_false_positives / total_observations
            if total_observations > 0
            else 0.0
        )


# =============================================================================
# VoI Optimizer
# =============================================================================


class VoIOptimizer:
    """
    Optimizes observation budget allocation.

    Key insight: Not all agents are equally worth observing.
    Focus observation on high-risk, high-value agents.
    """

    def __init__(
        self,
        ledger: ValueLedger,
        voi_ledger: VoILedger,
    ):
        self.ledger = ledger
        self.voi_ledger = voi_ledger

        # Historical reliability tracking
        self._reliability: dict[str, list[bool]] = {}

        # Observability scores (can an observer actually detect problems?)
        self._observability: dict[str, float] = {}

    def record_reliability(self, agent_id: str, success: bool) -> None:
        """Record a success/failure for reliability tracking."""
        self._reliability.setdefault(agent_id, []).append(success)
        # Keep last 100 results
        if len(self._reliability[agent_id]) > 100:
            self._reliability[agent_id] = self._reliability[agent_id][-100:]

    def get_reliability(self, agent_id: str) -> float:
        """Get historical reliability for an agent (0.0 to 1.0)."""
        history = self._reliability.get(agent_id, [])
        if not history:
            return 0.5  # Unknown: assume 50%
        return sum(1 for s in history if s) / len(history)

    def set_observability(self, agent_id: str, score: float) -> None:
        """Set observability score for an agent."""
        self._observability[agent_id] = max(0.0, min(1.0, score))

    def get_observability_score(self, agent_id: str) -> float:
        """Get observability score (how well can we detect problems?)."""
        return self._observability.get(agent_id, 0.5)  # Default: 50%

    def compute_observation_priority(self, agent_id: str) -> float:
        """
        How much should we invest in observing this agent?

        Priority = Risk × Consequence × Observability

        - Risk: How likely is this agent to fail? (1 - reliability)
        - Consequence: How bad is failure? (value throughput fraction)
        - Observability: Can we actually detect failure?
        """
        # Risk: inverse of historical reliability
        reliability = self.get_reliability(agent_id)
        risk = 1.0 - reliability

        # Consequence: how much value flows through this agent
        sheet = self.ledger.get_agent_balance_sheet(agent_id)
        total_impact = self.ledger.treasury.total_impact()
        if total_impact > 0:
            consequence = sheet.assets / total_impact
        else:
            consequence = 0.5  # Default if no impact yet

        # Observability: can we actually catch problems?
        observability = self.get_observability_score(agent_id)

        return risk * consequence * observability

    def allocate_observation_budget(
        self,
        total_budget: Gas,
        agents: list[str],
    ) -> dict[str, Gas]:
        """
        Distribute observation budget across agents.

        Uses priority scores to allocate proportionally.
        """
        if not agents:
            return {}

        priorities = {
            agent_id: self.compute_observation_priority(agent_id) for agent_id in agents
        }

        total_priority = sum(priorities.values())
        if total_priority == 0:
            # Equal distribution if no priority signal
            per_agent = total_budget.tokens // len(agents)
            return {
                a: Gas(
                    tokens=per_agent,
                    time_ms=0,
                    model_multiplier=total_budget.model_multiplier,
                )
                for a in agents
            }

        allocations = {}
        for agent_id, priority in priorities.items():
            fraction = priority / total_priority
            allocations[agent_id] = Gas(
                tokens=int(total_budget.tokens * fraction),
                time_ms=0,
                model_multiplier=total_budget.model_multiplier,
            )

        return allocations

    def select_observation_depth(
        self,
        agent_id: str,
        budget: Gas,
    ) -> ObservationDepth:
        """
        Given a budget, decide how deeply to observe.

        Depth Levels:
        - TELEMETRY_ONLY: Just metrics (cheapest)
        - SEMANTIC_SPOT: Sample semantic checks
        - SEMANTIC_FULL: Full semantic analysis (most expensive)
        - AXIOLOGICAL: Full economic audit
        """
        # Estimate costs (in tokens)
        costs = {
            ObservationDepth.TELEMETRY_ONLY: 10,
            ObservationDepth.SEMANTIC_SPOT: 500,
            ObservationDepth.SEMANTIC_FULL: 2000,
            ObservationDepth.AXIOLOGICAL: 1000,
        }

        # Select deepest level we can afford
        # Order from deepest to shallowest
        depth_order = [
            ObservationDepth.SEMANTIC_FULL,
            ObservationDepth.AXIOLOGICAL,
            ObservationDepth.SEMANTIC_SPOT,
            ObservationDepth.TELEMETRY_ONLY,
        ]

        for depth in depth_order:
            if costs[depth] <= budget.tokens:
                return depth

        return ObservationDepth.TELEMETRY_ONLY

    def get_observation_recommendations(
        self,
        agents: list[str],
        total_budget: Gas,
    ) -> list[dict[str, Any]]:
        """Get observation recommendations for a set of agents."""
        allocations = self.allocate_observation_budget(total_budget, agents)
        recommendations = []

        for agent_id in agents:
            budget = allocations.get(agent_id, Gas(tokens=0))
            priority = self.compute_observation_priority(agent_id)
            depth = self.select_observation_depth(agent_id, budget)

            recommendations.append(
                {
                    "agent_id": agent_id,
                    "priority": priority,
                    "budget_tokens": budget.tokens,
                    "recommended_depth": depth.value,
                    "reliability": self.get_reliability(agent_id),
                    "observability": self.get_observability_score(agent_id),
                }
            )

        # Sort by priority (highest first)
        recommendations.sort(key=lambda x: x["priority"], reverse=True)
        return recommendations


# =============================================================================
# Adaptive Observer
# =============================================================================


class AdaptiveObserver:
    """
    Adjusts observation frequency based on system state.

    Like a thermostat: observe more when things are hot.
    """

    def __init__(
        self,
        voi_optimizer: VoIOptimizer,
        base_interval: timedelta = timedelta(seconds=60),
        min_interval: timedelta = timedelta(seconds=5),
        max_interval: timedelta = timedelta(minutes=10),
    ):
        self.optimizer = voi_optimizer
        self.base_interval = base_interval
        self.min_interval = min_interval
        self.max_interval = max_interval

        # Last observation times
        self._last_observation: dict[str, datetime] = {}

        # Observers for each agent
        self._observers: dict[str, Callable[[str], Any]] = {}

        # Running state
        self._running = False

    def compute_observation_interval(self, agent_id: str) -> timedelta:
        """
        How often should we observe this agent?
        """
        priority = self.optimizer.compute_observation_priority(agent_id)

        # High priority → short interval (frequent observation)
        # Low priority → long interval (rare observation)
        if priority > 0.8:
            return self.min_interval
        elif priority > 0.5:
            return self.base_interval
        elif priority > 0.2:
            return timedelta(seconds=self.base_interval.total_seconds() * 2)
        else:
            return self.max_interval

    def should_observe(self, agent_id: str) -> bool:
        """Check if it's time to observe this agent."""
        now = datetime.now()
        last = self._last_observation.get(agent_id, datetime.min)
        interval = self.compute_observation_interval(agent_id)
        return (now - last) >= interval

    def mark_observed(self, agent_id: str) -> None:
        """Mark agent as just observed."""
        self._last_observation[agent_id] = datetime.now()

    def register_observer(
        self,
        agent_id: str,
        observer: Callable[[str], Any],
    ) -> None:
        """Register an observer function for an agent."""
        self._observers[agent_id] = observer

    async def observe(self, agent_id: str) -> Optional[Any]:
        """Perform observation if registered."""
        observer = self._observers.get(agent_id)
        if observer is None:
            return None

        result = observer(agent_id)
        self.mark_observed(agent_id)
        return result

    async def observe_adaptively(self, agents: list[str]) -> None:
        """
        Run adaptive observation loop.

        Observes agents at intervals determined by their priority.
        """
        self._running = True

        while self._running:
            # Timestamp for potential future use in scheduling logic
            _now = datetime.now()

            for agent_id in agents:
                if self.should_observe(agent_id):
                    await self.observe(agent_id)

            await asyncio.sleep(1)

    def stop(self) -> None:
        """Stop the adaptive observation loop."""
        self._running = False

    def get_observation_schedule(
        self,
        agents: list[str],
    ) -> list[dict[str, Any]]:
        """Get the current observation schedule for agents."""
        schedule = []
        now = datetime.now()

        for agent_id in agents:
            last = self._last_observation.get(agent_id, datetime.min)
            interval = self.compute_observation_interval(agent_id)
            next_observation = last + interval
            time_until = max(timedelta(0), next_observation - now)

            schedule.append(
                {
                    "agent_id": agent_id,
                    "interval_seconds": interval.total_seconds(),
                    "last_observed": last.isoformat() if last != datetime.min else None,
                    "next_observation": next_observation.isoformat(),
                    "seconds_until_next": time_until.total_seconds(),
                    "priority": self.optimizer.compute_observation_priority(agent_id),
                }
            )

        # Sort by next observation time
        schedule.sort(key=lambda x: x["seconds_until_next"])
        return schedule


# =============================================================================
# Unified Value Accounting
# =============================================================================


@dataclass
class SystemHealthReport:
    """Report on overall system economic health."""

    production_roc: float  # Return on Compute for productive work
    observation_rovi: float  # Return on Value of Information
    observation_budget_fraction: float  # What % of budget goes to observation
    is_healthy: bool
    recommendations: list[str]


class UnifiedValueAccounting:
    """
    Unified accounting across UVP and VoI.

    The system is healthy when:
    - RoC > 1.0 (production is profitable)
    - RoVI > 1.0 (observation is justified)
    - Total Gas sustainable within budget
    - Observation fraction < 10% of total budget
    """

    def __init__(self, value_ledger: ValueLedger, voi_ledger: VoILedger):
        self.value = value_ledger
        self.voi = voi_ledger

        # Thresholds for health assessment
        self.min_roc = 1.0
        self.min_rovi = 1.0
        self.max_observation_fraction = 0.10  # 10%
        self.max_false_positive_rate = 0.30  # 30%

    def system_health(self) -> SystemHealthReport:
        """Generate comprehensive system health report."""
        production_roc = self.value.system_roc()
        observation_rovi = self.voi.system_rovi()

        total_production_gas = self.value.treasury.total_gas()
        total_observation_gas = self.voi.total_gas()
        total_gas = total_production_gas + total_observation_gas

        observation_fraction = (
            total_observation_gas / total_gas if total_gas > 0 else 0.0
        )

        is_healthy = (
            production_roc >= self.min_roc
            and observation_rovi >= self.min_rovi
            and observation_fraction <= self.max_observation_fraction
        )

        recommendations = self.generate_recommendations()

        return SystemHealthReport(
            production_roc=production_roc,
            observation_rovi=observation_rovi,
            observation_budget_fraction=observation_fraction,
            is_healthy=is_healthy,
            recommendations=recommendations,
        )

    def generate_recommendations(self) -> list[str]:
        """Generate optimization recommendations."""
        recs = []

        # Check production RoC
        if self.value.system_roc() < self.min_roc:
            recs.append("Production RoC below threshold; focus on high-value tasks")

        # Check observation RoVI
        if self.voi.system_rovi() < self.min_rovi:
            recs.append(
                "Observation RoVI below threshold; reduce observation frequency or depth"
            )

        # Check false positive rate
        if self.voi.false_positive_rate() > self.max_false_positive_rate:
            recs.append(
                f"False positive rate ({self.voi.false_positive_rate():.1%}) too high; "
                "tune observation thresholds"
            )

        # Check observation budget fraction
        total_production_gas = self.value.treasury.total_gas()
        total_observation_gas = self.voi.total_gas()
        total_gas = total_production_gas + total_observation_gas

        if total_gas > 0:
            observation_fraction = total_observation_gas / total_gas
            if observation_fraction > self.max_observation_fraction:
                recs.append(
                    f"Observation consuming {observation_fraction:.1%} of budget; "
                    f"target <{self.max_observation_fraction:.0%}"
                )

        return recs

    def get_currency_summary(self) -> dict[str, Any]:
        """Get summary of all three currencies."""
        return {
            "gas": {
                "production": self.value.treasury.total_gas(),
                "observation": self.voi.total_gas(),
                "total": self.value.treasury.total_gas() + self.voi.total_gas(),
            },
            "impact": {
                "total": self.value.treasury.total_impact(),
                "debt": self.value.treasury.total_debt(),
                "net": self.value.treasury.total_impact()
                - self.value.treasury.total_debt(),
            },
            "epistemic_capital": {
                "total_voi": sum(
                    cap.total_voi_generated
                    for cap in self.voi.epistemic_capital.values()
                ),
                "disasters_prevented": sum(
                    cap.disasters_prevented
                    for cap in self.voi.epistemic_capital.values()
                ),
                "false_positives": sum(
                    cap.false_positives for cap in self.voi.epistemic_capital.values()
                ),
            },
            "efficiency": {
                "production_roc": self.value.system_roc(),
                "observation_rovi": self.voi.system_rovi(),
            },
        }


# =============================================================================
# Convenience Functions
# =============================================================================


def create_voi_ledger(value_ledger: Optional[ValueLedger] = None) -> VoILedger:
    """Create a VoI ledger, optionally linked to a value ledger."""
    return VoILedger(main_ledger=value_ledger)


def create_voi_optimizer(
    value_ledger: ValueLedger,
    voi_ledger: Optional[VoILedger] = None,
) -> VoIOptimizer:
    """Create a VoI optimizer."""
    if voi_ledger is None:
        voi_ledger = create_voi_ledger(value_ledger)
    return VoIOptimizer(ledger=value_ledger, voi_ledger=voi_ledger)


def create_adaptive_observer(
    voi_optimizer: VoIOptimizer,
    base_interval_seconds: float = 60.0,
    min_interval_seconds: float = 5.0,
    max_interval_seconds: float = 600.0,
) -> AdaptiveObserver:
    """Create an adaptive observer with custom intervals."""
    return AdaptiveObserver(
        voi_optimizer=voi_optimizer,
        base_interval=timedelta(seconds=base_interval_seconds),
        min_interval=timedelta(seconds=min_interval_seconds),
        max_interval=timedelta(seconds=max_interval_seconds),
    )


def create_unified_accounting(
    value_ledger: ValueLedger,
    voi_ledger: Optional[VoILedger] = None,
) -> UnifiedValueAccounting:
    """Create unified value accounting."""
    if voi_ledger is None:
        voi_ledger = create_voi_ledger(value_ledger)
    return UnifiedValueAccounting(value_ledger=value_ledger, voi_ledger=voi_ledger)
