"""
JIT Agent Templates: Code generation templates for common agent patterns.

Extracted from meta_architect.py (H12) as part of Phase D polish.

This module provides template-based code generation for common agent patterns:
- Parser: Extract structured data from text
- Filter: Select items based on criteria
- Transformer: Convert data between formats
- Analyzer: Extract insights from data
- Validator: Check data against rules
- Generic: General-purpose agent

These templates are used by MetaArchitect for JIT agent compilation.
"""

from dataclasses import dataclass


@dataclass(frozen=True)
class TemplateContext:
    """Context for template rendering."""

    intent: str  # Natural language description
    context: dict[str, object]  # Additional context hints


def generate_parser_template(ctx: TemplateContext) -> str:
    """
    Generate a parser agent template.

    Parser agents extract structured data from unstructured text
    (logs, configs, etc.).

    Args:
        ctx: Template context with intent and hints

    Returns:
        Generated Python source code
    """
    # Extract context hints
    sample_input = ctx.context.get("sample", "")
    output_format = ctx.context.get("output_format", "dict")

    return f'''"""
JIT-compiled parser agent.

Intent: {ctx.intent}
"""

import re
from dataclasses import dataclass
from typing import Optional


@dataclass
class ParsedData:
    """Parsed data structure."""
    raw: str
    # Add fields based on parsing logic


class JITParser:
    """
    {ctx.intent}

    Generated by MetaArchitect for one-time use.
    """

    def parse(self, text: str) -> Optional[ParsedData]:
        """
        Parse the input text and return structured data.

        Args:
            text: Input text to parse

        Returns:
            ParsedData if successful, None otherwise
        """
        # TODO: Implement parsing logic based on:
        # Sample: {str(sample_input)[:100]}...
        # Output: {output_format}

        # Placeholder implementation
        if not text:
            return None

        return ParsedData(raw=text)
'''


def generate_filter_template(ctx: TemplateContext) -> str:
    """
    Generate a filter agent template.

    Filter agents select items based on predicates.

    Args:
        ctx: Template context with intent and criteria

    Returns:
        Generated Python source code
    """
    criteria = ctx.context.get("criteria", "matches condition")

    return f'''"""
JIT-compiled filter agent.

Intent: {ctx.intent}
"""

from typing import Any, Callable


class JITFilter:
    """
    {ctx.intent}

    Generated by MetaArchitect for one-time use.
    """

    def __init__(self, predicate: Optional[Callable[[Any], bool]] = None):
        """Initialize filter with optional custom predicate."""
        self.predicate = predicate or self._default_predicate

    def _default_predicate(self, item: Any) -> bool:
        """
        Default filtering logic.

        Criteria: {criteria}
        """
        # TODO: Implement filtering logic
        return True

    def filter(self, items: list[Any]) -> list[Any]:
        """Filter items based on predicate."""
        return [item for item in items if self.predicate(item)]
'''


def generate_transformer_template(ctx: TemplateContext) -> str:
    """
    Generate a transformer agent template.

    Transformer agents convert data from format A to format B.

    Args:
        ctx: Template context with intent

    Returns:
        Generated Python source code
    """
    return f'''"""
JIT-compiled transformer agent.

Intent: {ctx.intent}
"""

from typing import Any


class JITTransformer:
    """
    {ctx.intent}

    Generated by MetaArchitect for one-time use.
    """

    def transform(self, input_data: Any) -> Any:
        """
        Transform input data to desired output format.

        Args:
            input_data: Data to transform

        Returns:
            Transformed data
        """
        # TODO: Implement transformation logic
        return input_data
'''


def generate_analyzer_template(ctx: TemplateContext) -> str:
    """
    Generate an analyzer agent template.

    Analyzer agents extract insights and patterns from data.

    Args:
        ctx: Template context with intent and patterns

    Returns:
        Generated Python source code
    """
    patterns = ctx.context.get("patterns", [])

    return f'''"""
JIT-compiled analyzer agent.

Intent: {ctx.intent}
"""

import re
from dataclasses import dataclass
from typing import Any


@dataclass
class AnalysisResult:
    """Result of analysis."""
    matches: list[str]
    confidence: float
    metadata: dict[str, Any]


class JITAnalyzer:
    """
    {ctx.intent}

    Generated by MetaArchitect for one-time use.
    """

    def __init__(self):
        """Initialize analyzer with patterns."""
        self.patterns = {patterns}

    def analyze(self, data: Any) -> AnalysisResult:
        """
        Analyze data and extract insights.

        Args:
            data: Data to analyze

        Returns:
            AnalysisResult with findings
        """
        # TODO: Implement analysis logic
        matches: list[str] = []
        confidence = 0.0
        metadata: dict[str, Any] = {{}}

        return AnalysisResult(
            matches=matches,
            confidence=confidence,
            metadata=metadata
        )
'''


def generate_validator_template(ctx: TemplateContext) -> str:
    """
    Generate a validator agent template.

    Validator agents check data against rules.

    Args:
        ctx: Template context with intent and rules

    Returns:
        Generated Python source code
    """
    rules = ctx.context.get("rules", [])

    return f'''"""
JIT-compiled validator agent.

Intent: {ctx.intent}
"""

from dataclasses import dataclass
from typing import Any


@dataclass
class ValidationResult:
    """Result of validation."""
    valid: bool
    errors: list[str]
    warnings: list[str]


class JITValidator:
    """
    {ctx.intent}

    Generated by MetaArchitect for one-time use.
    """

    def __init__(self):
        """Initialize validator with rules."""
        self.rules = {rules}

    def validate(self, data: Any) -> ValidationResult:
        """
        Validate data against rules.

        Args:
            data: Data to validate

        Returns:
            ValidationResult with validation status and messages
        """
        errors: list[str] = []
        warnings: list[str] = []

        # TODO: Implement validation logic based on rules

        return ValidationResult(
            valid=len(errors) == 0,
            errors=errors,
            warnings=warnings
        )
'''


def generate_generic_template(ctx: TemplateContext) -> str:
    """
    Generate a generic agent template.

    Generic agents for unclassified intents.

    Args:
        ctx: Template context with intent

    Returns:
        Generated Python source code
    """
    return f'''"""
JIT-compiled generic agent.

Intent: {ctx.intent}
"""

from typing import Any


class JITAgent:
    """
    {ctx.intent}

    Generated by MetaArchitect for one-time use.
    """

    def invoke(self, input_data: Any) -> Any:
        """
        Process input and produce output.

        Args:
            input_data: Input to process

        Returns:
            Processed output
        """
        # TODO: Implement logic based on intent
        return input_data
'''


# Template registry for easy lookup
TEMPLATE_GENERATORS = {
    "parser": generate_parser_template,
    "filter": generate_filter_template,
    "transformer": generate_transformer_template,
    "analyzer": generate_analyzer_template,
    "validator": generate_validator_template,
    "generic": generate_generic_template,
}


def generate_template(pattern: str, ctx: TemplateContext) -> str:
    """
    Generate code from template based on pattern.

    Args:
        pattern: Template pattern name (parser, filter, etc.)
        ctx: Template context with intent and hints

    Returns:
        Generated Python source code

    Raises:
        KeyError: If pattern not found in registry
    """
    generator = TEMPLATE_GENERATORS.get(pattern, generate_generic_template)
    return generator(ctx)
