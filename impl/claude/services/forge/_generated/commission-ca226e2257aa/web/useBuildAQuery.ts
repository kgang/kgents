/**
 * BuildAAgent AGENTESE Hooks
 *
 * React hooks for world.builda AGENTESE paths.
 * Uses useAsyncState pattern (project standard).
 *
 * Auto-generated by the Metaphysical Forge Projector.
 *
 * @see services/forge/artisans/projector.py
 */

import { useEffect, useCallback, useState } from 'react';
import { apiClient } from '@/api/client';
import { useAsyncState } from '@/hooks/useAsyncState';

// =============================================================================
// Types
// =============================================================================

export interface BuildAManifestResponse {
  name: string;
  state: string;
  description: string;
}

export interface QueryResult<T> {
  data: T | null;
  isLoading: boolean;
  error: Error | null;
  refetch: () => void;
}

export interface MutationResult<TData, TVariables> {
  data: TData | null;
  isLoading: boolean;
  isPending: boolean;
  error: Error | null;
  mutate: (variables: TVariables) => void;
  mutateAsync: (variables: TVariables) => Promise<TData>;
}

export interface InvokeRequest {
  // Add fields based on operation requirements
}

export interface InvokeResponse {
  success: boolean;
  message?: string;
}

// =============================================================================
// AGENTESE Fetch Helper
// =============================================================================

interface AgenteseResponse<T> {
  path: string;
  aspect: string;
  result: T;
  error?: string;
}

async function fetchAgentese<T>(path: string, body?: unknown): Promise<T> {
  const urlPath = path.replace(/\./g, '/');
  const parts = path.split('.');
  const aspect = parts.pop()!;

  if (aspect === 'manifest') {
    const response = await apiClient.get<AgenteseResponse<T>>(`/agentese/${urlPath}`);
    if (response.data.error) throw new Error(response.data.error);
    return response.data.result;
  }

  const response = await apiClient.post<AgenteseResponse<T>>(
    `/agentese/${urlPath.split('/').slice(0, -1).join('/')}/${aspect}`,
    body ?? {}
  );
  if (response.data.error) throw new Error(response.data.error);
  return response.data.result;
}

// =============================================================================
// Manifest Hook
// =============================================================================

/**
 * Fetch BuildAAgent manifest.
 * AGENTESE: world.builda.manifest
 */
export function useBuildAQuery(): QueryResult<BuildAManifestResponse> {
  const { state, execute } = useAsyncState<BuildAManifestResponse>();

  const refetch = useCallback(() => {
    execute(fetchAgentese<BuildAManifestResponse>('world.builda.manifest'));
  }, [execute]);

  useEffect(() => {
    refetch();
  }, [refetch]);

  return {
    data: state.data,
    isLoading: state.isLoading,
    error: state.error ? new Error(state.error) : null,
    refetch,
  };
}

// =============================================================================
// Operation Hooks
// =============================================================================

/**
 * Main operation - implement based on intent
 * AGENTESE: world.builda.invoke
 */
export function useInvoke(): MutationResult<
  InvokeResponse,
  InvokeRequest
> {
  const { state, execute } = useAsyncState<InvokeResponse>();
  const [isPending, setIsPending] = useState(false);

  const mutateAsync = useCallback(
    async (data: InvokeRequest) => {
      setIsPending(true);
      try {
        const result = await execute(
          fetchAgentese<InvokeResponse>('world.builda.invoke', data)
        );
        if (!result) throw new Error('Failed to execute invoke');
        return result;
      } finally {
        setIsPending(false);
      }
    },
    [execute]
  );

  const mutate = useCallback(
    (data: InvokeRequest) => {
      mutateAsync(data).catch(() => {});
    },
    [mutateAsync]
  );

  return {
    data: state.data,
    isLoading: state.isLoading,
    isPending,
    error: state.error ? new Error(state.error) : null,
    mutate,
    mutateAsync,
  };
}

