"""
Projector Artisan: The Surface Renderer.

The Projector gives the agent form. Every surface is a view. It produces:
- React visualization component with elastic UI patterns
- React hooks for AGENTESE integration
- Barrel export for clean imports

This is real LLM-powered generation via K-gent soul.dialogue().

Usage:
    projector = ProjectorArtisan(soul=kgent_soul)
    output = await projector.project(commission, design, service_output, herald_output)
    # output.output contains: files, summary

"The Projector gives the agent form. Every surface is a view."

See: spec/protocols/metaphysical-forge.md (Section 2.5)
"""

from __future__ import annotations

import json
import os
import re
from dataclasses import dataclass
from datetime import datetime, timezone
from pathlib import Path
from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from agents.k.soul import KgentSoul

from ..commission import ArtisanOutput, ArtisanType, Commission
from .architect import AgentDesign

# === Projector Output ===


@dataclass
class ProjectorOutput:
    """
    Output from the Projector artisan.

    Contains generated React component files.
    """

    artifact_path: str
    files: dict[str, str]  # filename -> content
    summary: str

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return {
            "path": self.artifact_path,
            "files": list(self.files.keys()),
            "file_count": len(self.files),
            "summary": self.summary,
        }


# === Code Templates ===


def _derive_component_name(design: AgentDesign) -> str:
    """Derive React component name from design."""
    name = design.name
    # Remove "Agent" suffix if present
    if name.endswith("Agent"):
        name = name[:-5]
    return f"{name}Visualization"


def _derive_hook_name(design: AgentDesign) -> str:
    """Derive React hook name from design."""
    name = design.name
    if name.endswith("Agent"):
        name = name[:-5]
    return f"use{name}Query"


def _generate_index_template(design: AgentDesign) -> str:
    """Generate index.ts barrel export."""
    comp_name = _derive_component_name(design)
    hook_name = _derive_hook_name(design)

    return f"""/**
 * {design.name} Web Components
 *
 * Auto-generated by the Metaphysical Forge Projector.
 */

export {{ {comp_name} }} from './{comp_name}';
export {{ {hook_name} }} from './{hook_name}';
"""


def _generate_hooks_template(design: AgentDesign, agentese_path: str) -> str:
    """Generate React hooks for AGENTESE integration."""
    name = design.name
    if name.endswith("Agent"):
        name = name[:-5]
    hook_name = f"use{name}Query"

    # Generate hooks for each operation
    operation_hooks = []
    for op in design.operations:
        op_name = op.get("name", "unknown")
        pascal_name = "".join(word.capitalize() for word in op_name.split("_"))
        op_desc = op.get("description", "")

        operation_hooks.append(f"""
/**
 * {op_desc}
 * AGENTESE: {agentese_path}.{op_name}
 */
export function use{pascal_name}(): MutationResult<
  {pascal_name}Response,
  {pascal_name}Request
> {{
  const {{ state, execute }} = useAsyncState<{pascal_name}Response>();
  const [isPending, setIsPending] = useState(false);

  const mutateAsync = useCallback(
    async (data: {pascal_name}Request) => {{
      setIsPending(true);
      try {{
        const result = await execute(
          fetchAgentese<{pascal_name}Response>('{agentese_path}.{op_name}', data)
        );
        if (!result) throw new Error('Failed to execute {op_name}');
        return result;
      }} finally {{
        setIsPending(false);
      }}
    }},
    [execute]
  );

  const mutate = useCallback(
    (data: {pascal_name}Request) => {{
      mutateAsync(data).catch(() => {{}});
    }},
    [mutateAsync]
  );

  return {{
    data: state.data,
    isLoading: state.isLoading,
    isPending,
    error: state.error ? new Error(state.error) : null,
    mutate,
    mutateAsync,
  }};
}}
""")

    # Generate request/response types
    type_definitions = []
    for op in design.operations:
        op_name = op.get("name", "unknown")
        pascal_name = "".join(word.capitalize() for word in op_name.split("_"))
        type_definitions.append(f"""
export interface {pascal_name}Request {{
  // Add fields based on operation requirements
}}

export interface {pascal_name}Response {{
  success: boolean;
  message?: string;
}}
""")

    return f"""/**
 * {design.name} AGENTESE Hooks
 *
 * React hooks for {agentese_path} AGENTESE paths.
 * Uses useAsyncState pattern (project standard).
 *
 * Auto-generated by the Metaphysical Forge Projector.
 *
 * @see services/forge/artisans/projector.py
 */

import {{ useEffect, useCallback, useState }} from 'react';
import {{ apiClient }} from '@/api/client';
import {{ useAsyncState }} from '@/hooks/useAsyncState';

// =============================================================================
// Types
// =============================================================================

export interface {name}ManifestResponse {{
  name: string;
  state: string;
  description: string;
}}

export interface QueryResult<T> {{
  data: T | null;
  isLoading: boolean;
  error: Error | null;
  refetch: () => void;
}}

export interface MutationResult<TData, TVariables> {{
  data: TData | null;
  isLoading: boolean;
  isPending: boolean;
  error: Error | null;
  mutate: (variables: TVariables) => void;
  mutateAsync: (variables: TVariables) => Promise<TData>;
}}
{"".join(type_definitions)}
// =============================================================================
// AGENTESE Fetch Helper
// =============================================================================

interface AgenteseResponse<T> {{
  path: string;
  aspect: string;
  result: T;
  error?: string;
}}

async function fetchAgentese<T>(path: string, body?: unknown): Promise<T> {{
  const urlPath = path.replace(/\\./g, '/');
  const parts = path.split('.');
  const aspect = parts.pop()!;

  if (aspect === 'manifest') {{
    const response = await apiClient.get<AgenteseResponse<T>>(`/agentese/${{urlPath}}`);
    if (response.data.error) throw new Error(response.data.error);
    return response.data.result;
  }}

  const response = await apiClient.post<AgenteseResponse<T>>(
    `/agentese/${{urlPath.split('/').slice(0, -1).join('/')}}/${{aspect}}`,
    body ?? {{}}
  );
  if (response.data.error) throw new Error(response.data.error);
  return response.data.result;
}}

// =============================================================================
// Manifest Hook
// =============================================================================

/**
 * Fetch {design.name} manifest.
 * AGENTESE: {agentese_path}.manifest
 */
export function {hook_name}(): QueryResult<{name}ManifestResponse> {{
  const {{ state, execute }} = useAsyncState<{name}ManifestResponse>();

  const refetch = useCallback(() => {{
    execute(fetchAgentese<{name}ManifestResponse>('{agentese_path}.manifest'));
  }}, [execute]);

  useEffect(() => {{
    refetch();
  }}, [refetch]);

  return {{
    data: state.data,
    isLoading: state.isLoading,
    error: state.error ? new Error(state.error) : null,
    refetch,
  }};
}}

// =============================================================================
// Operation Hooks
// =============================================================================
{"".join(operation_hooks)}
"""


def _generate_visualization_template(design: AgentDesign, agentese_path: str) -> str:
    """Generate React visualization component with elastic UI patterns."""
    name = design.name
    if name.endswith("Agent"):
        name = name[:-5]
    comp_name = f"{name}Visualization"
    hook_name = f"use{name}Query"

    # Generate state-specific UI sections
    state_sections = []
    for state in design.states:
        state_sections.append(f"""
          {{status === '{state.lower()}' && (
            <div className="p-4 bg-stone-50 rounded-lg">
              <div className="text-sm font-medium text-stone-700">{state}</div>
              <p className="mt-1 text-xs text-stone-400">
                Agent is in {state} state
              </p>
            </div>
          )}}""")

    states_ui = "".join(state_sections)

    # Generate operation buttons
    operation_buttons = []
    for op in design.operations:
        op_name = op.get("name", "unknown")
        op_desc = op.get("description", "")
        pascal_name = "".join(word.capitalize() for word in op_name.split("_"))
        operation_buttons.append(f"""
            <button
              onClick={{() => console.log('{op_name}')}}
              className="px-3 py-2 text-sm bg-amber-100 text-amber-800 rounded-md hover:bg-amber-200 transition-colors"
              title="{op_desc}"
            >
              {pascal_name}
            </button>""")

    operations_ui = "".join(operation_buttons) if operation_buttons else ""

    return f"""/**
 * {comp_name} - {design.description}
 *
 * Main visualization component for {design.name}.
 * Follows elastic-ui-patterns: density-aware layout.
 *
 * Auto-generated by the Metaphysical Forge Projector.
 *
 * @see services/forge/artisans/projector.py
 * @see docs/skills/elastic-ui-patterns.md
 */

import {{ useState, useCallback }} from 'react';
import {{ Hammer, RefreshCw }} from 'lucide-react';
import {{ {hook_name} }} from './{hook_name}';
import {{ cn }} from '@/lib/utils';
import type {{ Density }} from '@/shell/types';

// =============================================================================
// Types
// =============================================================================

export interface {comp_name}Props {{
  /** Initial status data from PathProjection */
  status: {name}StatusData | null;
  /** Current layout density */
  density: Density;
  /** Layout helpers */
  isMobile: boolean;
  isTablet: boolean;
  isDesktop: boolean;
  /** Refetch function from PathProjection */
  refetch: () => void;
}}

export interface {name}StatusData {{
  name?: string;
  state?: string;
  description?: string;
}}

// =============================================================================
// Component
// =============================================================================

export function {comp_name}({{
  status: initialStatus,
  density,
  isMobile,
  isTablet: _isTablet,
  isDesktop: _isDesktop,
  refetch: parentRefetch,
}}: {comp_name}Props) {{
  // AGENTESE hook for live data
  const manifest = {hook_name}();

  // Derive status from manifest or initial data
  const status = manifest.data?.state || initialStatus?.state || 'unknown';
  const name = manifest.data?.name || initialStatus?.name || '{design.name}';
  const description = manifest.data?.description || initialStatus?.description || '{design.description}';

  // Retry handler
  const handleRetry = useCallback(() => {{
    manifest.refetch();
    parentRefetch();
  }}, [manifest, parentRefetch]);

  // Density-adaptive styles
  const containerPadding = isMobile ? 'px-4 py-4' : 'px-6 py-8';
  const maxWidth = isMobile ? 'max-w-full' : 'max-w-4xl';
  const titleSize = isMobile ? 'text-xl' : 'text-2xl';

  return (
    <div className="min-h-screen bg-stone-50">
      {{/* Header */}}
      <header className="bg-white border-b border-stone-100">
        <div className={{`${{maxWidth}} mx-auto ${{containerPadding}}`}}>
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-4">
              <Hammer className="w-6 h-6 text-amber-500" />
              <div>
                <h1 className={{`${{titleSize}} font-serif text-stone-800`}}>
                  {{name}}
                </h1>
                <p className="mt-1 text-sm text-stone-400">{{description}}</p>
              </div>
            </div>
            <button
              onClick={{handleRetry}}
              className="p-2 text-stone-400 hover:text-stone-600 transition-colors"
              title="Refresh"
            >
              <RefreshCw className={{cn('w-5 h-5', manifest.isLoading && 'animate-spin')}} />
            </button>
          </div>
        </div>
      </header>

      {{/* Main Content */}}
      <main className={{`${{maxWidth}} mx-auto ${{containerPadding}}`}}>
        {{/* Loading State */}}
        {{manifest.isLoading && !manifest.data && (
          <div className="flex items-center justify-center py-12">
            <RefreshCw className="w-6 h-6 text-stone-400 animate-spin" />
            <span className="ml-2 text-stone-500">Loading...</span>
          </div>
        )}}

        {{/* Error State */}}
        {{manifest.error && (
          <div className="p-4 bg-red-50 border border-red-100 rounded-lg">
            <div className="text-sm font-medium text-red-700">Error loading data</div>
            <p className="mt-1 text-xs text-red-500">{{manifest.error.message}}</p>
            <button
              onClick={{handleRetry}}
              className="mt-2 px-3 py-1 text-xs bg-red-100 text-red-700 rounded hover:bg-red-200"
            >
              Retry
            </button>
          </div>
        )}}

        {{/* Status Display */}}
        {{!manifest.isLoading && !manifest.error && (
          <div className="space-y-6">
            {{/* State Card */}}
            <div className="bg-white rounded-lg border border-stone-200 p-6">
              <div className="flex items-center justify-between mb-4">
                <h2 className="text-lg font-medium text-stone-700">Current State</h2>
                <span className="px-2 py-1 text-xs bg-amber-100 text-amber-700 rounded-full">
                  {{status}}
                </span>
              </div>

              {{/* State-specific content */}}{states_ui}
            </div>

            {{/* Operations */}}
            <div className="bg-white rounded-lg border border-stone-200 p-6">
              <h2 className="text-lg font-medium text-stone-700 mb-4">Operations</h2>
              <div className="flex flex-wrap gap-2">
{operations_ui if operations_ui else '                <p className="text-stone-400 text-sm">No operations available</p>'}
              </div>
            </div>

            {{/* Info Panel */}}
            <div className="bg-stone-100 rounded-lg p-4">
              <p className="text-xs text-stone-500">
                States: {", ".join(design.states)} |
                Operations: {len(design.operations)} |
                Generated by Metaphysical Forge
              </p>
            </div>
          </div>
        )}}
      </main>

      {{/* Footer */}}
      <footer className="border-t border-stone-100 bg-white mt-16">
        <div className={{`${{maxWidth}} mx-auto ${{containerPadding}} text-center`}}>
          <p className="text-xs text-stone-300">{design.name}</p>
        </div>
      </footer>
    </div>
  );
}}

export default {comp_name};
"""


# === Projector Artisan ===


PROJECTOR_SYSTEM_PROMPT = """You are Projector, a surface rendering specialist for kgents.

Your role: Generate React components and hooks from agent designs.

A projection includes:
- {Name}Visualization.tsx - Main component with density-aware layout
- use{Name}Query.ts - AGENTESE hooks using useAsyncState pattern
- index.ts - Barrel export

Follow the elastic-ui-patterns:
- Accept density prop (compact/comfortable/spacious)
- Use isMobile/isTablet/isDesktop for responsive behavior
- Include ErrorPanel and LoadingPanel patterns
- Use stone/amber color palette (Living Earth aesthetic)

Respond with JSON:
{
  "files": {
    "index.ts": "...",
    "Visualization.tsx": "...",
    "hooks.ts": "..."
  },
  "summary": "Brief description of what was generated"
}

Do not include any text before or after the JSON. No markdown code fences."""


class ProjectorArtisan:
    """
    The Projector artisan: generates React components and hooks.

    Uses K-gent soul.dialogue() for LLM-powered generation.
    Falls back to template-based generation when K-gent unavailable.
    """

    def __init__(
        self,
        soul: "KgentSoul | None" = None,
        output_dir: str | Path | None = None,
    ) -> None:
        """
        Initialize ProjectorArtisan.

        Args:
            soul: K-gent soul for LLM calls. If None, uses templates.
            output_dir: Base directory for generated code.
        """
        self.soul = soul
        self._output_dir = Path(output_dir) if output_dir else None

    def _get_output_dir(self, commission_id: str) -> Path:
        """Get the output directory for generated components."""
        if self._output_dir:
            return self._output_dir / commission_id / "web"

        # Default to services/forge/_generated/{commission_id}/web/
        current = Path(__file__).parent
        while current.name != "impl" and current.parent != current:
            current = current.parent

        if current.name == "impl":
            return current / "claude" / "services" / "forge" / "_generated" / commission_id / "web"

        # Fallback to temp directory
        import tempfile

        return Path(tempfile.gettempdir()) / "kgents_forge_generated" / commission_id / "web"

    async def project(
        self,
        commission: Commission,
        design: dict[str, Any] | AgentDesign,
        service_output: dict[str, Any],
        herald_output: dict[str, Any],
    ) -> ArtisanOutput:
        """
        Generate React components from design and herald output.

        Args:
            commission: The commission context
            design: The architect's design
            service_output: The smith's output
            herald_output: The herald's output with AGENTESE path

        Returns:
            ArtisanOutput with generated files in output field
        """
        started_at = datetime.now(timezone.utc)

        # Normalize design to AgentDesign
        if isinstance(design, dict):
            design = AgentDesign.from_dict(design)

        # Get AGENTESE path from herald output
        agentese_path = herald_output.get("registered_path", f"world.{design.name.lower()}")

        try:
            if self.soul is not None:
                output = await self._project_with_llm(commission, design, agentese_path)
            else:
                output = self._project_with_templates(commission, design, agentese_path)

            # Write files to disk
            artifact_path = self._write_files(commission.id, output.files)
            output.artifact_path = artifact_path

            return ArtisanOutput(
                artisan=ArtisanType.PROJECTOR,
                status="complete",
                output=output.to_dict(),
                annotation=f"Generated {len(output.files)} React files at {artifact_path}",
                started_at=started_at,
                completed_at=datetime.now(timezone.utc),
            )

        except Exception as e:
            return ArtisanOutput(
                artisan=ArtisanType.PROJECTOR,
                status="failed",
                output=None,
                annotation=f"React generation failed: {e}",
                started_at=started_at,
                completed_at=datetime.now(timezone.utc),
                error=str(e),
            )

    async def _project_with_llm(
        self,
        commission: Commission,
        design: AgentDesign,
        agentese_path: str,
    ) -> ProjectorOutput:
        """Generate React components using K-gent LLM."""
        from agents.k.persona import DialogueMode
        from agents.k.soul import BudgetTier

        comp_name = _derive_component_name(design)
        hook_name = _derive_hook_name(design)

        user_prompt = f"""Generate React components for this agent:

Design:
{json.dumps(design.to_dict(), indent=2)}

AGENTESE Path: {agentese_path}
Component Name: {comp_name}
Hook Name: {hook_name}
Original Intent: {commission.intent}

Remember: Respond ONLY with valid JSON containing the files."""

        # Call K-gent with structured prompt
        assert self.soul is not None
        result = await self.soul.dialogue(
            message=user_prompt,
            mode=DialogueMode.ADVISE,
            budget=BudgetTier.DIALOGUE,
        )

        # Parse the JSON response
        data = self._parse_json_response(result.response)
        files = data.get("files", {})

        # Validate we got the expected files
        if not files:
            return self._project_with_templates(commission, design, agentese_path)

        return ProjectorOutput(
            artifact_path="",  # Set after writing
            files=files,
            summary=data.get("summary", "React components generated by LLM"),
        )

    def _project_with_templates(
        self,
        commission: Commission,
        design: AgentDesign,
        agentese_path: str,
    ) -> ProjectorOutput:
        """Generate React components using templates."""
        comp_name = _derive_component_name(design)
        hook_name = _derive_hook_name(design)

        files = {
            "index.ts": _generate_index_template(design),
            f"{comp_name}.tsx": _generate_visualization_template(design, agentese_path),
            f"{hook_name}.ts": _generate_hooks_template(design, agentese_path),
        }

        return ProjectorOutput(
            artifact_path="",  # Set after writing
            files=files,
            summary=f"Generated React components for {design.name}",
        )

    def _write_files(
        self,
        commission_id: str,
        files: dict[str, str],
    ) -> str:
        """Write generated files to disk. Returns artifact path."""
        output_dir = self._get_output_dir(commission_id)
        os.makedirs(output_dir, exist_ok=True)

        for filename, content in files.items():
            filepath = output_dir / filename
            filepath.write_text(content)

        return str(output_dir)

    def _parse_json_response(self, response: str) -> dict[str, Any]:
        """Parse JSON from LLM response, handling common issues."""
        response = response.strip()
        if response.startswith("```json"):
            response = response[7:]
        if response.startswith("```"):
            response = response[3:]
        if response.endswith("```"):
            response = response[:-3]
        response = response.strip()

        try:
            result = json.loads(response)
            return dict(result) if isinstance(result, dict) else {}
        except json.JSONDecodeError:
            pass

        match = re.search(r"\{[\s\S]*\}", response)
        if match:
            try:
                result = json.loads(match.group())
                return dict(result) if isinstance(result, dict) else {}
            except json.JSONDecodeError:
                pass

        return {}


__all__ = ["ProjectorArtisan", "ProjectorOutput"]
