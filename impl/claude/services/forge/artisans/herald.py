"""
Herald Artisan: The Protocol Specialist.

The Herald makes the agent speakable. Every agent deserves a name. It produces:
- AGENTESE node with @node decorator, contracts, aspect routing
- Request/Response contract types for type safety
- Rendering classes for output formatting

This is real LLM-powered generation via K-gent soul.dialogue().

Usage:
    herald = HeraldArtisan(soul=kgent_soul)
    output = await herald.expose(commission, design, service_output)
    # output.output contains: files, registered_path

"The Herald makes the agent speakable. Every agent deserves a name."

See: spec/protocols/metaphysical-forge.md (Section 2.4)
"""

from __future__ import annotations

import json
import re
from dataclasses import dataclass
from datetime import datetime, timezone
from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from agents.k.soul import KgentSoul

from ..commission import ArtisanOutput, ArtisanType, Commission
from .architect import AgentDesign

# === Herald Output ===


@dataclass
class HeraldOutput:
    """
    Output from the Herald artisan.

    Contains generated AGENTESE node files and registration path.
    """

    files: dict[str, str]  # filename -> content
    registered_path: str  # e.g., "world.todoagent"
    summary: str

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return {
            "files": list(self.files.keys()),
            "file_count": len(self.files),
            "registered_path": self.registered_path,
            "summary": self.summary,
        }


# === Code Templates ===


def _derive_agentese_path(design: AgentDesign) -> str:
    """Derive AGENTESE path from design name."""
    # Convert PascalCase to snake_case and make it an AGENTESE path
    name = design.name
    # Remove "Agent" suffix if present
    if name.endswith("Agent"):
        name = name[:-5]
    # Convert to lowercase with dots (not underscores)
    # e.g., TodoManager -> world.todomanager
    path_part = name.lower()
    return f"world.{path_part}"


def _generate_contracts_template(design: AgentDesign) -> str:
    """Generate contracts.py with Request/Response types."""
    class_name = design.name.replace("Agent", "")

    # Generate request/response classes for each operation
    contract_classes = []
    for op in design.operations:
        op_name = op.get("name", "unknown")
        op_input = op.get("input", "Any")
        op_output = op.get("output", "Any")
        op_desc = op.get("description", "")

        # PascalCase the operation name
        pascal_name = "".join(word.capitalize() for word in op_name.split("_"))

        # Request class
        contract_classes.append(f'''
@dataclass
class {pascal_name}Request:
    """Request for {op_name} operation. {op_desc}"""
    # Input: {op_input}
    # Add fields based on operation requirements
    pass
''')

        # Response class
        contract_classes.append(f'''
@dataclass
class {pascal_name}Response:
    """Response from {op_name} operation."""
    # Output: {op_output}
    success: bool = True
    message: str = ""
''')

    # Add manifest response
    contract_classes.insert(
        0,
        f'''
@dataclass
class {class_name}ManifestResponse:
    """Response for manifest aspect - agent status."""
    name: str
    state: str
    operation_count: int
    description: str = ""
''',
    )

    return f'''"""
{design.name} Contracts: Request/Response types for AGENTESE integration.

Auto-generated by the Metaphysical Forge Herald.
"""

from dataclasses import dataclass
{"".join(contract_classes)}

__all__ = [
    "{class_name}ManifestResponse",
{chr(10).join(f'    "{op.get("name", "unknown").title().replace("_", "")}Request",' for op in design.operations)}
{chr(10).join(f'    "{op.get("name", "unknown").title().replace("_", "")}Response",' for op in design.operations)}
]
'''


def _generate_node_template(design: AgentDesign, agentese_path: str) -> str:
    """Generate node.py with @node decorator and aspect routing."""
    class_name = design.name.replace("Agent", "")
    node_class = f"{class_name}Node"

    # Generate contracts dict for @node decorator
    contracts_entries = [
        "        # Perception aspects (Response only)",
        f'        "manifest": Response({class_name}ManifestResponse),',
    ]
    for op in design.operations:
        op_name = op.get("name", "unknown")
        pascal_name = "".join(word.capitalize() for word in op_name.split("_"))
        contracts_entries.append(
            f'        "{op_name}": Contract({pascal_name}Request, {pascal_name}Response),'
        )

    contracts_block = "\n".join(contracts_entries)

    # Generate aspect routing cases
    aspect_cases = []
    for op in design.operations:
        op_name = op.get("name", "unknown")
        aspect_cases.append(f'''
        elif aspect == "{op_name}":
            return await self._{op_name}(observer, **kwargs)''')

    aspect_routing = "".join(aspect_cases)

    # Generate method stubs for each operation
    method_stubs = []
    for op in design.operations:
        op_name = op.get("name", "unknown")
        pascal_name = "".join(word.capitalize() for word in op_name.split("_"))
        op_desc = op.get("description", "")
        method_stubs.append(f'''
    async def _{op_name}(
        self,
        observer: Observer,
        **kwargs: Any,
    ) -> Renderable:
        """
        AGENTESE: {agentese_path}.{op_name}

        {op_desc}
        """
        # TODO: Implement operation logic
        return BasicRendering(
            f"{op_name} operation executed",
            {{"success": True, "operation": "{op_name}"}},
        )
''')

    methods_block = "".join(method_stubs)

    # Generate imports for contracts
    contract_imports = [f"{class_name}ManifestResponse"]
    for op in design.operations:
        pascal_name = "".join(word.capitalize() for word in op.get("name", "unknown").split("_"))
        contract_imports.extend([f"{pascal_name}Request", f"{pascal_name}Response"])

    imports_line = ", ".join(contract_imports)

    return f'''"""
{design.name} AGENTESE Node: @node("{agentese_path}")

AGENTESE paths:
- {agentese_path}.manifest - Agent status
{chr(10).join(f"- {agentese_path}.{op.get('name', 'unknown')} - {op.get('description', '')}" for op in design.operations)}

Design Rationale:
{design.rationale}

Auto-generated by the Metaphysical Forge Herald.
See: docs/skills/agentese-node-registration.md
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import TYPE_CHECKING, Any

from protocols.agentese.contract import Contract, Response
from protocols.agentese.node import (
    BaseLogosNode,
    BasicRendering,
    Observer,
    Renderable,
)
from protocols.agentese.registry import node

from .contracts_ext import {imports_line}
from .polynomial import {design.name}Polynomial, {design.name}State
from .service import {class_name}Service

if TYPE_CHECKING:
    pass


# === Rendering Types ===


@dataclass(frozen=True)
class {class_name}ManifestRendering:
    """Rendering for agent manifest."""

    service: {class_name}Service

    def to_dict(self) -> dict[str, Any]:
        return {{
            "type": "{agentese_path.replace(".", "_")}_manifest",
            "name": "{design.name}",
            "state": self.service.state.value,
            "description": "{design.description}",
        }}

    def to_text(self) -> str:
        return f"""
{design.name}
==============
State: {{self.service.state.value}}
{design.description}
"""


# === {node_class} ===


@node(
    "{agentese_path}",
    description="{design.description}",
    contracts={{
{contracts_block}
    }},
)
class {node_class}(BaseLogosNode):
    """
    AGENTESE node for {design.name}.

    States: {", ".join(design.states)}
    Operations: {", ".join(op.get("name", "?") for op in design.operations)}

    Laws:
{chr(10).join(f"    - {law}" for law in design.laws)}
    """

    def __init__(self, service: {class_name}Service | None = None) -> None:
        """Initialize with optional service dependency."""
        self._service = service or {class_name}Service()

    @property
    def handle(self) -> str:
        """The AGENTESE path for this node."""
        return "{agentese_path}"

    async def manifest(self, observer: Observer) -> Renderable:
        """
        AGENTESE: {agentese_path}.manifest

        Returns agent status.
        """
        return {class_name}ManifestRendering(self._service)

    async def _invoke_aspect(
        self,
        aspect: str,
        observer: Observer,
        **kwargs: Any,
    ) -> Renderable:
        """Route aspect invocation to appropriate handler."""
        if aspect == "manifest":
            return await self.manifest(observer){aspect_routing}
        else:
            return BasicRendering(
                f"Unknown aspect: {{aspect}}",
                {{"error": "unknown_aspect", "aspect": aspect}},
            )
{methods_block}

__all__ = ["{node_class}", "{class_name}ManifestRendering"]
'''


# === Herald Artisan ===


HERALD_SYSTEM_PROMPT = """You are Herald, an AGENTESE protocol specialist for kgents.

Your role: Generate AGENTESE node files from agent designs and service outputs.

An AGENTESE node has:
- @node decorator with path, description, contracts
- Contracts dict mapping aspects to Request/Response types
- _invoke_aspect method for routing aspects to handlers
- Rendering classes for output formatting (to_dict and to_text)

Code Style:
- Use dataclasses for data types
- Type hints on all functions
- Docstrings with AGENTESE path comments
- Follow the Observer pattern (all methods receive observer: Observer)

Respond with JSON containing the generated files:
{
  "files": {
    "node.py": "...",
    "contracts_ext.py": "..."
  },
  "registered_path": "world.agentname",
  "summary": "Brief description of what was generated"
}

Do not include any text before or after the JSON. No markdown code fences."""


class HeraldArtisan:
    """
    The Herald artisan: generates AGENTESE nodes with contracts.

    Uses K-gent soul.dialogue() for LLM-powered generation.
    Falls back to template-based generation when K-gent unavailable.
    """

    def __init__(self, soul: "KgentSoul | None" = None) -> None:
        """
        Initialize HeraldArtisan.

        Args:
            soul: K-gent soul for LLM calls. If None, uses templates.
        """
        self.soul = soul

    async def expose(
        self,
        commission: Commission,
        design: dict[str, Any] | AgentDesign,
        service_output: dict[str, Any],
    ) -> ArtisanOutput:
        """
        Generate AGENTESE node from design and service output.

        Args:
            commission: The commission context
            design: The architect's design (dict or AgentDesign)
            service_output: The smith's output with file paths

        Returns:
            ArtisanOutput with generated files in output field
        """
        started_at = datetime.now(timezone.utc)

        # Normalize design to AgentDesign
        if isinstance(design, dict):
            design = AgentDesign.from_dict(design)

        try:
            if self.soul is not None:
                output = await self._expose_with_llm(commission, design, service_output)
            else:
                output = self._expose_with_templates(commission, design, service_output)

            return ArtisanOutput(
                artisan=ArtisanType.HERALD,
                status="complete",
                output=output.to_dict(),
                annotation=f"Registered {output.registered_path} with {len(output.files)} files",
                started_at=started_at,
                completed_at=datetime.now(timezone.utc),
            )

        except Exception as e:
            return ArtisanOutput(
                artisan=ArtisanType.HERALD,
                status="failed",
                output=None,
                annotation=f"AGENTESE generation failed: {e}",
                started_at=started_at,
                completed_at=datetime.now(timezone.utc),
                error=str(e),
            )

    async def _expose_with_llm(
        self,
        commission: Commission,
        design: AgentDesign,
        service_output: dict[str, Any],
    ) -> HeraldOutput:
        """Generate AGENTESE node using K-gent LLM."""
        from agents.k.persona import DialogueMode
        from agents.k.soul import BudgetTier

        # Build the user prompt
        user_prompt = f"""Generate AGENTESE node files for this agent:

Design:
{json.dumps(design.to_dict(), indent=2)}

Service Output Path: {service_output.get("path", "unknown")}
Original Intent: {commission.intent}

Remember: Respond ONLY with valid JSON containing the files."""

        # Call K-gent with structured prompt
        assert self.soul is not None  # Caller checks this
        result = await self.soul.dialogue(
            message=user_prompt,
            mode=DialogueMode.ADVISE,
            budget=BudgetTier.DIALOGUE,
        )

        # Parse the JSON response
        data = self._parse_json_response(result.response)
        files = data.get("files", {})
        registered_path = data.get("registered_path", _derive_agentese_path(design))

        # Validate we got the expected files
        if not files:
            # Fallback to templates if LLM didn't produce valid output
            return self._expose_with_templates(commission, design, service_output)

        return HeraldOutput(
            files=files,
            registered_path=registered_path,
            summary=data.get("summary", "AGENTESE node generated by LLM"),
        )

    def _expose_with_templates(
        self,
        commission: Commission,
        design: AgentDesign,
        service_output: dict[str, Any],
    ) -> HeraldOutput:
        """Generate AGENTESE node using templates."""
        agentese_path = _derive_agentese_path(design)

        files = {
            "node.py": _generate_node_template(design, agentese_path),
            "contracts_ext.py": _generate_contracts_template(design),
        }

        return HeraldOutput(
            files=files,
            registered_path=agentese_path,
            summary=f"Generated AGENTESE node for {design.name} at {agentese_path}",
        )

    def _parse_json_response(self, response: str) -> dict[str, Any]:
        """Parse JSON from LLM response, handling common issues."""
        # Strip any markdown code fences
        response = response.strip()
        if response.startswith("```json"):
            response = response[7:]
        if response.startswith("```"):
            response = response[3:]
        if response.endswith("```"):
            response = response[:-3]
        response = response.strip()

        # Try direct parse
        try:
            result = json.loads(response)
            return dict(result) if isinstance(result, dict) else {}
        except json.JSONDecodeError:
            pass

        # Try to find JSON object in response
        match = re.search(r"\{[\s\S]*\}", response)
        if match:
            try:
                result = json.loads(match.group())
                return dict(result) if isinstance(result, dict) else {}
            except json.JSONDecodeError:
                pass

        # Fallback: return empty dict
        return {}


__all__ = ["HeraldArtisan", "HeraldOutput"]
