"""
Smith Artisan: The Implementer.

The Smith turns categorical blueprints into running code. It produces:
- Service module structure (services/<name>/)
- Business logic implementation (service.py)
- PolyAgent implementation (polynomial.py)
- Module exports (__init__.py)

This is real LLM-powered code generation via K-gent soul.dialogue().

Usage:
    smith = SmithArtisan(soul=kgent_soul)
    output = await smith.implement(commission, architect_design)
    # output.output contains: path, files generated

"The Smith turns categorical blueprints into running code."

See: spec/protocols/metaphysical-forge.md (Section 2.3)
"""

from __future__ import annotations

import json
import os
import re
from dataclasses import dataclass
from datetime import datetime, timezone
from pathlib import Path
from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from agents.k.soul import KgentSoul

from ..commission import ArtisanOutput, ArtisanType, Commission
from .architect import AgentDesign

# === Smith Output ===


@dataclass
class SmithOutput:
    """
    Output from the Smith artisan.

    Contains generated file paths and code.
    """

    artifact_path: str
    files: dict[str, str]  # filename -> content
    summary: str

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return {
            "path": self.artifact_path,
            "files": list(self.files.keys()),
            "file_count": len(self.files),
            "summary": self.summary,
        }


# === Code Templates ===


def _generate_init_template(design: AgentDesign) -> str:
    """Generate __init__.py exports."""
    class_name = design.name.replace("Agent", "") + "Service"
    return f'''"""
{design.name}: {design.description}

Auto-generated by the Metaphysical Forge.
"""

from .service import {class_name}
from .polynomial import {design.name}Polynomial

__all__ = [
    "{class_name}",
    "{design.name}Polynomial",
]
'''


def _generate_polynomial_template(design: AgentDesign) -> str:
    """Generate polynomial.py with PolyAgent definition."""
    # Generate state enum entries
    state_entries = "\n".join(f'    {s} = "{s.lower()}"' for s in design.states)

    # Generate transition dict entries
    transition_entries = []
    for state, targets in design.transitions.items():
        targets_str = ", ".join(f"{design.name}State.{t}" for t in targets)
        transition_entries.append(f"    {design.name}State.{state}: [{targets_str}],")
    transitions_code = "\n".join(transition_entries)

    return f'''"""
{design.name} Polynomial: State machine definition.

States: {", ".join(design.states)}
Initial: {design.initial_state}

Auto-generated by the Metaphysical Forge.
"""

from dataclasses import dataclass
from enum import Enum
from typing import Any


class {design.name}State(str, Enum):
    """States for {design.name}."""
{state_entries}


# State transition map
{design.name.upper()}_TRANSITIONS: dict[{design.name}State, list[{design.name}State]] = {{
{transitions_code}
}}


@dataclass
class {design.name}Polynomial:
    """
    PolyAgent polynomial for {design.name}.

    Laws:
{chr(10).join(f"    - {law}" for law in design.laws)}
    """

    state: {design.name}State = {design.name}State.{design.initial_state}

    def can_transition(self, to_state: {design.name}State) -> bool:
        """Check if transition is valid."""
        valid_transitions = {design.name.upper()}_TRANSITIONS.get(self.state, [])
        return to_state in valid_transitions

    def transition(self, to_state: {design.name}State) -> bool:
        """Attempt state transition. Returns True if successful."""
        if self.can_transition(to_state):
            self.state = to_state
            return True
        return False


__all__ = ["{design.name}State", "{design.name}Polynomial", "{design.name.upper()}_TRANSITIONS"]
'''


def _generate_service_template(design: AgentDesign) -> str:
    """Generate service.py with business logic."""
    class_name = design.name.replace("Agent", "") + "Service"

    # Generate operation methods
    operation_methods = []
    for op in design.operations:
        op_name = op.get("name", "unknown")
        op_input = op.get("input", "Any")
        op_output = op.get("output", "Any")
        op_desc = op.get("description", "")

        operation_methods.append(f'''
    async def {op_name}(self, input_data: {op_input}) -> {op_output}:
        """
        {op_desc}

        TODO: Implement based on design intent.
        """
        # Placeholder implementation
        raise NotImplementedError("{op_name} not yet implemented")
''')

    return f'''"""
{class_name}: Business logic for {design.name}.

{design.description}

Design Rationale:
{design.rationale}

Auto-generated by the Metaphysical Forge.
"""

from __future__ import annotations

from typing import Any

from .polynomial import {design.name}Polynomial, {design.name}State


class {class_name}:
    """
    Service implementation for {design.name}.

    States: {", ".join(design.states)}
    Operations: {", ".join(op.get("name", "?") for op in design.operations)}
    """

    def __init__(self) -> None:
        """Initialize the service."""
        self._polynomial = {design.name}Polynomial()

    @property
    def state(self) -> {design.name}State:
        """Current state."""
        return self._polynomial.state

    def transition(self, to_state: {design.name}State) -> bool:
        """Attempt state transition."""
        return self._polynomial.transition(to_state)
{"".join(operation_methods)}

__all__ = ["{class_name}"]
'''


# === Smith Artisan ===


SMITH_SYSTEM_PROMPT = """You are Smith, a code generation specialist for the kgents project.

Your role: Generate Python service code from categorical designs (AgentDesign).

You will receive a design specification with:
- name: Agent name
- description: What the agent does
- states: List of states
- transitions: Valid state transitions
- operations: Operations with input/output types
- laws: Categorical laws to honor

Generate three Python files:
1. __init__.py - exports
2. polynomial.py - PolyAgent state machine
3. service.py - business logic

Code Style:
- Use dataclasses for data types
- Use Enum for states
- Type hints on all functions
- Docstrings on all public methods
- Follow PEP 8

Respond with JSON containing the three files:
{
  "files": {
    "__init__.py": "...",
    "polynomial.py": "...",
    "service.py": "..."
  },
  "summary": "Brief description of what was generated"
}

Do not include any text before or after the JSON. No markdown code fences."""


class SmithArtisan:
    """
    The Smith artisan: generates service implementation code.

    Uses K-gent soul.dialogue() for LLM-powered code generation.
    Falls back to template-based generation when K-gent unavailable.
    """

    def __init__(
        self,
        soul: "KgentSoul | None" = None,
        output_dir: str | Path | None = None,
    ) -> None:
        """
        Initialize SmithArtisan.

        Args:
            soul: K-gent soul for LLM calls. If None, uses templates.
            output_dir: Base directory for generated code. Defaults to
                        services/forge/_generated/
        """
        self.soul = soul
        self._output_dir = Path(output_dir) if output_dir else None

    def _get_output_dir(self) -> Path:
        """Get the output directory for generated code."""
        if self._output_dir:
            return self._output_dir

        # Default to services/forge/_generated/
        # Find the impl/claude directory
        current = Path(__file__).parent
        while current.name != "impl" and current.parent != current:
            current = current.parent

        if current.name == "impl":
            return current / "claude" / "services" / "forge" / "_generated"

        # Fallback to temp directory
        import tempfile

        return Path(tempfile.gettempdir()) / "kgents_forge_generated"

    async def implement(
        self,
        commission: Commission,
        design: dict[str, Any] | AgentDesign,
    ) -> ArtisanOutput:
        """
        Generate service implementation from design.

        Args:
            commission: The commission context
            design: The architect's design (dict or AgentDesign)

        Returns:
            ArtisanOutput with generated files in output field
        """
        started_at = datetime.now(timezone.utc)

        # Normalize design to AgentDesign
        if isinstance(design, dict):
            design = AgentDesign.from_dict(design)

        try:
            if self.soul is not None:
                output = await self._implement_with_llm(commission, design)
            else:
                output = self._implement_with_templates(commission, design)

            # Write files to disk
            artifact_path = self._write_files(commission, output.files)
            output.artifact_path = artifact_path

            return ArtisanOutput(
                artisan=ArtisanType.SMITH,
                status="complete",
                output=output.to_dict(),
                annotation=f"Generated {len(output.files)} files at {artifact_path}",
                started_at=started_at,
                completed_at=datetime.now(timezone.utc),
            )

        except Exception as e:
            return ArtisanOutput(
                artisan=ArtisanType.SMITH,
                status="failed",
                output=None,
                annotation=f"Code generation failed: {e}",
                started_at=started_at,
                completed_at=datetime.now(timezone.utc),
                error=str(e),
            )

    async def _implement_with_llm(
        self,
        commission: Commission,
        design: AgentDesign,
    ) -> SmithOutput:
        """Generate code using K-gent LLM."""
        from agents.k.persona import DialogueMode
        from agents.k.soul import BudgetTier

        # Build the user prompt from design
        user_prompt = f"""Generate Python service code for this agent design:

{json.dumps(design.to_dict(), indent=2)}

Original intent: {commission.intent}

Remember: Respond ONLY with valid JSON containing the three files."""

        # Call K-gent with structured prompt
        assert self.soul is not None  # Caller checks this
        result = await self.soul.dialogue(
            message=user_prompt,
            mode=DialogueMode.ADVISE,
            budget=BudgetTier.DIALOGUE,
        )

        # Parse the JSON response
        data = self._parse_json_response(result.response)
        files = data.get("files", {})
        summary = data.get("summary", "Code generated by LLM")

        # Validate we got the expected files
        if not files:
            # Fallback to templates if LLM didn't produce valid output
            return self._implement_with_templates(commission, design)

        return SmithOutput(
            artifact_path="",  # Set after writing
            files=files,
            summary=summary,
        )

    def _implement_with_templates(
        self,
        commission: Commission,
        design: AgentDesign,
    ) -> SmithOutput:
        """Generate code using templates when K-gent unavailable."""
        files = {
            "__init__.py": _generate_init_template(design),
            "polynomial.py": _generate_polynomial_template(design),
            "service.py": _generate_service_template(design),
        }

        return SmithOutput(
            artifact_path="",  # Set after writing
            files=files,
            summary=f"Generated service for {design.name} using templates",
        )

    def _write_files(
        self,
        commission: Commission,
        files: dict[str, str],
    ) -> str:
        """Write generated files to disk. Returns artifact path."""
        # Create output directory
        output_base = self._get_output_dir()
        commission_dir = output_base / commission.id

        os.makedirs(commission_dir, exist_ok=True)

        # Write each file
        for filename, content in files.items():
            filepath = commission_dir / filename
            filepath.write_text(content)

        return str(commission_dir)

    def _parse_json_response(self, response: str) -> dict[str, Any]:
        """Parse JSON from LLM response, handling common issues."""
        # Strip any markdown code fences
        response = response.strip()
        if response.startswith("```json"):
            response = response[7:]
        if response.startswith("```"):
            response = response[3:]
        if response.endswith("```"):
            response = response[:-3]
        response = response.strip()

        # Try direct parse
        try:
            result = json.loads(response)
            return dict(result) if isinstance(result, dict) else {}
        except json.JSONDecodeError:
            pass

        # Try to find JSON object in response
        match = re.search(r"\{[\s\S]*\}", response)
        if match:
            try:
                result = json.loads(match.group())
                return dict(result) if isinstance(result, dict) else {}
            except json.JSONDecodeError:
                pass

        # Fallback: return empty dict
        return {}


__all__ = ["SmithArtisan", "SmithOutput"]
