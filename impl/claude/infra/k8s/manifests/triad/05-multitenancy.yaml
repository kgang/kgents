# Multi-Tenant Infrastructure for kgents SaaS
# Production-grade Row-Level Security (RLS) implementation
#
# AGENTESE: concept.isolation.tenant
#
# This implements:
# 1. Tenants table (source of truth for organizations)
# 2. Users table (tenant members with roles)
# 3. API Keys table (programmatic access)
# 4. RLS policies on all tenant-scoped tables
# 5. Session context functions for tenant isolation
#
# Security Model:
# - Every tenant-scoped query automatically filters by tenant_id
# - RLS policies use session variables (current_setting)
# - API Gateway sets tenant context via SET SESSION
# - Superuser bypass available for admin operations
#
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: triad-postgres-multitenancy
  namespace: kgents-triad
  labels:
    app.kubernetes.io/name: triad-postgres
    app.kubernetes.io/component: multitenancy
    app.kubernetes.io/part-of: kgents
    kgents.io/saas-component: tenant-isolation
data:
  05-tenants.sql: |
    -- ============================================================
    -- TENANTS TABLE: Source of Truth for Organizations
    -- ============================================================
    --
    -- Each tenant represents an organization/customer in the SaaS.
    -- Tenants own all resources (memories, sessions, API keys, etc.)
    --
    -- Billing Integration:
    -- - stripe_customer_id: Links to Stripe for payments
    -- - subscription_tier: Current plan (free, pro, enterprise)
    -- - subscription_status: Stripe subscription status
    --
    -- Usage Tracking:
    -- - tokens_used_month: Current month's token consumption
    -- - tokens_limit_month: Monthly limit based on tier
    -- - rate_limit_rpm: Requests per minute limit
    --
    -- ============================================================

    CREATE TABLE IF NOT EXISTS tenants (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

        -- Identity
        name TEXT NOT NULL,
        slug TEXT NOT NULL UNIQUE,  -- URL-safe identifier

        -- Billing (Stripe integration)
        stripe_customer_id TEXT UNIQUE,
        subscription_tier TEXT NOT NULL DEFAULT 'free',
        subscription_status TEXT NOT NULL DEFAULT 'active',

        -- Usage & Limits
        tokens_used_month BIGINT NOT NULL DEFAULT 0,
        tokens_limit_month BIGINT NOT NULL DEFAULT 10000,  -- Free tier default
        rate_limit_rpm INTEGER NOT NULL DEFAULT 60,  -- Requests per minute

        -- Metadata
        settings JSONB NOT NULL DEFAULT '{}',
        created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

        -- Soft delete support
        deleted_at TIMESTAMPTZ,

        -- Constraints
        CONSTRAINT valid_tier CHECK (subscription_tier IN (
            'free', 'pro', 'enterprise', 'custom'
        )),
        CONSTRAINT valid_subscription_status CHECK (subscription_status IN (
            'active', 'past_due', 'canceled', 'trialing', 'paused'
        )),
        CONSTRAINT positive_limits CHECK (
            tokens_limit_month >= 0 AND rate_limit_rpm > 0
        )
    );

    -- Indexes for common queries
    CREATE INDEX IF NOT EXISTS idx_tenants_slug ON tenants(slug) WHERE deleted_at IS NULL;
    CREATE INDEX IF NOT EXISTS idx_tenants_stripe ON tenants(stripe_customer_id) WHERE stripe_customer_id IS NOT NULL;
    CREATE INDEX IF NOT EXISTS idx_tenants_tier ON tenants(subscription_tier) WHERE deleted_at IS NULL;

    -- Updated_at trigger
    DROP TRIGGER IF EXISTS tenants_updated_at ON tenants;
    CREATE TRIGGER tenants_updated_at
        BEFORE UPDATE ON tenants
        FOR EACH ROW
        EXECUTE FUNCTION update_updated_at();

    -- CDC outbox trigger
    DROP TRIGGER IF EXISTS tenants_outbox_trigger ON tenants;
    CREATE TRIGGER tenants_outbox_trigger
        AFTER INSERT OR UPDATE OR DELETE ON tenants
        FOR EACH ROW EXECUTE FUNCTION outbox_trigger();

    COMMENT ON TABLE tenants IS 'SaaS tenant organizations - source of truth for multi-tenancy';

  06-users.sql: |
    -- ============================================================
    -- USERS TABLE: Tenant Members with Role-Based Access
    -- ============================================================
    --
    -- Users belong to exactly one tenant (organization).
    -- Role hierarchy: owner > admin > member > readonly
    --
    -- Authentication:
    -- - External auth provider (Auth0/Clerk) via external_auth_id
    -- - Email verification status tracked
    --
    -- ============================================================

    CREATE TABLE IF NOT EXISTS users (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,

        -- Identity
        email TEXT NOT NULL,
        name TEXT,

        -- External Auth (Auth0, Clerk, etc.)
        external_auth_id TEXT UNIQUE,
        external_auth_provider TEXT,  -- 'auth0', 'clerk', 'google', etc.

        -- Role & Status
        role TEXT NOT NULL DEFAULT 'member',
        is_active BOOLEAN NOT NULL DEFAULT TRUE,
        email_verified BOOLEAN NOT NULL DEFAULT FALSE,

        -- Timestamps
        last_login_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

        -- Soft delete
        deleted_at TIMESTAMPTZ,

        -- Constraints
        CONSTRAINT valid_role CHECK (role IN ('owner', 'admin', 'member', 'readonly')),
        CONSTRAINT unique_email_per_tenant UNIQUE (tenant_id, email)
    );

    -- Indexes
    CREATE INDEX IF NOT EXISTS idx_users_tenant ON users(tenant_id) WHERE deleted_at IS NULL;
    CREATE INDEX IF NOT EXISTS idx_users_email ON users(email) WHERE deleted_at IS NULL;
    CREATE INDEX IF NOT EXISTS idx_users_external_auth ON users(external_auth_id) WHERE external_auth_id IS NOT NULL;

    -- Updated_at trigger
    DROP TRIGGER IF EXISTS users_updated_at ON users;
    CREATE TRIGGER users_updated_at
        BEFORE UPDATE ON users
        FOR EACH ROW
        EXECUTE FUNCTION update_updated_at();

    -- CDC outbox trigger
    DROP TRIGGER IF EXISTS users_outbox_trigger ON users;
    CREATE TRIGGER users_outbox_trigger
        AFTER INSERT OR UPDATE OR DELETE ON users
        FOR EACH ROW EXECUTE FUNCTION outbox_trigger();

    COMMENT ON TABLE users IS 'Tenant members with role-based access control';

  07-api-keys.sql: |
    -- ============================================================
    -- API_KEYS TABLE: Programmatic Access Credentials
    -- ============================================================
    --
    -- API keys provide programmatic access to the kgents API.
    -- Each key belongs to a tenant and optionally a specific user.
    --
    -- Security:
    -- - Key hash stored, not plaintext (key_hash)
    -- - Key prefix stored for identification (key_prefix: kg_xxx)
    -- - Scopes limit what the key can do
    -- - Expiration support for security rotation
    --
    -- ============================================================

    CREATE TABLE IF NOT EXISTS api_keys (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
        user_id UUID REFERENCES users(id) ON DELETE SET NULL,

        -- Key Identity (never store the full key!)
        key_prefix TEXT NOT NULL,  -- First 8 chars: "kg_abc12"
        key_hash TEXT NOT NULL,    -- SHA-256 hash of full key
        name TEXT NOT NULL,        -- Human-readable name

        -- Permissions
        scopes TEXT[] NOT NULL DEFAULT ARRAY['read', 'write'],

        -- Limits (can override tenant defaults)
        rate_limit_rpm INTEGER,  -- NULL = use tenant default
        tokens_limit_request INTEGER,  -- Max tokens per request

        -- Expiration
        expires_at TIMESTAMPTZ,

        -- Activity tracking
        last_used_at TIMESTAMPTZ,
        use_count BIGINT NOT NULL DEFAULT 0,

        -- Status
        is_active BOOLEAN NOT NULL DEFAULT TRUE,
        revoked_at TIMESTAMPTZ,
        revoked_by UUID REFERENCES users(id),

        -- Timestamps
        created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

        -- Constraints
        CONSTRAINT valid_scopes CHECK (
            scopes <@ ARRAY['read', 'write', 'admin', 'billing']::TEXT[]
        ),
        CONSTRAINT key_prefix_format CHECK (key_prefix ~ '^kg_[a-z0-9]{5}$')
    );

    -- Indexes
    CREATE UNIQUE INDEX IF NOT EXISTS idx_api_keys_hash ON api_keys(key_hash);
    CREATE INDEX IF NOT EXISTS idx_api_keys_prefix ON api_keys(key_prefix);
    CREATE INDEX IF NOT EXISTS idx_api_keys_tenant ON api_keys(tenant_id) WHERE is_active = TRUE;
    CREATE INDEX IF NOT EXISTS idx_api_keys_user ON api_keys(user_id) WHERE user_id IS NOT NULL;

    -- Function to update last_used tracking
    CREATE OR REPLACE FUNCTION update_api_key_usage(p_key_id UUID) RETURNS VOID AS $$
    BEGIN
        UPDATE api_keys
        SET last_used_at = NOW(), use_count = use_count + 1
        WHERE id = p_key_id;
    END;
    $$ LANGUAGE plpgsql;

    -- CDC outbox trigger
    DROP TRIGGER IF EXISTS api_keys_outbox_trigger ON api_keys;
    CREATE TRIGGER api_keys_outbox_trigger
        AFTER INSERT OR UPDATE OR DELETE ON api_keys
        FOR EACH ROW EXECUTE FUNCTION outbox_trigger();

    COMMENT ON TABLE api_keys IS 'API keys for programmatic access - key hash stored, not plaintext';

  08-rls-functions.sql: |
    -- ============================================================
    -- RLS CONTEXT FUNCTIONS: Tenant Isolation Infrastructure
    -- ============================================================
    --
    -- These functions manage tenant context for RLS policies.
    -- The API Gateway (Kong) sets these at the start of each request.
    --
    -- Security Model:
    -- 1. Kong validates JWT/API key and extracts tenant_id
    -- 2. Kong calls set_tenant_context(tenant_id) via pgbouncer
    -- 3. All subsequent queries are automatically tenant-filtered
    -- 4. Connection is returned to pool with context cleared
    --
    -- ============================================================

    -- Set the current tenant context (called by API Gateway)
    CREATE OR REPLACE FUNCTION set_tenant_context(p_tenant_id UUID) RETURNS VOID AS $$
    BEGIN
        -- Set session variable that RLS policies will check
        PERFORM set_config('app.current_tenant_id', p_tenant_id::TEXT, TRUE);
    END;
    $$ LANGUAGE plpgsql SECURITY DEFINER;

    -- Get the current tenant context (used by RLS policies)
    CREATE OR REPLACE FUNCTION current_tenant_id() RETURNS UUID AS $$
    BEGIN
        RETURN NULLIF(current_setting('app.current_tenant_id', TRUE), '')::UUID;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END;
    $$ LANGUAGE plpgsql STABLE;

    -- Clear tenant context (called when returning connection to pool)
    CREATE OR REPLACE FUNCTION clear_tenant_context() RETURNS VOID AS $$
    BEGIN
        PERFORM set_config('app.current_tenant_id', '', TRUE);
    END;
    $$ LANGUAGE plpgsql SECURITY DEFINER;

    -- Check if caller has admin bypass (for admin operations)
    CREATE OR REPLACE FUNCTION is_admin_bypass() RETURNS BOOLEAN AS $$
    BEGIN
        RETURN COALESCE(current_setting('app.admin_bypass', TRUE), 'false') = 'true';
    END;
    $$ LANGUAGE plpgsql STABLE;

    -- Enable admin bypass (for migrations, admin queries)
    CREATE OR REPLACE FUNCTION enable_admin_bypass() RETURNS VOID AS $$
    BEGIN
        PERFORM set_config('app.admin_bypass', 'true', TRUE);
    END;
    $$ LANGUAGE plpgsql SECURITY DEFINER;

    -- Disable admin bypass
    CREATE OR REPLACE FUNCTION disable_admin_bypass() RETURNS VOID AS $$
    BEGIN
        PERFORM set_config('app.admin_bypass', 'false', TRUE);
    END;
    $$ LANGUAGE plpgsql SECURITY DEFINER;

    COMMENT ON FUNCTION set_tenant_context IS 'Set tenant context for RLS - called by API Gateway';
    COMMENT ON FUNCTION current_tenant_id IS 'Get current tenant ID for RLS policies';
    COMMENT ON FUNCTION clear_tenant_context IS 'Clear tenant context when returning connection to pool';

  09-rls-policies.sql: |
    -- ============================================================
    -- ROW-LEVEL SECURITY POLICIES
    -- ============================================================
    --
    -- Enable RLS on all tenant-scoped tables.
    -- Policies check current_tenant_id() for isolation.
    --
    -- Policy naming convention:
    -- - {table}_{operation}_{scope}
    -- - e.g., memories_select_tenant, api_keys_insert_tenant
    --
    -- ============================================================

    -- --------------------------------------------------------------
    -- TENANTS TABLE: Only admins can see all tenants
    -- Regular users can only see their own tenant
    -- --------------------------------------------------------------
    ALTER TABLE tenants ENABLE ROW LEVEL SECURITY;
    ALTER TABLE tenants FORCE ROW LEVEL SECURITY;

    DROP POLICY IF EXISTS tenants_select_own ON tenants;
    CREATE POLICY tenants_select_own ON tenants
        FOR SELECT
        USING (
            is_admin_bypass() OR
            id = current_tenant_id()
        );

    DROP POLICY IF EXISTS tenants_update_own ON tenants;
    CREATE POLICY tenants_update_own ON tenants
        FOR UPDATE
        USING (
            is_admin_bypass() OR
            id = current_tenant_id()
        );

    -- Only admins can insert/delete tenants
    DROP POLICY IF EXISTS tenants_insert_admin ON tenants;
    CREATE POLICY tenants_insert_admin ON tenants
        FOR INSERT
        WITH CHECK (is_admin_bypass());

    DROP POLICY IF EXISTS tenants_delete_admin ON tenants;
    CREATE POLICY tenants_delete_admin ON tenants
        FOR DELETE
        USING (is_admin_bypass());

    -- --------------------------------------------------------------
    -- USERS TABLE: Users can see members of their tenant
    -- --------------------------------------------------------------
    ALTER TABLE users ENABLE ROW LEVEL SECURITY;
    ALTER TABLE users FORCE ROW LEVEL SECURITY;

    DROP POLICY IF EXISTS users_select_tenant ON users;
    CREATE POLICY users_select_tenant ON users
        FOR SELECT
        USING (
            is_admin_bypass() OR
            tenant_id = current_tenant_id()
        );

    DROP POLICY IF EXISTS users_insert_tenant ON users;
    CREATE POLICY users_insert_tenant ON users
        FOR INSERT
        WITH CHECK (
            is_admin_bypass() OR
            tenant_id = current_tenant_id()
        );

    DROP POLICY IF EXISTS users_update_tenant ON users;
    CREATE POLICY users_update_tenant ON users
        FOR UPDATE
        USING (
            is_admin_bypass() OR
            tenant_id = current_tenant_id()
        );

    DROP POLICY IF EXISTS users_delete_tenant ON users;
    CREATE POLICY users_delete_tenant ON users
        FOR DELETE
        USING (
            is_admin_bypass() OR
            tenant_id = current_tenant_id()
        );

    -- --------------------------------------------------------------
    -- API_KEYS TABLE: Tenant-scoped access
    -- --------------------------------------------------------------
    ALTER TABLE api_keys ENABLE ROW LEVEL SECURITY;
    ALTER TABLE api_keys FORCE ROW LEVEL SECURITY;

    DROP POLICY IF EXISTS api_keys_select_tenant ON api_keys;
    CREATE POLICY api_keys_select_tenant ON api_keys
        FOR SELECT
        USING (
            is_admin_bypass() OR
            tenant_id = current_tenant_id()
        );

    DROP POLICY IF EXISTS api_keys_insert_tenant ON api_keys;
    CREATE POLICY api_keys_insert_tenant ON api_keys
        FOR INSERT
        WITH CHECK (
            is_admin_bypass() OR
            tenant_id = current_tenant_id()
        );

    DROP POLICY IF EXISTS api_keys_update_tenant ON api_keys;
    CREATE POLICY api_keys_update_tenant ON api_keys
        FOR UPDATE
        USING (
            is_admin_bypass() OR
            tenant_id = current_tenant_id()
        );

    DROP POLICY IF EXISTS api_keys_delete_tenant ON api_keys;
    CREATE POLICY api_keys_delete_tenant ON api_keys
        FOR DELETE
        USING (
            is_admin_bypass() OR
            tenant_id = current_tenant_id()
        );

  10-existing-tables-rls.sql: |
    -- ============================================================
    -- ADD TENANT_ID TO EXISTING TABLES + RLS
    -- ============================================================
    --
    -- Migrate existing tables to multi-tenant model:
    -- 1. Add tenant_id column
    -- 2. Enable RLS
    -- 3. Create isolation policies
    --
    -- ============================================================

    -- --------------------------------------------------------------
    -- MEMORIES TABLE: Add tenant isolation
    -- --------------------------------------------------------------
    DO $$
    BEGIN
        -- Add tenant_id if not exists
        IF NOT EXISTS (
            SELECT 1 FROM information_schema.columns
            WHERE table_name = 'memories' AND column_name = 'tenant_id'
        ) THEN
            ALTER TABLE memories ADD COLUMN tenant_id UUID;
            CREATE INDEX IF NOT EXISTS idx_memories_tenant ON memories(tenant_id);
        END IF;
    END $$;

    ALTER TABLE memories ENABLE ROW LEVEL SECURITY;
    ALTER TABLE memories FORCE ROW LEVEL SECURITY;

    DROP POLICY IF EXISTS memories_tenant_isolation ON memories;
    CREATE POLICY memories_tenant_isolation ON memories
        FOR ALL
        USING (
            is_admin_bypass() OR
            tenant_id = current_tenant_id() OR
            tenant_id IS NULL  -- Legacy data accessible to all (migration period)
        )
        WITH CHECK (
            is_admin_bypass() OR
            tenant_id = current_tenant_id()
        );

    -- --------------------------------------------------------------
    -- PERSONA_GARDEN TABLE: Add tenant isolation
    -- --------------------------------------------------------------
    DO $$
    BEGIN
        IF NOT EXISTS (
            SELECT 1 FROM information_schema.columns
            WHERE table_name = 'persona_garden' AND column_name = 'tenant_id'
        ) THEN
            ALTER TABLE persona_garden ADD COLUMN tenant_id UUID;
            CREATE INDEX IF NOT EXISTS idx_garden_tenant ON persona_garden(tenant_id);
        END IF;
    END $$;

    ALTER TABLE persona_garden ENABLE ROW LEVEL SECURITY;
    ALTER TABLE persona_garden FORCE ROW LEVEL SECURITY;

    DROP POLICY IF EXISTS garden_tenant_isolation ON persona_garden;
    CREATE POLICY garden_tenant_isolation ON persona_garden
        FOR ALL
        USING (
            is_admin_bypass() OR
            tenant_id = current_tenant_id() OR
            tenant_id IS NULL
        )
        WITH CHECK (
            is_admin_bypass() OR
            tenant_id = current_tenant_id()
        );

    -- --------------------------------------------------------------
    -- OUTBOX TABLE: Admin only (system table)
    -- --------------------------------------------------------------
    ALTER TABLE outbox ENABLE ROW LEVEL SECURITY;
    ALTER TABLE outbox FORCE ROW LEVEL SECURITY;

    DROP POLICY IF EXISTS outbox_admin_only ON outbox;
    CREATE POLICY outbox_admin_only ON outbox
        FOR ALL
        USING (is_admin_bypass())
        WITH CHECK (is_admin_bypass());

  11-sessions.sql: |
    -- ============================================================
    -- SESSIONS TABLE: K-Gent Conversation Sessions
    -- ============================================================
    --
    -- Stores K-Gent chat sessions with full RLS support.
    -- Sessions are tenant-scoped and optionally user-scoped.
    --
    -- ============================================================

    CREATE TABLE IF NOT EXISTS sessions (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
        user_id UUID REFERENCES users(id) ON DELETE SET NULL,

        -- Session Identity
        title TEXT,
        agent_type TEXT NOT NULL DEFAULT 'kgent',  -- kgent, agentese, custom

        -- State
        status TEXT NOT NULL DEFAULT 'active',
        context JSONB NOT NULL DEFAULT '{}',  -- Session context/memory

        -- Usage Tracking
        message_count INTEGER NOT NULL DEFAULT 0,
        tokens_used BIGINT NOT NULL DEFAULT 0,

        -- Timestamps
        last_message_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

        -- Soft delete
        deleted_at TIMESTAMPTZ,

        -- Constraints
        CONSTRAINT valid_status CHECK (status IN ('active', 'archived', 'deleted')),
        CONSTRAINT valid_agent_type CHECK (agent_type IN ('kgent', 'agentese', 'custom'))
    );

    -- Indexes
    CREATE INDEX IF NOT EXISTS idx_sessions_tenant ON sessions(tenant_id) WHERE deleted_at IS NULL;
    CREATE INDEX IF NOT EXISTS idx_sessions_user ON sessions(user_id) WHERE user_id IS NOT NULL;
    CREATE INDEX IF NOT EXISTS idx_sessions_recent ON sessions(tenant_id, last_message_at DESC) WHERE deleted_at IS NULL;

    -- Updated_at trigger
    DROP TRIGGER IF EXISTS sessions_updated_at ON sessions;
    CREATE TRIGGER sessions_updated_at
        BEFORE UPDATE ON sessions
        FOR EACH ROW
        EXECUTE FUNCTION update_updated_at();

    -- RLS
    ALTER TABLE sessions ENABLE ROW LEVEL SECURITY;
    ALTER TABLE sessions FORCE ROW LEVEL SECURITY;

    DROP POLICY IF EXISTS sessions_tenant_isolation ON sessions;
    CREATE POLICY sessions_tenant_isolation ON sessions
        FOR ALL
        USING (
            is_admin_bypass() OR
            tenant_id = current_tenant_id()
        )
        WITH CHECK (
            is_admin_bypass() OR
            tenant_id = current_tenant_id()
        );

    -- CDC outbox trigger
    DROP TRIGGER IF EXISTS sessions_outbox_trigger ON sessions;
    CREATE TRIGGER sessions_outbox_trigger
        AFTER INSERT OR UPDATE OR DELETE ON sessions
        FOR EACH ROW EXECUTE FUNCTION outbox_trigger();

    COMMENT ON TABLE sessions IS 'K-Gent conversation sessions with RLS tenant isolation';

  12-messages.sql: |
    -- ============================================================
    -- MESSAGES TABLE: Session Messages/History
    -- ============================================================
    --
    -- Stores individual messages within sessions.
    -- Inherits tenant isolation from parent session.
    --
    -- ============================================================

    CREATE TABLE IF NOT EXISTS messages (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        session_id UUID NOT NULL REFERENCES sessions(id) ON DELETE CASCADE,
        tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,

        -- Message Content
        role TEXT NOT NULL,  -- user, assistant, system
        content TEXT NOT NULL,

        -- Metadata
        tokens_in INTEGER DEFAULT 0,
        tokens_out INTEGER DEFAULT 0,
        model TEXT,  -- claude-3-opus, gpt-4, etc.
        latency_ms INTEGER,  -- Response time

        -- AGENTESE specific
        agentese_path TEXT,  -- If this was an AGENTESE invoke
        agentese_result JSONB,

        -- Timestamps
        created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

        -- Constraints
        CONSTRAINT valid_role CHECK (role IN ('user', 'assistant', 'system', 'tool'))
    );

    -- Indexes
    CREATE INDEX IF NOT EXISTS idx_messages_session ON messages(session_id, created_at);
    CREATE INDEX IF NOT EXISTS idx_messages_tenant ON messages(tenant_id);

    -- RLS
    ALTER TABLE messages ENABLE ROW LEVEL SECURITY;
    ALTER TABLE messages FORCE ROW LEVEL SECURITY;

    DROP POLICY IF EXISTS messages_tenant_isolation ON messages;
    CREATE POLICY messages_tenant_isolation ON messages
        FOR ALL
        USING (
            is_admin_bypass() OR
            tenant_id = current_tenant_id()
        )
        WITH CHECK (
            is_admin_bypass() OR
            tenant_id = current_tenant_id()
        );

    -- CDC outbox trigger
    DROP TRIGGER IF EXISTS messages_outbox_trigger ON messages;
    CREATE TRIGGER messages_outbox_trigger
        AFTER INSERT OR UPDATE OR DELETE ON messages
        FOR EACH ROW EXECUTE FUNCTION outbox_trigger();

    COMMENT ON TABLE messages IS 'Session messages with RLS tenant isolation';

  13-usage-events.sql: |
    -- ============================================================
    -- USAGE_EVENTS TABLE: Token/API Usage Tracking
    -- ============================================================
    --
    -- Tracks all billable events for metering and billing.
    -- This feeds into OpenMeter/Lago for usage-based billing.
    --
    -- ============================================================

    CREATE TABLE IF NOT EXISTS usage_events (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,

        -- Event Identity
        event_type TEXT NOT NULL,  -- agentese_invoke, kgent_message, storage_write
        source TEXT NOT NULL,      -- api, playground, sdk

        -- Metered Values
        tokens_in INTEGER DEFAULT 0,
        tokens_out INTEGER DEFAULT 0,
        storage_bytes BIGINT DEFAULT 0,
        compute_ms INTEGER DEFAULT 0,

        -- Context
        session_id UUID,
        api_key_id UUID,
        agentese_path TEXT,

        -- Billing Period
        billing_period TEXT NOT NULL,  -- YYYY-MM format

        -- Timestamps
        created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

        -- Constraints
        CONSTRAINT valid_event_type CHECK (event_type IN (
            'agentese_invoke', 'kgent_message', 'storage_write',
            'storage_read', 'embedding', 'api_call'
        ))
    );

    -- Indexes for billing queries
    CREATE INDEX IF NOT EXISTS idx_usage_tenant_period ON usage_events(tenant_id, billing_period);
    CREATE INDEX IF NOT EXISTS idx_usage_type ON usage_events(event_type, created_at);
    CREATE INDEX IF NOT EXISTS idx_usage_recent ON usage_events(created_at DESC);

    -- Partitioning hint: In production, partition by billing_period
    COMMENT ON TABLE usage_events IS 'Billable usage events for metering - partition by billing_period in production';

    -- Aggregation function for billing
    CREATE OR REPLACE FUNCTION get_tenant_usage(
        p_tenant_id UUID,
        p_billing_period TEXT
    ) RETURNS TABLE (
        total_tokens_in BIGINT,
        total_tokens_out BIGINT,
        total_storage_bytes BIGINT,
        total_compute_ms BIGINT,
        event_count BIGINT
    ) AS $$
    BEGIN
        RETURN QUERY
        SELECT
            COALESCE(SUM(tokens_in), 0)::BIGINT,
            COALESCE(SUM(tokens_out), 0)::BIGINT,
            COALESCE(SUM(storage_bytes), 0)::BIGINT,
            COALESCE(SUM(compute_ms), 0)::BIGINT,
            COUNT(*)::BIGINT
        FROM usage_events
        WHERE tenant_id = p_tenant_id
        AND billing_period = p_billing_period;
    END;
    $$ LANGUAGE plpgsql STABLE;

    -- RLS
    ALTER TABLE usage_events ENABLE ROW LEVEL SECURITY;
    ALTER TABLE usage_events FORCE ROW LEVEL SECURITY;

    DROP POLICY IF EXISTS usage_tenant_isolation ON usage_events;
    CREATE POLICY usage_tenant_isolation ON usage_events
        FOR ALL
        USING (
            is_admin_bypass() OR
            tenant_id = current_tenant_id()
        )
        WITH CHECK (
            is_admin_bypass() OR
            tenant_id = current_tenant_id()
        );

  14-default-tenant.sql: |
    -- ============================================================
    -- DEFAULT TENANT: For Development/Testing
    -- ============================================================
    --
    -- Create a default tenant for local development.
    -- In production, tenants are created via signup flow.
    --
    -- ============================================================

    -- Enable admin bypass for setup
    SELECT enable_admin_bypass();

    -- Create default development tenant
    INSERT INTO tenants (id, name, slug, subscription_tier, tokens_limit_month, rate_limit_rpm)
    VALUES (
        '00000000-0000-0000-0000-000000000001'::UUID,
        'Development Tenant',
        'dev',
        'enterprise',
        1000000,  -- 1M tokens
        1000      -- 1000 rpm
    )
    ON CONFLICT (slug) DO UPDATE SET
        name = EXCLUDED.name,
        subscription_tier = EXCLUDED.subscription_tier,
        tokens_limit_month = EXCLUDED.tokens_limit_month,
        rate_limit_rpm = EXCLUDED.rate_limit_rpm;

    -- Create default dev user
    INSERT INTO users (id, tenant_id, email, name, role, email_verified)
    VALUES (
        '00000000-0000-0000-0000-000000000001'::UUID,
        '00000000-0000-0000-0000-000000000001'::UUID,
        'dev@kgents.local',
        'Developer',
        'owner',
        TRUE
    )
    ON CONFLICT (tenant_id, email) DO NOTHING;

    -- Create development API keys (matching existing auth.py keys)
    INSERT INTO api_keys (id, tenant_id, user_id, key_prefix, key_hash, name, scopes)
    VALUES
        (
            '00000000-0000-0000-0000-000000000001'::UUID,
            '00000000-0000-0000-0000-000000000001'::UUID,
            '00000000-0000-0000-0000-000000000001'::UUID,
            'kg_alice',
            encode(sha256('kg_dev_alice'::bytea), 'hex'),
            'Alice Dev Key',
            ARRAY['read', 'write']
        ),
        (
            '00000000-0000-0000-0000-000000000002'::UUID,
            '00000000-0000-0000-0000-000000000001'::UUID,
            '00000000-0000-0000-0000-000000000001'::UUID,
            'kg_bob00',
            encode(sha256('kg_dev_bob'::bytea), 'hex'),
            'Bob Dev Key',
            ARRAY['read', 'write', 'admin']
        ),
        (
            '00000000-0000-0000-0000-000000000003'::UUID,
            '00000000-0000-0000-0000-000000000001'::UUID,
            '00000000-0000-0000-0000-000000000001'::UUID,
            'kg_carol',
            encode(sha256('kg_dev_carol'::bytea), 'hex'),
            'Carol Dev Key',
            ARRAY['read', 'write', 'admin', 'billing']
        )
    ON CONFLICT DO NOTHING;

    -- Migrate existing data to dev tenant
    UPDATE memories SET tenant_id = '00000000-0000-0000-0000-000000000001'::UUID WHERE tenant_id IS NULL;
    UPDATE persona_garden SET tenant_id = '00000000-0000-0000-0000-000000000001'::UUID WHERE tenant_id IS NULL;

    -- Disable admin bypass
    SELECT disable_admin_bypass();

    -- Verification
    DO $$
    DECLARE
        tenant_count INTEGER;
        user_count INTEGER;
        key_count INTEGER;
    BEGIN
        SELECT COUNT(*) INTO tenant_count FROM tenants;
        SELECT COUNT(*) INTO user_count FROM users;
        SELECT COUNT(*) INTO key_count FROM api_keys;

        RAISE NOTICE 'Multi-tenancy setup complete: % tenants, % users, % API keys',
            tenant_count, user_count, key_count;
    END $$;
