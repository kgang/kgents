# Ghost Daemon Deployment
# The Living Filesystem daemon - projects system state for peripheral awareness
#
# Architecture:
#   - Runs the ghost daemon that collects real metrics
#   - GitCollector: git status from mounted repo
#   - FlinchCollector: test failure analysis
#   - InfraCollector: kubectl from within cluster (has special access)
#   - Projects to shared volume for external consumption
#
# Key learning points:
#   - The ghost daemon runs independently (no DB dependency)
#   - InfraCollector can query the cluster directly
#   - PVC holds the .kgents/ghost/ files for persistence
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: ghost-daemon-config
  namespace: kgents-agents
  labels:
    app.kubernetes.io/name: ghost-daemon
    app.kubernetes.io/component: sensorium
    app.kubernetes.io/part-of: kgents
data:
  GHOST_INTERVAL_SECONDS: "180"  # 3 minutes
  GHOST_LOG_LEVEL: "INFO"
  GHOST_ENABLE_GIT: "true"
  GHOST_ENABLE_FLINCH: "true"
  GHOST_ENABLE_INFRA: "true"
  # Infra collector config - it's inside the cluster!
  GHOST_INFRA_NAMESPACE: "kgents-agents"
  GHOST_INFRA_CONTEXT: "in-cluster"

---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: ghost-data
  namespace: kgents-agents
  labels:
    app.kubernetes.io/name: ghost-daemon
    app.kubernetes.io/component: storage
    app.kubernetes.io/part-of: kgents
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 100Mi  # Ghost files are small

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ghost-daemon
  namespace: kgents-agents
  labels:
    app.kubernetes.io/name: ghost-daemon
    app.kubernetes.io/component: sensorium
    app.kubernetes.io/part-of: kgents
spec:
  replicas: 1  # Only one daemon needed
  selector:
    matchLabels:
      app: ghost-daemon
  template:
    metadata:
      labels:
        app: ghost-daemon
        app.kubernetes.io/name: ghost-daemon
        app.kubernetes.io/component: sensorium
    spec:
      serviceAccountName: ghost-daemon  # For kubectl access
      containers:
      - name: ghost-daemon
        # Placeholder image - builds the daemon structure
        image: python:3.12-slim
        command:
        - 'python'
        - '-c'
        - |
          import http.server
          import socketserver
          import os
          import json
          import subprocess
          from datetime import datetime
          from pathlib import Path
          import time

          print("Ghost Daemon starting...")
          print(f"GHOST_INTERVAL_SECONDS: {os.environ.get('GHOST_INTERVAL_SECONDS', '180')}")
          print(f"GHOST_ENABLE_INFRA: {os.environ.get('GHOST_ENABLE_INFRA', 'true')}")
          print()

          ghost_dir = Path("/data/ghost")
          ghost_dir.mkdir(parents=True, exist_ok=True)

          interval = int(os.environ.get("GHOST_INTERVAL_SECONDS", "180"))

          def collect_infra_health():
              """Collect k8s health from inside the cluster."""
              try:
                  result = subprocess.run(
                      ["kubectl", "get", "pods", "-n", "kgents-agents", "-o", "json"],
                      capture_output=True, text=True, timeout=10
                  )
                  if result.returncode == 0:
                      data = json.loads(result.stdout)
                      running = sum(1 for p in data.get("items", [])
                                    if p.get("status", {}).get("phase") == "Running")
                      total = len(data.get("items", []))
                      return {"status": "running", "pods_running": running, "pods_total": total}
              except Exception as e:
                  return {"status": "error", "error": str(e)}
              return {"status": "unknown"}

          def project():
              """Project ghost state to files."""
              now = datetime.now().isoformat()

              # Collect infra health
              infra = collect_infra_health()

              # Write health.status
              health_line = f"cortex:healthy | infra:{infra.get('status', 'unknown')} pods:{infra.get('pods_running', 0)}/{infra.get('pods_total', 0)}"
              (ghost_dir / "health.status").write_text(health_line)

              # Write context.json
              context = {
                  "timestamp": now,
                  "source": "ghost-daemon-k8s",
                  "infra_health": infra,
                  "interval_seconds": interval,
              }
              (ghost_dir / "context.json").write_text(json.dumps(context, indent=2))

              # Write thought_stream.md
              thought_path = ghost_dir / "thought_stream.md"
              existing = thought_path.read_text() if thought_path.exists() else "# Ghost Thought Stream\n\n"
              new_thought = f"- *{now}* [ghost-daemon-k8s] Projection from cluster\n"
              thought_path.write_text(existing + new_thought)

              print(f"[{now}] Projected: {health_line}")

          # Initial projection
          project()

          # Start health endpoint + daemon loop
          class HealthHandler(http.server.BaseHTTPRequestHandler):
              def do_GET(self):
                  self.send_response(200)
                  self.send_header("Content-type", "application/json")
                  self.end_headers()
                  status = {"status": "running", "last_projection": datetime.now().isoformat()}
                  self.wfile.write(json.dumps(status).encode())
              def log_message(self, format, *args):
                  pass

          import threading
          import signal
          import sys

          running = True
          def signal_handler(sig, frame):
              global running
              running = False
              print("\nShutting down...")
              sys.exit(0)

          signal.signal(signal.SIGTERM, signal_handler)
          signal.signal(signal.SIGINT, signal_handler)

          # Start HTTP server in background
          server = socketserver.TCPServer(("", 8080), HealthHandler)
          server_thread = threading.Thread(target=server.serve_forever)
          server_thread.daemon = True
          server_thread.start()
          print("Health server running on :8080")

          # Daemon loop
          while running:
              time.sleep(interval)
              if running:
                  project()
        ports:
        - containerPort: 8080
          name: http
          protocol: TCP
        envFrom:
        - configMapRef:
            name: ghost-daemon-config
        volumeMounts:
        - name: ghost-data
          mountPath: /data/ghost
        resources:
          requests:
            memory: "64Mi"
            cpu: "25m"
          limits:
            memory: "128Mi"
            cpu: "100m"
        readinessProbe:
          httpGet:
            path: /
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 10
        livenessProbe:
          httpGet:
            path: /
            port: 8080
          initialDelaySeconds: 10
          periodSeconds: 30

      volumes:
      - name: ghost-data
        persistentVolumeClaim:
          claimName: ghost-data

---
# ServiceAccount for kubectl access
apiVersion: v1
kind: ServiceAccount
metadata:
  name: ghost-daemon
  namespace: kgents-agents
  labels:
    app.kubernetes.io/name: ghost-daemon
    app.kubernetes.io/component: sensorium
    app.kubernetes.io/part-of: kgents

---
# Role for reading pods in the namespace
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: ghost-daemon-role
  namespace: kgents-agents
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list"]
- apiGroups: ["apps"]
  resources: ["deployments"]
  verbs: ["get", "list"]

---
# Bind role to service account
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: ghost-daemon-binding
  namespace: kgents-agents
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: ghost-daemon-role
subjects:
- kind: ServiceAccount
  name: ghost-daemon
  namespace: kgents-agents

---
apiVersion: v1
kind: Service
metadata:
  name: ghost-daemon
  namespace: kgents-agents
  labels:
    app.kubernetes.io/name: ghost-daemon
    app.kubernetes.io/component: sensorium
    app.kubernetes.io/part-of: kgents
spec:
  type: ClusterIP
  ports:
  - port: 8080
    targetPort: 8080
    name: http
    protocol: TCP
  selector:
    app: ghost-daemon
