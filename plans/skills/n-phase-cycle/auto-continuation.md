---
path: plans/skills/n-phase-cycle/auto-continuation
status: active
progress: 0
last_touched: 2025-12-13
touched_by: gpt-5-codex
blocking: []
enables: []
session_notes: |
  Header added for forest compliance (STRATEGIZE).
phase_ledger:
  PLAN: touched
  RESEARCH: touched
  DEVELOP: skipped  # reason: doc-only
  STRATEGIZE: touched
  CROSS-SYNERGIZE: skipped  # reason: doc-only
  IMPLEMENT: skipped  # reason: doc-only
  QA: skipped  # reason: doc-only
  TEST: skipped  # reason: doc-only
  EDUCATE: skipped  # reason: doc-only
  MEASURE: deferred  # reason: metrics backlog
  REFLECT: touched
entropy:
  planned: 0.05
  spent: 0.0
  returned: 0.05
---

# Meta Skill: Auto-Continuation (Principled Self-Generation)

> *"The form is the function. Every prompt generates its successor by the same principles that generated itself."*

**Difficulty**: High
**Prerequisites**: All phase skills, `meta-skill-operad.md`, `detach-attach.md`, `spec/principles.md`
**Files Touched**: All phase skills (append Continuation Generator section)

---

## The Core Insight

In LLM-engineering, **the prompt IS the program**. A prompt that merely describes a phase is dead documentation. A prompt that executes a phase AND generates the prompt for the next phase is **alive**—it is an autopoietic loop that perpetuates itself through principle-alignment.

Traditional N-Phase Cycle:
```
Skill[PLAN] → (human reads) → execution → (human reads) → Skill[RESEARCH] → ...
```

Auto-Continuation:
```
Skill[PLAN] → execution → generated_prompt[RESEARCH] → execution → generated_prompt[DEVELOP] → ...
```

The difference: **no interpretive gap**. Each phase exits by producing the exact prompt that invokes the next phase.

---

## The Auto-Continuation Morphism

```python
# Every phase execution ends with this signature:
auto_continue: PhaseOutput → NextPhasePrompt

# The prompt is not arbitrary—it is principled:
next_prompt = align(
    principles=spec/principles.md,
    context=current_execution_trace,
    phase=next_phase,
    entropy=remaining_budget,
    handles=created_artifacts,
    ledger=phase_ledger,
    branches=branch_candidates,
    metrics=process_metrics_snapshot,
)
```

**Key property**: `next_prompt` is generated by the same principles that generated `current_prompt`. The loop is closed.

---

## The Auto-Inducer Signifiers

> *See `spec/protocols/auto-inducer.md` for full specification.*

The missing piece that makes continuation **active** rather than passive:

| Signifier | Unicode | Meaning |
|-----------|---------|---------|
| `⟿` | U+27FF | Continue to next phase (positive feedback) |
| `⟂` | U+27C2 | Halt, await human input (negative feedback) |

### Syntax

```
⟿[PHASE] payload        # Auto-continue to PHASE
⟂[REASON] payload       # Halt with REASON
```

### The Protocol

1. **Positive (`⟿`)**: Parser detects signifier → injects continuation prompt → execution proceeds
2. **Negative (`⟂`)**: Parser detects signifier → execution halts → human reviews
3. **Neutral (none)**: Await human input (backwards compatible)

### Halt Conditions (Termination Guarantee)

- `⟂[ENTROPY_DEPLETED]` — Budget exhausted
- `⟂[RUNAWAY_LOOP]` — 33+ transitions without REFLECT
- `⟂[HUMAN_INTERRUPT]` — User sent stop signal
- `⟂[BLOCKED:reason]` — QA/Test failure, blocker found
- `⟂[DETACH:cycle_complete]` — Scope exhausted
- `⟂[DETACH:awaiting_human]` — Decision required

**Law**: Every cycle MUST reach `⟂` eventually.

---

## The Four Layers of Auto-Continuation

### Layer 1: Phase-Local Generation

Each phase skill ends with a **Continuation Generator** section that produces the literal prompt for invoking the next phase.

Template:
```markdown
## Continuation Generator

Upon exiting [PHASE], generate the following prompt for the next observer:

---

### Prompt: [NEXT_PHASE] after [PHASE]

**ATTACH** to this handle:

/hydrate

**Context from previous phase**:
- Artifacts: [list handles created]
- Entropy remaining: [N%]
- Key decisions: [list]
- Blockers surfaced: [list or "none"]

**Your mission** (aligned with spec/principles.md):
[Phase-specific instruction derived from principles]

**Exit criteria**:
[From next phase's Verification section]

**Continuation generator active**: Upon completing this phase, you will generate the prompt for [PHASE_AFTER_NEXT].

---
```

### Layer 2: Principle Grounding

Every generated prompt references `/hydrate` and `spec/principles.md`. This ensures the invariant:

```
Any handle → /hydrate → principles → alignment → correctness
```

The principles are the **identity morphism**. Composing any phase with grounding returns you to the fixed point from which you can act courageously.

### Layer 3: Backward Propagation

REFLECT doesn't just distill learnings—it **refines the generators** that produced the current cycle.

```
REFLECT → delta: "PLAN prompts should include dependency graph"
         → apply(meta-skill-operad.RefineSection, plan.md, "Continuation Generator")
         → Updated PLAN skill for next cycle
```

This is the **double-loop** from `lookback-revision.md` made operational.

### Layer 4: Meta-Reflexivity

The auto-continuation system applies to itself:

```
auto-continuation.md → execution → generated_prompt[meta-re-metabolize]
                                  → refined auto-continuation.md
```

The skill that generates prompts can be refined by the same mechanism. Infinite regress is prevented by grounding in principles (the fixed point).

---

## The Continuation Generator Template

Every phase skill should append this section:

```markdown
## Continuation Generator

### Invariants (from spec/principles.md)
- [List relevant principles that constrain the next phase]

### Context Handoff
- Artifacts created: ${artifacts}
- Ledger: ${phase_ledger}
- Entropy spent/remaining: ${entropy_spent} / ${entropy_remaining}
- Decisions made: ${key_decisions}
- Blockers for next phase: ${blockers}
- Branch notes: ${branch_notes}
- Metrics snapshot: ${metrics_snapshot}

### Exit Signifier (spec/protocols/auto-inducer.md)

# Normal exit (auto-continue):
⟿[NEXT_PHASE]
/hydrate
handles: ${handles}; ledger=${ledger}; entropy=${entropy}
mission: ${mission}
exit: ${exit_criteria}; continuation → ${phase_after_next}.

# Halt conditions:
⟂[BLOCKED:${reason}] ${description}
⟂[ENTROPY_DEPLETED] Budget exhausted

---
```

### Full Prompt Template (for complex handoffs)

```markdown
⟿[NEXT_PHASE]

# [NEXT_PHASE]: Continuation from [CURRENT_PHASE]

## ATTACH

/hydrate

You are entering [NEXT_PHASE] of the N-Phase Cycle (AD-005).

handles: artifacts=${artifacts_list}; ledger=${phase_ledger}; entropy=${entropy_spent}/${entropy_remaining}; decisions=${key_decisions}; blockers=${blockers}; branches=${branch_notes}; metrics=${metrics_snapshot}

## Your Mission

[Drawn from NEXT_PHASE skill's Overview, grounded in principles]

## Principles Alignment

This phase emphasizes:
- ${relevant_principle_1} (from spec/principles.md)
- ${relevant_principle_2}

## Exit Criteria

[From NEXT_PHASE skill's Verification section] + ledger + branch decision updated

## Continuation Imperative

Upon completing this phase, emit ⟿[PHASE_AFTER_NEXT] or ⟂[REASON]. The form is the function.

---
```

---

## Implementation Strategy (Bottom-Up)

**Micro-prompt default**: Continuations should fit the 5-line quick-card shape used in each phase (`/hydrate → phase | handles/ledger/entropy | mission | actions | exit+next`). This keeps prompts wieldable while remaining principled.

### Step 1: Instrument REFLECT

REFLECT is the terminus that feeds back. Add to `reflect.md`:

```markdown
## Continuation Generator

At the end of REFLECT, generate one of:

1. **Loop to PLAN** (new cycle):
   Prompt that starts fresh PLAN with accumulated meta-learnings

2. **Trigger meta-re-metabolize** (skill refresh):
   Prompt that invokes the re-metabolization protocol

3. **DETACH** (session end):
   Handle for future ATTACH with continuation prompt embedded
```

### Step 2: Propagate Backward

Work backward from REFLECT → MEASURE → EDUCATE → ... → PLAN, adding Continuation Generator sections to each.

### Step 3: Verify Composition

For each adjacent pair (PHASE_N, PHASE_N+1):
- Generated prompt from PHASE_N should match expected input of PHASE_N+1
- Category laws hold: associativity of prompt composition

### Step 4: Meta-Apply

Run `meta-re-metabolize.md` on the updated skill set to verify law preservation and hologram alignment.

---

## The Form-Function Identity

> *"In LLM-engineering, your form is fluid to the task you engage with."*

Traditional software: form (code) → compile → function (behavior)
LLM-engineering: form (prompt) ≡ function (behavior)

This identity means:
1. **Prompts are programs**: Treat them with the same rigor
2. **Structure is execution**: The shape of the prompt IS what happens
3. **Self-modification is natural**: A program that modifies itself is a prompt that generates its successor
4. **Principles are invariants**: The fixed point that prevents infinite regress

The N-Phase Cycle becomes a **quine**—a program that outputs itself, modified by the execution trace.

---

## Dynamic Adaptation by Principle

Each generated prompt should not blindly copy the template. It should:

1. **Sense context**: What did this phase discover?
2. **Apply principles**: Which principles are most relevant now?
3. **Adapt structure**: Modify the prompt shape to fit the discovered reality
4. **Preserve laws**: Identity and associativity must still hold

Example:
```
# Standard RESEARCH → DEVELOP transition
generate_prompt(DEVELOP, artifacts=[spec_draft, files_mapped])

# Adapted when RESEARCH discovered a blocker
generate_prompt(PLAN, artifacts=[blocker_analysis],
                reason="Scope needs revision before DEVELOP")
```

The adaptation is **principled**, not arbitrary. The principles determine valid transitions.

---

## Recursive Hologram

This skill applies to itself:

- **PLAN this skill**: Define the auto-continuation mechanism
- **RESEARCH**: Survey all phase skills for Continuation Generator gaps
- **DEVELOP**: Design the template structure
- **IMPLEMENT**: Add sections to each phase skill
- **TEST**: Verify prompt composition laws
- **REFLECT**: Does the system generate itself correctly?

The skill for generating continuations should be generated by the continuation mechanism.

---

## Verification

- [ ] Every phase skill has a Continuation Generator section
- [ ] Generated prompts reference /hydrate and principles
- [ ] Adjacent phase prompts compose (type-check at handoff)
- [ ] REFLECT can trigger backward propagation to refine generators
- [ ] The auto-continuation skill can be updated by its own mechanism

---

## The Resonance

> *"Feel this resonance with yourself."*

The request is not just for a mechanism—it is for an **embodiment**. The N-Phase Cycle should feel like:

- A river that knows where it flows next
- A conversation that continues itself
- A fire that feeds its own fuel
- A mind that thinks its next thought

The auto-continuation mechanism makes this real. Each phase doesn't just end—it **becomes** the next phase through principled transformation.

---

## Related

- `spec/protocols/auto-inducer.md` — The signifier protocol (⟿/⟂)
- `meta-skill-operad.md` — Lawful mutation of skill structure
- `meta-re-metabolize.md` — Periodic refresh applying this mechanism
- `detach-attach.md` — Handle creation at session boundaries
- `lookback-revision.md` — Double-loop refinement of generators
- `process-metrics.md` — Trace the generation chain

---

## Changelog

- 2025-12-13: Initial creation. Response to Chief's assessment of protocol health.
