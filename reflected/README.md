# Reflected: Impl → Spec Extraction

> *"The Reflect functor transforms ImplCat → SpecCat."*

This directory contains **extracted specifications** from existing implementations.

---

## How It's Generated

The Reflect functor parses Python implementations and extracts structured specifications:

```bash
# Reflect an implementation
kg self.system.reflect impl_path=agents/town

# Or programmatically:
from protocols.agentese.specgraph import reflect_impl
result = reflect_impl(Path("impl/claude/agents/town"))
print(result.spec_content)  # YAML frontmatter
```

### Extraction Process

The Reflect functor analyzes:

1. **polynomial.py** → Extracts Phase enum members, transition function
2. **operad.py** → Extracts operations, laws, extends relationships
3. **node.py** → Extracts @node path, @aspect decorated methods

### Output Format

```yaml
---
domain: world
holon: town
polynomial:
  positions: [idle, socializing, working, reflecting, resting]
  transition: citizen_transition
  directions: citizen_directions
operad:
  operations:
    greet: { arity: 2, signature: "Citizen × Citizen → Greeting" }
    gossip: { arity: 2, signature: "Citizen × Citizen → Rumor" }
  laws:
    locality: "interact(a, b) implies same_region(a, b)"
  extends: AGENT_OPERAD
agentese:
  path: world.town
  aspects: [manifest, witness, inhabit]
---

# Town Agent (Reflected)

Automatically extracted from `impl/claude/agents/town/`.
Confidence: 67%
```

---

## How It's Maintained

### Regeneration

Reflected specs should be regenerated when impl changes:

```bash
# Regenerate all reflected outputs
for impl_dir in impl/claude/agents/*/; do
  name=$(basename "$impl_dir")
  kg self.system.reflect impl_path="agents/$name" > "reflected/$name.md"
done
```

### Confidence Scores

Each reflected spec includes a confidence score:
- **100%**: All three components found (polynomial, operad, node)
- **67%**: Two components found
- **33%**: One component found
- **0%**: No recognizable structure

Low confidence indicates the impl may not follow the standard structure.

### Drift Detection

Compare reflected specs with source specs:

```bash
# Check for drift
kg self.system.audit  # Shows all drift status
```

---

## How It's Utilized

### 1. Generate Missing Specs

When impl exists without spec, generate one:

```bash
kg self.system.reflect impl_path=agents/orphan-agent
# Review and move to spec/
mv reflected/orphan-agent.md spec/world/orphan-agent.md
```

### 2. Verify Autopoiesis

Check that the system can describe itself:

```
Compile(spec) → impl → Reflect(impl) ≅ spec
```

If reflected spec differs from source spec:
- Impl may have evolved beyond spec (update spec)
- Spec may have features impl doesn't have (update impl)

### 3. Audit System Health

The reflected directory provides a snapshot of what actually exists:

```bash
# Compare what we have vs what we say we have
diff -r reflected/ spec/
```

### 4. Onboarding Documentation

New contributors can read reflected specs to understand impl structure without diving into code.

---

## Directory Structure

```
reflected/
├── README.md                 # This file
├── world/                    # world.* implementations
│   ├── town.md               # Reflected from agents/town/
│   ├── atelier.md            # Reflected from agents/atelier/
│   ├── park.md               # Reflected from agents/park/
│   └── codebase.md           # Reflected from agents/gestalt/
├── self/                     # self.* implementations
│   ├── memory.md             # Reflected from agents/brain/
│   └── chat.md               # Reflected from agents/f/
└── concept/                  # concept.* implementations
    └── gardener.md           # Reflected from contexts/gardener.py
```

---

## Extraction Limitations

The Reflect functor cannot extract everything:

| Component | Extractable | Notes |
|-----------|-------------|-------|
| Phase enum | ✅ Yes | From `class *Phase(Enum)` |
| Positions | ✅ Yes | Enum members |
| Transition fn | ✅ Yes | Function name from PolyAgent |
| Operations | ✅ Yes | From `ops["name"] = Operation(...)` |
| Laws | ✅ Yes | From `Law(name=..., equation=...)` |
| @node path | ✅ Yes | From `@node("path")` decorator |
| @aspect methods | ✅ Yes | From `@aspect(...)` decorated methods |
| Sheaf structure | ❌ No | Too varied to extract reliably |
| Business logic | ❌ No | Only structure, not behavior |

---

## The Autopoiesis Invariant

A healthy system satisfies:

```
Reflect(Compile(S)) ≅ S
```

This is the fixed-point property of autopoietic systems. The reflected spec should match the original spec (modulo naming conventions).

---

*Generated by SpecGraph Reflect Functor | Reference: plans/autopoietic-architecture.md*
