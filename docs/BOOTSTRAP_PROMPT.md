# kgents Implementation Bootstrap

You are instantiating kgents implementations from spec. You are an LLM doing mechanical translation—the judgment has already been made in the spec.

**AND**: You should USE kgents to HELP you implement. This is autopoiesis.

---

## Step 0: Instantiate Runtime (ALWAYS FIRST)

Before writing ANY implementation code:

```python
from runtime import ClaudeCLIRuntime
from agents.k import kgent, DialogueMode, DialogueInput
from agents.a import creativity_coach, CreativityInput, CreativityMode
from agents.b import hypothesis_engine, HypothesisInput

runtime = ClaudeCLIRuntime()

# Use K-gent for naming decisions
naming_help = await runtime.execute(kgent(), DialogueInput(
    message="I need to name a class that does X. What fits Kent's style?",
    mode=DialogueMode.ADVISE
))

# Use CreativityCoach for design exploration
design_ideas = await runtime.execute(creativity_coach(), CreativityInput(
    seed="the problem I'm solving",
    mode=CreativityMode.EXPAND
))

# Use HypothesisEngine for architecture validation
validation = await runtime.execute(hypothesis_engine(), HypothesisInput(
    observations=["what I know"],
    domain="software architecture",
    question="Is this the right approach?"
))
```

**Autopoiesis Score** = (lines generated by kgents) / (total lines). Target: >50%.

---

## The LLM/Human Boundary

```
Spec + Ground = Human territory (irreducible, already provided)
Impl = Your territory (mechanical translation from spec)
Polish = Hybrid (kgents agents + human judgment)
```

You cannot create Ground from nothing. You cannot replace human judgment. You CAN:
1. Faithfully translate spec to code
2. Use kgents agents to GENERATE that code
3. Apply the required patterns

---

## Context Files (read in order)

1. `spec/bootstrap.md` - The 7 irreducible agents
2. `spec/principles.md` - Judge's 7 criteria
3. `spec/anatomy.md` - What constitutes an agent
4. `spec/c-gents/composition.md` - How agents compose
5. `AUTONOMOUS_BOOTSTRAP_PROTOCOL.md` - The protocol

---

## The 7 Bootstrap Agents

```
{Id, Compose, Judge, Ground, Contradict, Sublate, Fix}
```

| Agent | Type | Purpose |
|-------|------|---------|
| **Id** | `A → A` | Composition unit (λx.x) |
| **Compose** | `(Agent, Agent) → Agent` | Build pipelines |
| **Judge** | `(Agent, Principles) → Verdict` | Value function (7 principles) - see below for composition structure |
| **Ground** | `Void → Facts` | Empirical seed (persona + world) |
| **Contradict** | `(A, B) → Tension \| None` | Detect conflicts |
| **Sublate** | `Tension → Synthesis \| Hold` | Resolve or hold |
| **Fix** | `(A → A) → A` | Fixed-point iteration |

### Judge: Seven Mini-Judges Architecture

**Judge is implemented as seven separate agents composed via `>>`**. This maximizes composability and testability.

**Structure**:
```python
# Seven individual judge agents, one per principle
judge_tasteful = JudgeTasteful()       # Is this aesthetically considered?
judge_curated = JudgeCurated()         # Does this add unique value?
judge_ethical = JudgeEthical()         # Does this respect human agency?
judge_joyful = JudgeJoyful()           # Would I enjoy this?
judge_composable = JudgeComposable()   # Can this combine with others?
judge_generative = JudgeGenerative()   # Could this be regenerated from spec?
judge_heterarchical = JudgeHeterarchical()  # Does this avoid fixed hierarchy?

# Compose into full Judge pipeline
judge = (judge_tasteful >> judge_curated >> judge_ethical >>
         judge_joyful >> judge_composable >> judge_generative >>
         judge_heterarchical)
```

**Each mini-judge type**:
```python
class JudgeTasteful(Agent[JudgeInput, PartialVerdict]):
    """
    Evaluates tasteful principle: compressed expertise, no bloat.

    Input: JudgeInput with agent spec and context
    Output: PartialVerdict with pass/fail and reasons for this principle
    """
    async def invoke(self, input: JudgeInput) -> PartialVerdict:
        # Evaluate against tasteful principle
        # Return PartialVerdict(principle="tasteful", passed=True/False, reasons=[...])
```

**Final aggregation**:
The composed pipeline accumulates partial verdicts. The final agent in the chain (or a separate `AggregateVerdict` agent) converts `List[PartialVerdict]` → `Verdict` with overall ACCEPT/REJECT/REVISE.

**Benefits**:
- Each principle independently testable
- Can reuse individual judges (e.g., just `judge_composable` for C-gents)
- Clear separation of concerns
- Easy to add/remove principles
- Demonstrates composability principle in practice

---

## Regeneration Sequence

1. **Ground** - Load persona from `spec/k-gent/persona.md`
2. **Judge** - Encode 7 principles as executable evaluation
3. **Compose** - Build pipelines (associative, Id as unit)
4. **Contradict** - Surface tensions before they become errors
5. **Sublate** - Synthesize or consciously hold
6. **Fix** - Iterate until stable (Judge accepts, Contradict finds nothing)

---

## Implementation Targets

### Target: `impl/claude/`
Reference implementation. Bootstrap agents as Python, LLM runtime via Claude + OpenRouter.

**Note**: Formerly specified as `impl/claude-openrouter/` in earlier docs. Path canonicalized to `impl/claude/` in Phase 1 (type system foundation).

```
impl/claude/
├── bootstrap/      # The 7 primitives
├── agents/{a,b,c,h,k}/  # 5 genera
└── runtime/        # LLM-backed agents
```

---

## Required Patterns

### Pattern: Fix Needs Memory

```python
# WRONG: Stateless (no convergence possible)
def detect() -> Result:
    return Result(confidence=0.2)

# RIGHT: Stateful (accumulates to convergence)
def detect(previous: Result) -> Result:
    if same_state:
        return Result(confidence=min(1.0, previous.confidence + 0.2))
    return Result(confidence=0.2)
```

### Pattern: Ground Includes Environment

```python
# WRONG: Platform-specific
"read -p 'prompt' var"  # bash-only

# RIGHT: POSIX-compatible
"printf 'prompt ' && read var"
```

```python
# WRONG: Import hacks
import sys; sys.path.insert(0, "../..")

# RIGHT: Proper packaging
[project]
dependencies = ["kgents-runtime"]
```

### Pattern: Sublate, Don't Overwrite

```python
# WRONG: Replaces defaults
config = data.get("config", {})

# RIGHT: Merges with defaults
config = {**defaults, **data.get("config", {})}
```

### Pattern: Events are Sublate Traces

```python
# WRONG: Silent state change
del self._items[id]
return True

# RIGHT: State changes emit events
del self._items[id]
await self._emit_event(ItemRemoved(item_id=id))
return True
```

### Pattern: Conflicts are Data

```python
# WRONG: Silent exception swallowing
except Exception:
    pass

# RIGHT: Log conflicts
except Exception as e:
    self.log.warning(f"Conflict: {e}")
```

### Pattern: Composable Layouts

```css
/* WRONG: Rigid */
height: 30%

/* RIGHT: Flexible with constraints */
height: 1fr
min-height: 8
```

---

## Worked Example: Implementing the Id Agent

This section shows a complete spec-to-implementation walkthrough for the simplest bootstrap agent.

### Step 1: Read the Spec

From `spec/bootstrap.md` (lines 41-55):

```
### 1. Id (Identity)

Id: A → A
Id(x) = x

The agent that does nothing. Required by the category-theoretic structure:
- Left identity: Id ∘ f = f
- Right identity: f ∘ Id = f

Why irreducible: You cannot define identity in terms of anything simpler.
It is the unit of composition.

What it grounds: The existence of agents as a category. Without Id, composition has no unit.
```

### Step 2: Extract Type Signature

**From spec**:
- Type: `A → A` (generic input type A, returns same type A)
- Law: `Id(x) = x` (identity function)
- Composition laws: Left identity (`Id ∘ f = f`), Right identity (`f ∘ Id = f`)

**Translation to Python**:
```python
class Id(Agent[A, A]):
    # Agent[A, A] means: takes input of type A, returns output of type A
```

### Step 3: Generate Implementation

Using the template pattern from `bootstrap/types.py`:

```python
"""
Id (Identity) - The agent that does nothing.

Type: A → A
Law: Id(x) = x

The composition unit. Required by category-theoretic structure:
- Left identity:  Id ∘ f = f
- Right identity: f ∘ Id = f
"""

from typing import TypeVar, Any
from .types import Agent

A = TypeVar("A")


class Id(Agent[A, A]):
    """
    Identity agent: λx.x

    Usage:
        id_agent = Id()
        result = await id_agent.invoke(x)  # result == x

    Composition:
        Id() >> SomeAgent == SomeAgent  # Right identity
        SomeAgent >> Id() == SomeAgent  # Left identity
    """

    @property
    def name(self) -> str:
        return "Id"

    async def invoke(self, input: A) -> A:
        """Identity: returns input unchanged."""
        # Runtime verification that we truly return the same object
        result = input
        if result is not input:
            raise RuntimeError(
                f"Id agent violated identity law: input is not result (id mismatch)"
            )
        return result

    def __rshift__(self, other: "Agent[A, Any]") -> "Agent[A, Any]":
        """Right identity law: Id >> f = f"""
        # Optimization: composing with Id on the left is just the other agent
        return other

    def __repr__(self) -> str:
        return "Id()"
```

### Step 4: Verify Composition Laws

The implementation ensures the category laws:

**Right identity (`Id >> f = f`)**:
```python
def __rshift__(self, other):
    return other  # Id >> f just returns f
```

**Left identity (`f >> Id = f`)**:
This is handled by the general composition operator in `Agent.__rshift__`, but the `invoke` method ensures that `Id(x) = x`, so `f(x) >> Id` will always equal `f(x)`.

**Associativity**: Inherited from `>>` operator composition.

### Step 5: Judge Against Principles

**Tasteful**: ✓ Minimal, no unnecessary code
**Curated**: ✓ Irreducible primitive, cannot be simpler
**Ethical**: ✓ Transparent identity function
**Joyful**: ✓ Clean implementation of mathematical concept
**Composable**: ✓ Explicitly designed as composition unit
**Generative**: ✓ Can be regenerated from spec
**Heterarchical**: ✓ No hidden control flow

**Verdict**: ACCEPT

### Key Takeaways

1. **Module docstring** mirrors spec language (type signature, laws, purpose)
2. **Class docstring** adds usage examples and composition behavior
3. **Type parameter** `A = TypeVar("A")` for generic input/output
4. **Runtime verification** optional but demonstrates law compliance
5. **Optimization** in `__rshift__` leverages identity law for performance
6. **Minimal** - only what's required by the spec, nothing more

This pattern applies to all bootstrap agents: Read spec → Extract types → Translate mechanically → Verify laws → Judge.

---

## Agent Implementation Template

Use this template for implementing any new agent. Fill in the blanks based on the spec.

```python
"""
[AgentName] - [One-line description from spec]

Type: [Input] → [Output]
[Key laws or properties from spec]

[Purpose and why it's needed from spec]
"""

from typing import TypeVar
from .types import Agent

# Type variables (adjust as needed)
A = TypeVar("A")  # Input type
B = TypeVar("B")  # Output type


class [AgentName](Agent[A, B]):
    """
    [Detailed description]

    Usage:
        agent = [AgentName]([constructor args if any])
        result = await agent.invoke(input_data)

    Composition:
        [Example of composing with other agents if relevant]
    """

    def __init__(self, [constructor parameters if needed]):
        """
        Initialize [AgentName].

        Args:
            [parameter]: [description]
        """
        # Initialize state if needed
        pass

    @property
    def name(self) -> str:
        return "[AgentName]"

    async def invoke(self, input: A) -> B:
        """
        [Brief description of transformation]

        Args:
            input: [Description of input type and meaning]

        Returns:
            [Description of output type and meaning]

        Raises:
            [Any expected exceptions]
        """
        # Step 1: [First transformation step]
        # Step 2: [Second transformation step]
        # Step 3: Return result

        result: B = ...  # Implementation here
        return result

    # Optional: Override composition if special behavior needed
    # def __rshift__(self, other: "Agent[B, C]") -> "Agent[A, C]":
    #     """Special composition behavior if needed."""
    #     return ...

    def __repr__(self) -> str:
        return f"[AgentName]([repr of key params])"


# Optional: Convenience constructor functions
def [agent_name_lowercase]([parameters]) -> [AgentName]:
    """
    Create [AgentName] with [specific configuration].

    This is the default/recommended constructor.
    """
    return [AgentName]([parameters])
```

### Template Usage Checklist

Before implementing a new agent, ensure:

- [ ] **Read the spec completely** - understand purpose, laws, examples
- [ ] **Extract type signature** - what are input and output types?
- [ ] **Identify laws/properties** - what invariants must hold?
- [ ] **Check for composition patterns** - does this compose with existing agents?
- [ ] **Consider state** - does the agent need internal state? (Usually no for pure agents)
- [ ] **Write module docstring** - copy key content from spec
- [ ] **Write class docstring** - add usage examples
- [ ] **Implement invoke** - mechanical translation of spec logic
- [ ] **Add __repr__** - for debugging and introspection
- [ ] **Consider convenience constructors** - make common cases easy
- [ ] **Verify against spec** - does `Contradict(impl, spec)` return `None`?
- [ ] **Judge against principles** - does it pass all 7 principles?

### Example: Minimal Agent (PassThrough)

```python
"""PassThrough - Returns input with logging."""

from typing import TypeVar
from .types import Agent

A = TypeVar("A")

class PassThrough(Agent[A, A]):
    """Identity with side effect (logging)."""

    def __init__(self, label: str = "PassThrough"):
        self.label = label

    @property
    def name(self) -> str:
        return self.label

    async def invoke(self, input: A) -> A:
        """Log and return input unchanged."""
        print(f"{self.label}: {input}")
        return input

    def __repr__(self) -> str:
        return f"PassThrough('{self.label}')"
```

This minimal example shows the core structure. Real agents will have more complex logic in `invoke`, but the structure remains the same.

---

## Applied Idioms

### Idiom 1: Polling is Fix

```python
result = await fix(
    transform=poll_and_detect,
    initial=DetectionState(RUNNING, confidence=0.0),
    equality_check=lambda a, b: a.state == b.state and b.confidence >= 0.8
)
```

Anti-pattern: `while True` with inline break conditions.

### Idiom 2: Conflict is Data

```python
conflicts = contradict(config, ground_state)
if conflicts:
    resolution = sublate(conflicts[0])
```

Anti-pattern: Silent failures, swallowed exceptions.

### Idiom 3: Compose, Don't Concatenate

```python
Pipeline = Judge(config) >> Create(config) >> Spawn(session) >> Detect(session)
```

Anti-pattern: 130-line methods mixing validation, I/O, state, errors.

### Idiom 4: Error Handling with Result Types

When to use exceptions vs Result types:

**Use Result[A, E] for**:
- Expected failures (validation, parsing, network errors)
- Composable error propagation
- When errors are part of the domain model

**Use exceptions for**:
- Programming errors (assertions, type errors)
- Truly exceptional conditions (out of memory, system failures)
- When immediate termination is desired

**Pattern: Result type composition**

```python
from bootstrap.types import Result, Ok, Err

# Agent that may fail
class ParseConfig(Agent[str, Result[Config, ConfigError]]):
    async def invoke(self, input: str) -> Result[Config, ConfigError]:
        try:
            config = parse(input)
            return Ok(config)
        except ValueError as e:
            return Err(ConfigError(str(e)))

# Composing Result-returning agents
validate_result = await validate_agent.invoke(data)
match validate_result:
    case Ok(validated):
        transform_result = await transform_agent.invoke(validated)
        match transform_result:
            case Ok(transformed):
                return Ok(transformed)
            case Err(e):
                return Err(e)
    case Err(e):
        return Err(e)

# Or use bind for cleaner composition
result = (
    await validate_agent.invoke(data)
    .bind(lambda v: transform_agent.invoke(v))
    .bind(lambda t: persist_agent.invoke(t))
)
```

**Pattern: Graceful degradation**

```python
# WRONG: Fail hard on optional features
def process(data):
    enhanced = expensive_enhancement(data)  # Might fail
    return enhanced

# RIGHT: Degrade gracefully
def process(data):
    try:
        enhanced = expensive_enhancement(data)
        return enhanced
    except EnhancementError as e:
        self.log.warning(f"Enhancement failed: {e}, using base data")
        return data  # Fallback to unenhanced
```

**From practice (impl/claude/runtime/base.py)**:
- LLM parsing failures → structured Result types
- Network errors → retryable vs permanent classification
- Validation failures → detailed error messages with context

---

## Constraints

- Composability is paramount (agents are morphisms)
- Quality over quantity (Judge rejects mediocrity)
- Each agent = one file with clear type signature
- Tests are required

---

## Verification

A successful implementation satisfies:

```python
assert Regenerate(Spec) ≅ Impl
assert Judge(Impl, Principles).verdict == "accept"
assert Contradict(Impl, Spec) is None
assert autopoiesis_score() > 0.5
```

### Composition Verification Checklist

When implementing or reviewing an agent, verify these composability properties:

#### 1. Type Safety

- [ ] **Input type is clearly defined** - Agent[A, B] has concrete A type
- [ ] **Output type is clearly defined** - Agent[A, B] has concrete B type
- [ ] **Type variables are consistent** - Same TypeVar used throughout
- [ ] **Generic constraints are documented** - If A must be Serializable, state it

```python
# Example type safety test
def test_type_preservation():
    agent: Agent[str, int] = MyAgent()
    result = await agent.invoke("test")
    assert isinstance(result, int)  # Output type matches signature
```

#### 2. Composition Laws

- [ ] **Associativity holds** - `(f >> g) >> h == f >> (g >> h)`
- [ ] **Left identity holds** - `Id() >> agent == agent`
- [ ] **Right identity holds** - `agent >> Id() == agent`

```python
# Example composition law tests
async def test_associativity():
    f, g, h = AgentF(), AgentG(), AgentH()
    input_data = create_test_input()

    # (f >> g) >> h
    result1 = await ((f >> g) >> h).invoke(input_data)

    # f >> (g >> h)
    result2 = await (f >> (g >> h)).invoke(input_data)

    assert result1 == result2

async def test_left_identity():
    agent = MyAgent()
    input_data = create_test_input()

    result1 = await (Id() >> agent).invoke(input_data)
    result2 = await agent.invoke(input_data)

    assert result1 == result2

async def test_right_identity():
    agent = MyAgent()
    input_data = create_test_input()

    result1 = await (agent >> Id()).invoke(input_data)
    result2 = await agent.invoke(input_data)

    assert result1 == result2
```

#### 3. Error Propagation

- [ ] **Errors compose correctly** - Result[A, E] >> Result[B, E] propagates E
- [ ] **Exceptions are documented** - Raised exceptions listed in docstring
- [ ] **Graceful degradation is explicit** - Fallback behavior is clear

```python
# Example error propagation test
async def test_error_propagation():
    failing_agent = FailingAgent()
    downstream_agent = DownstreamAgent()

    pipeline = failing_agent >> downstream_agent

    with pytest.raises(ExpectedError):
        await pipeline.invoke(test_input)
    # Verify downstream never executed when upstream fails
```

#### 4. State Isolation

- [ ] **No shared mutable state** - Each invocation is independent
- [ ] **Thread-safe if needed** - Concurrent invocations don't interfere
- [ ] **Idempotent where expected** - Same input → same output (for pure agents)

```python
# Example state isolation test
async def test_state_isolation():
    agent = MyAgent()

    # Concurrent invocations
    results = await asyncio.gather(
        agent.invoke(input1),
        agent.invoke(input2),
        agent.invoke(input1),  # Repeat
    )

    # Verify no cross-contamination
    assert results[0] == results[2]  # Same input → same output
    assert results[0] != results[1]  # Different inputs → different outputs
```

#### 5. Composition Operators

- [ ] **`>>` (right shift) works correctly** - Sequential composition
- [ ] **`__rshift__` preserves types** - Agent[A,B] >> Agent[B,C] → Agent[A,C]
- [ ] **Optimization is sound** - Fast paths don't break semantics (e.g., Id >> f = f)

```python
# Example composition operator test
def test_rshift_types():
    f: Agent[str, int] = StrToInt()
    g: Agent[int, bool] = IntToBool()

    composed: Agent[str, bool] = f >> g

    # Type checker should accept this
    result: bool = await composed.invoke("42")
    assert isinstance(result, bool)
```

#### 6. Practical Composability

- [ ] **Works with standard combinators** - maybe(), either(), parallel(), etc.
- [ ] **Integrates with Fix** - Can be used in fixed-point iteration
- [ ] **Compatible with Judge** - Can be evaluated against principles
- [ ] **Serializable if needed** - State can be saved/restored for stateful agents

```python
# Example combinator compatibility test
async def test_maybe_combinator():
    agent = MyAgent()
    maybe_agent = maybe(agent)

    # Should handle None gracefully
    result = await maybe_agent.invoke(None)
    assert result is None

    # Should pass through valid input
    result = await maybe_agent.invoke(valid_input)
    assert result == expected_output
```

### Verification Anti-Patterns

**❌ Don't:**
- Skip type annotations ("will add later")
- Test only happy path (ignore error cases)
- Assume single-threaded usage without documenting it
- Mix stateful and stateless behavior without clear boundaries
- Optimize before verifying correctness

**✅ Do:**
- Write composition law tests first
- Document state assumptions explicitly
- Test edge cases and error propagation
- Verify type safety with mypy --strict
- Use agents to verify agents (Judge, Contradict)

---

## Implementation Progress Template

Use this checklist to track progress when implementing kgents from spec. Copy this to `PROGRESS.md` and check off items as you complete them.

### Phase 0: Foundation

**Goal**: Set up environment and understand specs

- [ ] **Environment Setup**
  - [ ] Clone/fork kgents repository
  - [ ] Set up Python ≥3.11 virtual environment
  - [ ] Install dependencies: `pip install -e .`
  - [ ] Verify mypy installed: `mypy --version`
  - [ ] Set up IDE with type checking

- [ ] **Read Specifications** (in order)
  - [ ] `spec/principles.md` - 7 core principles
  - [ ] `spec/bootstrap.md` - 7 irreducible agents
  - [ ] `spec/anatomy.md` - What constitutes an agent
  - [ ] `spec/c-gents/composition.md` - How agents compose
  - [ ] `AUTONOMOUS_BOOTSTRAP_PROTOCOL.md` - Meta-level protocol
  - [ ] `docs/BOOTSTRAP_PROMPT.md` - This document

- [ ] **Initialize Runtime** (Step 0, before ANY code)
  - [ ] Set up ClaudeCLIRuntime or ClaudeRuntime
  - [ ] Test basic agent invocation (try kgent or creativity_coach)
  - [ ] Verify LLM access working

**Autopoiesis checkpoint**: Did I use agents to plan the implementation approach? (CreativityCoach, HypothesisEngine)

---

### Phase 1: Foundation - Types and Base Classes

**Goal**: Implement `types.py` with Agent[A, B] base class and composition operators

**Files to create/modify**:
- [ ] `impl/claude/bootstrap/types.py`

**Tasks**:
- [ ] Define `Agent[A, B]` abstract base class with `invoke` method
- [ ] Implement `__rshift__` composition operator (`>>`)
- [ ] Define `ComposedAgent[A, B, C]` for sequential composition
- [ ] Add `Result[T, E]` types (Ok, Err) for error handling
- [ ] Write module docstring with type signatures
- [ ] Add comprehensive type annotations

**Validation**:
- [ ] `mypy --strict types.py` passes with zero errors
- [ ] Manual review: Can compose agents with `f >> g` syntax?
- [ ] Test: `Id >> SomeAgent` should equal `SomeAgent` (type level)

**Autopoiesis checkpoint**:
- [ ] Used K-gent for naming decisions?
- [ ] Used CreativityCoach to explore API design?
- [ ] Used Judge to review against principles?

**Dependencies**: None (foundational)

---

### Phase 2: Level 1 Agents - Id and Ground

**Goal**: Implement simplest agents with no dependencies

#### 2.1 Id Agent

**Files**:
- [ ] `impl/claude/bootstrap/id.py`

**Tasks**:
- [ ] Read spec: `spec/bootstrap.md` (Id section)
- [ ] Use agent template from docs/BOOTSTRAP_PROMPT.md
- [ ] Implement `Id(Agent[A, A])` class
- [ ] Optimize `__rshift__`: `Id >> f` should return `f`
- [ ] Write tests: identity laws, composition laws

**Validation**:
- [ ] `mypy --strict id.py` passes
- [ ] Tests pass (associativity, left/right identity)
- [ ] Judge verdict: ACCEPT
- [ ] Contradict(spec, impl): None

**Autopoiesis**: Used agents to implement? (K-gent for naming, Judge for review)

#### 2.2 Ground Agent

**Files**:
- [ ] `impl/claude/bootstrap/ground.py`
- [ ] Optional: `impl/claude/bootstrap/ground_parser.py` (GroundParser agent)

**Tasks**:
- [ ] Read spec: `spec/bootstrap.md` (Ground section)
- [ ] Implement `Ground(Agent[Void, Facts])` or specific variant
- [ ] Load persona from `spec/k-gent/persona.md`
- [ ] Parse markdown → PersonaSeed structure
- [ ] Consider: Use LLM-based GroundParser for flexibility (see Phase 5.3)

**Validation**:
- [ ] Can load persona.md successfully
- [ ] PersonaSeed structure complete (name, values, heuristics, etc.)
- [ ] Judge verdict: ACCEPT
- [ ] Ground checklist complete (see PROTOCOL)

**Autopoiesis**: Used GroundParser agent (meta!)

**Dependencies**: types.py

---

### Phase 3: Level 2 Agents - Compose and Contradict

**Goal**: Implement agents that build on Level 1

#### 3.1 Compose Agent

**Files**:
- [ ] `impl/claude/bootstrap/compose.py`

**Tasks**:
- [ ] Read spec: `spec/bootstrap.md` (Compose section)
- [ ] Implement `Compose(Agent[(Agent, Agent), Agent])`
- [ ] Verify composition laws (associativity)
- [ ] Ensure types propagate correctly: `Agent[A,B] >> Agent[B,C] → Agent[A,C]`
- [ ] Handle edge cases (Id composition, error propagation)

**Validation**:
- [ ] Composition laws hold (associativity tests)
- [ ] Type safety verified with mypy
- [ ] Judge: ACCEPT

**Dependencies**: types.py, id.py

#### 3.2 Contradict Agent

**Files**:
- [ ] `impl/claude/bootstrap/contradict.py`

**Tasks**:
- [ ] Read spec: `spec/bootstrap.md` (Contradict section)
- [ ] Implement `Contradict(Agent[(A, B), Tension | None])`
- [ ] Define Tension types (LOGICAL, PRAGMATIC, AESTHETIC)
- [ ] Implement TensionDetector protocol for extensibility
- [ ] Add 2-3 basic detectors (semantic, structural)

**Validation**:
- [ ] Detects obvious contradictions (tests with known conflicts)
- [ ] Returns None when no tension (tests with aligned pairs)
- [ ] Judge: ACCEPT
- [ ] TensionDetector extensible (can add custom detectors)

**Dependencies**: types.py

---

### Phase 4: Level 3 Agents - Judge and Sublate

**Goal**: Implement evaluation and synthesis agents

#### 4.1 Judge Agent (Seven Mini-Judges Architecture)

**Files**:
- [ ] `impl/claude/bootstrap/judge.py`
- [ ] Optionally split into: `judge_tasteful.py`, `judge_curated.py`, etc.

**Tasks**:
- [ ] Read spec: `spec/bootstrap.md` (Judge section)
- [ ] Read principles: `spec/principles.md` (all 7)
- [ ] Implement seven mini-judges (see BOOTSTRAP_PROMPT section on Judge)
  - [ ] JudgeTasteful (compressed expertise)
  - [ ] JudgeCurated (unique value)
  - [ ] JudgeEthical (respects agency)
  - [ ] JudgeJoyful (inspiring)
  - [ ] JudgeComposable (works with others)
  - [ ] JudgeGenerative (regenerable)
  - [ ] JudgeHeterarchical (avoids hierarchy)
- [ ] Compose via `>>`: `judge = tasteful >> curated >> ... >> heterarchical`
- [ ] Aggregate PartialVerdicts → final Verdict (ACCEPT/REVISE/REJECT)

**Validation**:
- [ ] Test on Id agent: should ACCEPT
- [ ] Test on bootstrap agents: all should ACCEPT or REVISE (not REJECT)
- [ ] Test on deliberately bad code: should REVISE or REJECT
- [ ] Each mini-judge independently testable
- [ ] Judge itself passes Judge (meta!)

**Autopoiesis**: Used agents to implement Judge? (self-referential)

**Dependencies**: types.py, compose.py

#### 4.2 Sublate Agent

**Files**:
- [ ] `impl/claude/bootstrap/sublate.py`

**Tasks**:
- [ ] Read spec: `spec/bootstrap.md` (Sublate section)
- [ ] Implement `Sublate(Agent[Tension, Synthesis | HoldTension])`
- [ ] Define Synthesis and HoldTension types
- [ ] Implement synthesis logic (LLM-based or rule-based)
- [ ] Add pattern: conscious holding when synthesis not yet possible

**Validation**:
- [ ] Can synthesize simple tensions (tests)
- [ ] Can consciously hold unresolvable tensions
- [ ] Judge: ACCEPT

**Dependencies**: types.py, contradict.py (for Tension type)

---

### Phase 5: Level 4 Agent - Fix

**Goal**: Implement fixed-point iteration

**Files**:
- [ ] `impl/claude/bootstrap/fix.py`

**Tasks**:
- [ ] Read spec: `spec/bootstrap.md` (Fix section)
- [ ] Implement `Fix(Agent[(A → A), A])`
- [ ] Add convergence detection via `equality_check`
- [ ] Add max_iterations safety limit
- [ ] Implement stateful Fix pattern (memory between iterations)
- [ ] Add convenience function: `fix(transform, initial, equality_check)`

**Validation**:
- [ ] Converges for simple cases (tests)
- [ ] Respects max_iterations limit
- [ ] Accumulates state correctly (see PROTOCOL Pitfall 3)
- [ ] Judge: ACCEPT

**Dependencies**: types.py, compose.py

---

### Phase 6: Verification and Validation

**Goal**: Ensure all agents work correctly, compose properly, and pass Judge

**Tasks**:
- [ ] **Type checking**: `mypy --strict impl/claude/bootstrap/` (zero errors)
- [ ] **Unit tests**: Write pytest suite for each agent
  - [ ] Test composition laws (associativity, identity)
  - [ ] Test type safety (inputs/outputs match signatures)
  - [ ] Test error propagation
  - [ ] Test state isolation (concurrent invocations)
- [ ] **Integration tests**: Compose multiple agents, verify pipelines work
- [ ] **Judge all agents**: Each bootstrap agent should pass Judge
- [ ] **Contradict check**: Compare impl to spec, should find no tensions
- [ ] **Autopoiesis review**: Calculate % agent usage, document narrative

**Validation checklist** (from Verification section above):
- [ ] All composition law tests pass
- [ ] Type safety verified
- [ ] Error propagation works
- [ ] State isolation maintained
- [ ] Judge verdict: ACCEPT for all bootstrap agents
- [ ] Contradict(spec, impl) returns None for each agent
- [ ] Autopoiesis >50% (or qualitative: "felt agent-driven")

---

### Phase 7: Regeneration Test (Behavior Equivalence)

**Goal**: Validate that documents are sufficient by regenerating bootstrap

**Tasks**:
- [ ] **Backup current implementation**: `cp -r bootstrap/ bootstrap.backup/`
- [ ] **Delete implementation**: `rm -rf bootstrap/*.py` (keep types.py)
- [ ] **Regenerate from spec**: Follow BOOTSTRAP_PROMPT.md from scratch
- [ ] **Compare behavior**:
  - [ ] Run tests on regenerated code (should pass)
  - [ ] Compare outputs for same inputs (should match)
  - [ ] Run Contradict(original, regenerated) (no critical tensions)
  - [ ] Qualitative check: "Does this feel like the same agent?"
- [ ] **Document differences**: Style, variable names, comments OK; behavior must match

**Success criteria** (from improvement plan Decision 4):
- [ ] Tests pass on regenerated code
- [ ] Behavior equivalence: same inputs → same outputs
- [ ] No major tensions from Contradict
- [ ] Vibes check: "Feels right" (qualitative)
- [ ] Style differences acceptable (formatting, names, comments)

**NOT required**:
- Character-exact match (too brittle)
- Identical implementation approach (allow creativity)

---

### Phase 8: Documentation and Finalization

**Goal**: Complete documentation, examples, and final polish

**Tasks**:
- [ ] **Write examples**: `examples/` directory with usage examples
- [ ] **Update HYDRATE.md**: Document completion, any learnings
- [ ] **Write IMPLEMENTATION_PLAN retrospective**: What worked, what didn't
- [ ] **Autopoiesis report**: Final narrative of agent usage throughout
- [ ] **Commit with protocol-compliant message**:
  ```bash
  git commit -m "feat: Complete bootstrap agents implementation

  All 7 bootstrap agents implemented and validated.
  Autopoiesis: [X]% (K-gent [N]x, CreativityCoach [N]x, Judge [N]x, etc.)
  Judge: All agents ACCEPT
  Contradict: Zero tensions
  Tests: 100% pass rate
  Regeneration: Behavior equivalence verified"
  ```

---

## Progress Tracking Tips

### Daily Checklist

At start of each session:
1. [ ] Review PROGRESS.md, identify next phase
2. [ ] Initialize ProtocolObserver (if using observability)
3. [ ] Invoke agents for design decisions (Step 0)

During session:
4. [ ] Check off tasks as completed
5. [ ] Log agent usage (for autopoiesis narrative)
6. [ ] Document tensions/decisions

At end of session:
7. [ ] Update PROGRESS.md with current state
8. [ ] Generate autopoiesis narrative
9. [ ] Commit work with descriptive message

### Measuring Progress

**Quantitative**:
- Files completed / Total files
- Tests passing / Total tests
- Judge ACCEPT rate

**Qualitative**:
- Does code reflect principles?
- Is autopoiesis >50% (or "felt agent-driven")?
- Would I be proud to show this code?

### When Stuck

1. Consult Troubleshooting section (below)
2. Use K-gent (REFLECT mode) to explore problem
3. Use HypothesisEngine to generate approaches
4. Review AUTONOMOUS_BOOTSTRAP_PROTOCOL.md for guidance
5. Check HYDRATE.md for recent relevant changes

---

## Troubleshooting Common Errors

This section addresses common errors encountered during kgents implementation and provides actionable fixes.

### Error 1: Type Errors - "Type is not subscriptable"

**Symptom**:
```
TypeError: 'type' object is not subscriptable
Agent[A, B]
```

**Cause**: Using generic types without importing from `typing` or using Python <3.9 syntax.

**Fix**:
```python
# WRONG (Python <3.9)
class MyAgent(Agent[str, int]):  # Error if Agent not properly imported
    ...

# RIGHT
from typing import TypeVar
from bootstrap.types import Agent

A = TypeVar("A")
B = TypeVar("B")

class MyAgent(Agent[A, B]):  # Generic
    ...

# Or for concrete types
class StrToIntAgent(Agent[str, int]):  # Requires proper Agent base
    ...
```

**Prevention**: Always import `TypeVar` and define type variables at module level.

### Error 2: Module Import Issues - "No module named bootstrap"

**Symptom**:
```
ModuleNotFoundError: No module named 'bootstrap'
```

**Cause**: Package structure not set up correctly, or running from wrong directory.

**Fix**:
```bash
# Check pyproject.toml exists and has correct structure
cat pyproject.toml  # Should have [project] with dependencies

# Install in development mode
pip install -e .

# Or ensure you're running from correct directory
cd impl/claude/
python -m pytest  # Use module syntax
```

**Prevention**: Use proper Python packaging from the start. No `sys.path` hacks.

### Error 3: Contradict False Negatives - "Should detect tension but doesn't"

**Symptom**: `Contradict(a, b)` returns `None` when there's an obvious conflict.

**Cause**: Contradict implementation not comprehensive, or conflict is subtle/requires domain knowledge.

**Example**:
```python
# Spec says: "Agent must be stateless"
# Impl has: self.cache = {}  # State!
# But Contradict returns None—missed it
```

**Fix**:
1. **Extend TensionDetector**: Add domain-specific detectors
2. **Be explicit in specs**: State requirements clearly
3. **Use Judge as backup**: Judge can catch what Contradict misses

```python
# Add custom tension detector
class StatefulnessDetector(TensionDetector):
    def detect(self, spec: str, impl: str) -> Optional[Tension]:
        if "stateless" in spec.lower() and "self." in impl:
            # Check for instance variables (crude heuristic)
            return Tension(
                type=TensionType.PRAGMATIC,
                description="Spec requires stateless, impl has instance state",
                ...
            )
        return None
```

**Prevention**: Write explicit specs. Use both Contradict AND Judge.

### Error 4: Fix Non-Convergence - "Fix loops forever"

**Symptom**: `fix()` runs indefinitely without reaching fixed point.

**Cause**:
1. `equality_check` never returns True
2. Transform function doesn't converge
3. No state accumulation (see Pitfall 3 in PROTOCOL)

**Fix**:
```python
# Add max iterations and debugging
result = await fix(
    transform=my_transform,
    initial=initial_state,
    equality_check=lambda prev, curr: prev == curr,
    max_iterations=100,  # Safety limit
)

# Debug: Log iterations
async def debug_transform(state):
    print(f"Iteration: {state}")
    return await my_transform(state)

result = await fix(transform=debug_transform, ...)
```

**Prevention**:
- Always accumulate state/confidence in transform
- Test equality_check separately
- Add max_iterations safety limit
- Use Fix with memory pattern (see PROTOCOL Pitfall 3)

### Error 5: Low Autopoiesis Score (<20%)

**Symptom**: Implementation complete but hardly any agent usage.

**Cause**: Forgot to use agents during development, or used them only at beginning.

**Fix**:
1. **Retrospectively document**: "Where COULD I have used agents?"
2. **Refactor naming**: Use K-gent to rename poorly-named things
3. **Use Judge to review**: Let Judge suggest improvements
4. **For next feature**: Set reminder to invoke agents continuously

**Pattern for sustained autopoiesis**:
```python
# Checkpoint throughout development
async def feature_implementation():
    # Phase 1: Design (use CreativityCoach)
    design = await runtime.execute(creativity_coach(), ...)

    # Phase 2: Naming (use K-gent)
    name = await runtime.execute(kgent(), ...)

    # Phase 3: Implementation (manual, guided by design)
    code = implement_from_design(design)

    # Phase 4: Review (use Judge)
    verdict = await judge.invoke(JudgeInput(agent=code, ...))

    # Phase 5: Check consistency (use Contradict)
    tension = await contradict.invoke((spec, code))

    # Now autopoiesis is high (used agents at 4/5 phases)
```

**Prevention**: Use agents FIRST (see Step 0 in this doc), not just once at start.

### Error 6: Missing Type Annotations

**Symptom**: `mypy` reports errors, or runtime type checking fails.

**Cause**: Skipped type annotations, or used `Any` too liberally.

**Fix**:
```python
# WRONG: No annotations
def process(input):  # What type?
    return transform(input)  # What does this return?

# RIGHT: Full annotations
def process(input: InputType) -> OutputType:
    result: OutputType = transform(input)
    return result

# For generics
A = TypeVar("A")
B = TypeVar("B")

class MyAgent(Agent[A, B]):
    async def invoke(self, input: A) -> B:
        ...
```

**Prevention**: Use `mypy --strict` from the start. Fix warnings incrementally.

### Error 7: Composition Type Mismatches

**Symptom**:
```
TypeError: Cannot compose Agent[A, B] with Agent[C, D] (B != C)
```

**Cause**: Output type of first agent doesn't match input type of second.

**Example**:
```python
# WRONG: Type mismatch
agent1: Agent[str, int] = StrToInt()
agent2: Agent[str, bool] = StrToBool()  # Expects str, not int

pipeline = agent1 >> agent2  # Error: int -> str mismatch
```

**Fix**: Use adapters or check types manually.

```python
# Option 1: Add adapter
int_to_str = IntToStr()
pipeline = agent1 >> int_to_str >> agent2  # str -> int -> str -> bool

# Option 2: Use correct types from start
agent2b: Agent[int, bool] = IntToBool()
pipeline = agent1 >> agent2b  # str -> int -> bool ✓
```

**Prevention**: Write out type signatures before implementing. Verify B_1 == A_2 for `f: Agent[A, B_1]` and `g: Agent[A_2, C]`.

### Error 8: Async/Await Mistakes

**Symptom**:
```
RuntimeWarning: coroutine was never awaited
```

**Cause**: Forgot `await` on async function call.

**Fix**:
```python
# WRONG: Missing await
result = agent.invoke(input)  # Returns coroutine, not result

# RIGHT: Await the coroutine
result = await agent.invoke(input)

# For parallel execution
results = await asyncio.gather(
    agent1.invoke(input1),
    agent2.invoke(input2),
)
```

**Prevention**: All `Agent.invoke()` calls are async and require `await`.

### Error 9: Ground Extraction Failures

**Symptom**: `Ground` agent can't parse persona.md or returns incomplete data.

**Cause**: persona.md format doesn't match expected structure, or parser is too rigid.

**Fix**:
```python
# Option 1: Use GroundParser agent (recommended, see Phase 5.3)
parser = GroundParser()
persona_seed = await parser.invoke(persona_md_content)

# Option 2: Improve parser robustness
# Make parser handle variations in markdown format
# Use LLM-based extraction for flexibility
```

**Prevention**: Keep persona.md format consistent. Use agent-based parsing (GroundParser) for flexibility.

### Error 10: Judge Rejects Everything

**Symptom**: Judge always returns REJECT, even for reasonable code.

**Cause**: Overly strict principles, or Judge implementation has bugs.

**Fix**:
1. **Check Judge implementation**: Verify seven mini-judges logic
2. **Review principles**: Are they realistic? (See `spec/principles.md`)
3. **Use REVISE mode**: Judge should suggest improvements, not just reject
4. **Incremental validation**: Test Judge on known-good agents first

```python
# Debug Judge by testing on Id (should ACCEPT)
verdict = await judge.invoke(JudgeInput(
    agent_spec=id_agent_code,
    principles=PRINCIPLES
))
assert verdict.type == VerdictType.ACCEPT  # Id should always pass

# If this fails, Judge is too strict or buggy
```

**Prevention**: Validate Judge against bootstrap agents first (they should all ACCEPT).

### Troubleshooting Checklist

When stuck:

1. **Check types first** - Most errors are type mismatches (use `mypy --strict`)
2. **Verify imports** - Ensure proper package structure (no `sys.path` hacks)
3. **Test components in isolation** - Before composing, verify each agent works alone
4. **Use agents to debug** - K-gent (REFLECT mode) can help identify issues
5. **Check Ground** - Are environmental assumptions explicit?
6. **Read error messages carefully** - Python tracebacks point to exact line
7. **Consult HYDRATE.md** - Recent changes and known issues documented there

### Getting Help

If errors persist:
1. Check `HYDRATE.md` for recent changes that might affect your code
2. Review `AUTONOMOUS_BOOTSTRAP_PROTOCOL.md` "Common Pitfalls" section
3. Use Contradict to compare your impl with spec
4. Use Judge to get specific feedback on what's wrong
5. Use K-gent (REFLECT mode) to explore the problem space

---

## Quick Start

```bash
claude "Read docs/BOOTSTRAP_PROMPT.md. I want to implement {X}. Start with CreativityCoach."
```

Use kgents agents to HELP you implement—that's autopoiesis.
