#!/usr/bin/env bash
#
# kgents pre-push hook (HEAVY) - OPTIMIZED
#
# Philosophy: Gate pushes with rigorous verification.
# This is the last line of defense before CI.
#
# Optimizations (2025-12-16, updated 2025-12-19):
#   - Parallel test execution with pytest-xdist (-n 5 default)
#   - Combined test passes (unit + law + property in single run)
#   - Smart marker detection (skip empty passes)
#   - Reduced collection overhead
#   - Worker cap at 5 (was auto=all CPUs, caused system thrashing)
#
# Checks:
#   1. Ruff lint (strict, blocking)
#   2. Mypy (strict, blocking)
#   3. All tests in single parallel run (blocking)
#
# Optional (can skip with KGENTS_SKIP_HEAVY=1):
#   - Chaos tests (accursed share)
#

# Note: We intentionally don't use `set -e` because we handle exit codes manually
# with FAILED variable tracking. `set -e` would exit prematurely on non-blocking checks.

# Source library (resolve symlinks to find actual script location)
SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}" 2>/dev/null || echo "${BASH_SOURCE[0]}")")" && pwd)"
source "$SCRIPT_DIR/lib.sh"

REPO_ROOT=$(get_repo_root)
cd "$REPO_ROOT"

# Parse push info
REMOTE="$1"
URL="$2"

echo -e "${BOLD}pre-push${NC} ${CYAN}(heavy verification before push to ${REMOTE})${NC}"
echo ""

# Check for skip flag
if [ "${KGENTS_SKIP_HEAVY:-0}" = "1" ]; then
    warn "KGENTS_SKIP_HEAVY=1 detected. Skipping heavy tests."
    warn "Use with caution - CI will still run these tests."
    exit 0
fi

# Check dependencies
require_uv

TOTAL_STEPS=3
FAILED=0

# Detect CPU count for parallel execution
# KGENTS_PYTEST_WORKERS overrides auto-detection (default: 5 to reduce system load)
if [ -n "${KGENTS_PYTEST_WORKERS:-}" ]; then
    CPU_COUNT="$KGENTS_PYTEST_WORKERS"
elif command -v nproc &> /dev/null; then
    CPU_COUNT=$(( $(nproc) / 2 ))
    [ "$CPU_COUNT" -lt 4 ] && CPU_COUNT=4
    [ "$CPU_COUNT" -gt 5 ] && CPU_COUNT=5
elif command -v sysctl &> /dev/null; then
    TOTAL_CPU=$(sysctl -n hw.ncpu 2>/dev/null || echo "8")
    CPU_COUNT=$(( TOTAL_CPU / 2 ))
    [ "$CPU_COUNT" -lt 4 ] && CPU_COUNT=4
    [ "$CPU_COUNT" -gt 5 ] && CPU_COUNT=5
else
    CPU_COUNT=5
fi

# =============================================================================
# Step 1: Lint (strict - non-blocking until codebase is clean)
# =============================================================================
section "Ruff lint (strict)" 1 $TOTAL_STEPS

cd "$REPO_ROOT/impl/claude"
LINT_OUTPUT=$(uv run ruff check agents/ bootstrap/ runtime/ protocols/ testing/ 2>&1)
LINT_EXIT=$?
if [ $LINT_EXIT -eq 0 ]; then
    success "Lint passed"
else
    # Count issues instead of showing all output
    LINT_COUNT=$(echo "$LINT_OUTPUT" | grep -c "^[A-Z][0-9]" || echo "0")
    warn "Lint: $LINT_COUNT issues (non-blocking, run 'ruff check' for details)"
fi
cd "$REPO_ROOT"
echo ""

# =============================================================================
# Step 2: Type check (strict)
# =============================================================================
section "Mypy (strict)" 2 $TOTAL_STEPS

cd "$REPO_ROOT/impl/claude"
MYPY_OUTPUT=$(uv run mypy --strict --explicit-package-bases agents/ bootstrap/ runtime/ 2>&1)
MYPY_EXIT=$?
if [ $MYPY_EXIT -eq 0 ]; then
    success "Type check passed"
else
    # Count errors instead of showing all output
    MYPY_COUNT=$(echo "$MYPY_OUTPUT" | grep -c ": error:" || echo "0")
    warn "Mypy: $MYPY_COUNT errors (non-blocking, run 'mypy' for details)"
fi
cd "$REPO_ROOT"
echo ""

# =============================================================================
# Step 3: All tests (parallel, combined pass)
# =============================================================================
section "All tests (parallel: $CPU_COUNT workers)" 3 $TOTAL_STEPS

cd "$REPO_ROOT/impl/claude"

# Single combined test run with parallel execution
# Excludes: slow, tier3 (E2E), accursed_share (chaos - run separately if needed)
# Includes: unit, law, property tests in one pass
#
# Optimizations applied:
#   1. Combined passes: unit + law + property in single run (was 5 separate)
#   2. Parallel execution: -n $CPU_COUNT with loadfile distribution
#   3. Eliminated empty passes: integration marker had 0 tests
info "Running tests with $CPU_COUNT workers (combined pass)..."
TEST_OUTPUT=$(uv run pytest \
    -m "not slow and not tier3 and not accursed_share" \
    -n "$CPU_COUNT" \
    --tb=no \
    -q \
    --dist=loadfile \
    2>&1)
TEST_EXIT=$?

if [ $TEST_EXIT -eq 0 ]; then
    # Extract summary line (e.g., "19000 passed in 45.34s")
    SUMMARY=$(echo "$TEST_OUTPUT" | tail -1)
    success "All tests: $SUMMARY"
else
    # Show last few lines on failure
    SUMMARY=$(echo "$TEST_OUTPUT" | tail -5)
    error "Tests failed:"
    echo "$SUMMARY"
    FAILED=1
fi
cd "$REPO_ROOT"
echo ""

# =============================================================================
# Optional: Chaos tests (accursed share) - skip with KGENTS_SKIP_CHAOS=1
# =============================================================================
# Note: Property tests are now included in the main test run above
if [ "${KGENTS_SKIP_CHAOS:-0}" != "1" ]; then
    info "Running chaos tests (accursed share, non-blocking)..."
    cd "$REPO_ROOT/impl/claude"
    CHAOS_OUTPUT=$(uv run pytest -m "accursed_share" -n "$CPU_COUNT" --tb=no -q 2>&1)
    CHAOS_EXIT=$?
    if [ $CHAOS_EXIT -eq 0 ]; then
        SUMMARY=$(echo "$CHAOS_OUTPUT" | tail -1)
        success "Chaos tests: $SUMMARY"
    elif [ $CHAOS_EXIT -eq 5 ]; then
        info "No chaos tests found (skipped)"
    else
        info "Chaos tests discovered issues (expected, non-blocking)"
    fi
    cd "$REPO_ROOT"
    echo ""
fi

# =============================================================================
# Summary
# =============================================================================
hr
if [ $FAILED -eq 0 ]; then
    success "pre-push complete. All checks passed."
    hr
    exit 0
else
    error "pre-push FAILED. Fix issues before pushing."
    echo ""
    info "To bypass (not recommended):"
    info "  KGENTS_SKIP_HEAVY=1 git push"
    hr
    exit 1
fi
