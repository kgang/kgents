# Autonomous Bootstrap Protocol

**A meta-level protocol for Kent + Claude Code to implement kgents.**

This document is self-referential: Claude Code reads it to guide implementation, and the implementation validates the protocol.

---

## Core Principle: Autopoiesis First

**Use kgents to build kgents from the FIRST line of code.**

```python
# Step 0: Before writing ANY implementation
from runtime import ClaudeCLIRuntime
from agents.k import kgent, DialogueMode, DialogueInput
from agents.a import creativity_coach, CreativityInput, CreativityMode

runtime = ClaudeCLIRuntime()

# Use K-gent for naming decisions
name = await runtime.execute(kgent(), DialogueInput(
    message="What should I name this component?",
    mode=DialogueMode.ADVISE
))

# Use CreativityCoach for design exploration
design = await runtime.execute(creativity_coach(), CreativityInput(
    seed="the problem I'm solving",
    mode=CreativityMode.EXPAND
))
```

### Complete Workflow Example: Agent-Driven Design

**Scenario**: Implementing a new "MemoryAgent" that maintains conversation history.

**Session demonstrates >50% autopoiesis:**

```python
from runtime import ClaudeCLIRuntime
from agents.a import creativity_coach, CreativityMode, CreativityInput
from agents.k import kgent, DialogueMode, DialogueInput
from agents.b import hypothesis_engine, HypothesisInput
from bootstrap import judge, contradict, sublate

runtime = ClaudeCLIRuntime()

# 1. EXPLORATION (CreativityCoach)
print("=== Phase 1: Design Exploration ===")
exploration = await runtime.execute(
    creativity_coach(),
    CreativityInput(
        seed="Agent that maintains conversation history for context",
        mode=CreativityMode.EXPAND
    )
)
# Output: 5 design approaches (in-memory list, SQLite, file-based, Redis, etc.)

# 2. VALIDATION (HypothesisEngine)
print("=== Phase 2: Architecture Validation ===")
validation = await runtime.execute(
    hypothesis_engine(),
    HypothesisInput(
        observations=[
            "Need persistence across sessions",
            "Must be fast for real-time chat",
            "Should handle 1000+ messages"
        ],
        domain="software architecture",
        question="Which storage approach is most suitable?"
    )
)
# Output: Hypotheses ranking approaches by criteria

# 3. NAMING (K-gent)
print("=== Phase 3: Component Naming ===")
naming = await runtime.execute(
    kgent(),
    DialogueInput(
        message="I'm implementing a conversation history agent. Should I call it MemoryAgent, HistoryAgent, or ContextAgent?",
        mode=DialogueMode.ADVISE
    )
)
# Output: "HistoryAgent - 'memory' is overloaded, 'history' is precise"

# 4. IMPLEMENTATION (Manual, guided by above)
print("=== Phase 4: Implementation ===")
# Write HistoryAgent based on chosen architecture
# (This part is mechanical translation from design)

# 5. JUDGMENT (Judge)
print("=== Phase 5: Quality Check ===")
verdict = await judge.invoke(JudgeInput(
    agent_spec=history_agent_code,
    principles=PRINCIPLES
))
if verdict.type == VerdictType.REVISE:
    print(f"Revisions needed: {verdict.revisions}")
    # Apply revisions, re-run judge (Fix pattern)

# 6. CONSISTENCY CHECK (Contradict)
print("=== Phase 6: Consistency Verification ===")
tension = await contradict.invoke((spec_expectations, actual_implementation))
if tension:
    print(f"Tension detected: {tension.description}")
    resolution = await sublate.invoke(tension)
    print(f"Resolution: {resolution.explanation}")

# Autopoiesis score: 5/6 phases used agents (83%)
```

**Key points demonstrated**:
1. **Agents used continuously** - not just initial setup
2. **Design decisions delegated** to appropriate agents
3. **Human judgment preserved** - final implementation choice remains with Kent
4. **Iterative refinement** - Judge → revise → Judge (Fix pattern)
5. **Explicit verification** - Contradict/Sublate for consistency

**This session achieves >50% autopoiesis**: Design, validation, naming, judgment, and consistency checking all agent-driven.

**Autopoiesis Score** = (lines generated by kgents agents) / (total lines)
- Target: >50%
- Measure this. Track it. Improve it.

---

## Ground: The Bootstrap Kernel

```
impl/claude/
├── bootstrap/           # 7 irreducible agents
│   ├── id.py           # Identity: A → A
│   ├── compose.py      # Composition: (Agent, Agent) → Agent
│   ├── judge.py        # Judgment: (Agent, Principles) → Verdict
│   ├── ground.py       # Grounding: Void → Facts
│   ├── contradict.py   # Contradiction: (A, B) → Tension | None
│   ├── sublate.py      # Synthesis: Tension → Synthesis | Hold
│   ├── fix.py          # Fixed-point: (A → A) → A
│   └── types.py        # Agent[A, B] base class
├── agents/
│   ├── a/              # Abstract + Art (AbstractSkeleton, CreativityCoach)
│   ├── b/              # Bio/Scientific (HypothesisEngine, Robin)
│   ├── c/              # Category theory (Maybe, Either, parallel, race, branch, switch)
│   ├── h/              # Dialectics (Hegel, Jung, Lacan)
│   └── k/              # Persona (KgentAgent, PersonaQueryAgent, EvolutionAgent)
└── runtime/            # LLM execution (ClaudeCLIRuntime, ClaudeRuntime, OpenRouterRuntime)
```

---

## Bootstrap Agent Decision Matrix

**When to invoke which bootstrap agent?** Use this table for real-time decision-making:

| Situation | Agent(s) | Mode/Pattern | Example |
|-----------|----------|--------------|---------|
| **Naming a component** | K-gent | `DialogueMode.ADVISE` | "What should I call this class?" |
| **Design uncertainty** | CreativityCoach → HypothesisEngine → Judge | `EXPAND` → validate → evaluate | Exploring architecture options |
| **Configuration conflicts** | Contradict → Sublate | Detect tension → synthesize or hold | Config defaults vs user overrides |
| **Need to retry/iterate** | Fix | Define transform + equality_check | Polling, convergence, retry logic |
| **Two approaches contradict** | Contradict → Sublate | All modes (LOGICAL, PRAGMATIC, etc.) | "Spec says X, impl does Y" |
| **Starting from scratch** | Ground | Load persona/world/history | Initial project setup, persona extraction |
| **Building pipelines** | Compose (`>>`) | Sequential composition | `validate >> transform >> persist` |
| **Quality check** | Judge | Seven mini-judges composed | Review against 7 principles |
| **Identity/passthrough** | Id | Composition unit | Testing, default case, category laws |

### Decision Tree for Common Scenarios

**Scenario: "I'm stuck on a design decision"**
```
1. Use CreativityCoach (EXPAND mode) to explore options
2. Use K-gent (CHALLENGE mode) to check against persona preferences
3. Use HypothesisEngine to validate architectural soundness
4. Use Judge to evaluate against principles
```

**Scenario: "Something feels wrong but I can't pinpoint it"**
```
1. Use Contradict to compare current vs expected
2. If tension found → Sublate to synthesize or consciously hold
3. If no tension but still feels off → use K-gent (REFLECT mode)
```

**Scenario: "I need this to work reliably"**
```
1. Use Fix for retry/convergence pattern
2. Use Judge to ensure quality
3. Use Contradict to verify consistency with spec
```

**Scenario: "Starting a new implementation"**
```
1. Ground: Load persona and context
2. CreativityCoach: Explore design space
3. K-gent: Get naming/style guidance
4. Compose: Build pipeline from small agents
5. Judge: Validate against principles
6. Fix: Iterate until stable
```

---

## The Protocol

### Principle: Heterarchical Collaboration

Neither Kent nor Claude Code is "in charge." The collaboration is heterarchical:
- **Kent provides Ground**: preferences, judgment calls, domain knowledge
- **Claude Code provides Fix**: iteration, exploration, mechanical translation
- **Both apply Judge**: reviewing against the 7 principles

### Principle: Spec Before Impl

1. Write specification in `spec/{letter}-gents/`
2. Read spec completely before implementing
3. Implement as mechanical translation
4. Validate: `Contradict(impl, spec) = None`

---

## Required Patterns

### Pattern: Events are Sublate Traces

State changes MUST emit events:
```python
# WRONG
del self._sessions[id]
return True

# RIGHT
del self._sessions[id]
await self._emit_event(SessionRemoved(session_id=id))
return True
```

### Pattern: Ground Includes Environment

Shell, platform, package structure are Ground—explicit, not assumed:
```python
# WRONG: Assumes bash
command = "read -p 'prompt' var"

# RIGHT: POSIX is Ground
command = "printf 'prompt ' && read var"
```

**Ground checklist**:
- [ ] Shell commands are POSIX-compatible
- [ ] Package structure in `pyproject.toml` (no `sys.path` hacks)
- [ ] Config defaults merge, not overwrite
- [ ] Framework constraints documented

### Pattern: Fix Needs Memory

Fixed-point iteration carries state:
```python
# WRONG: Stateless
def detect(session) -> Result:
    return Result(confidence=0.2)

# RIGHT: Stateful
def detect(session, previous: Result) -> Result:
    if current_state == previous.state:
        return Result(confidence=min(1.0, previous.confidence + 0.2))
    return Result(state=current_state, confidence=0.2)
```

### Pattern: Sublate, Don't Overwrite

Merge configurations, preserve both sides:
```python
# WRONG
config = data.get("config", {})

# RIGHT
config = {**defaults, **data.get("config", {})}
```

### Pattern: Conflicts are Data

Never swallow exceptions silently:
```python
# WRONG
except Exception:
    pass

# RIGHT
except Exception as e:
    self.log.warning(f"Conflict: {e}")
```

---

## Execution Protocol

### For Each Implementation Phase

```
LOOP:
  1. Use kgents agents to explore design (CreativityCoach, K-gent)
  2. Read relevant spec
  3. Implement (mechanically translate, use LLM to generate boilerplate)
  4. Kent reviews (Judge)
  5. IF accept: mark complete, next phase
     ELIF revise: Claude Code modifies
     ELIF reject: discuss, potentially Sublate
```

### Termination (Fix)

Implementation is complete when:
```python
def protocol_complete() -> bool:
    return all([
        spec_exists(f"spec/{letter}-gents/"),
        impl_exists(f"impl/claude/agents/{letter}/"),
        Judge(impl, Principles).verdict == "accept",
        Contradict(impl, spec) is None,
        autopoiesis_score() > 0.5,
        kent_approves(),
    ])
```

---

## Meta-Instructions for Claude Code

When reading this document:

1. **Instantiate runtime FIRST** — Before any implementation
2. **Use K-gent for naming** — Don't guess, ask
3. **Use CreativityCoach for design** — Explore before coding
4. **Read specs completely** — Understand before implementing
5. **Apply the 7 patterns** — Events, Ground, Fix memory, Sublate merge, Conflicts as data
6. **Measure autopoiesis** — Track what kgents generated vs. manual

### On Tensions

If you encounter contradictions:
1. Surface them explicitly (Contradict)
2. Propose synthesis or hold (Sublate)
3. Let Kent decide (Judge)

### On Uncertainty

If spec is unclear:
1. Use HypothesisEngine to generate possibilities
2. Ask Kent for clarification
3. Propose and iterate (Fix)

---

## Quick Start

```bash
# Begin new implementation:
claude "Read AUTONOMOUS_BOOTSTRAP_PROTOCOL.md. I want to implement {X}. Start by using CreativityCoach to explore the design space."
```

---

## Self-Description

This protocol is itself an application of bootstrap agents:

| Protocol Element | Bootstrap Agent |
|------------------|-----------------|
| "Ground" section | Ground |
| Phase ordering | Compose |
| Kent checkpoints | Judge |
| Termination condition | Fix |
| "On Tensions" section | Contradict + Sublate |
| Autopoiesis imperative | Id (self-reference) |

The protocol bootstraps the bootstrap.
